
FreeRTOS_SprintsChallenges_UserStory2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005472  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000046  00800060  00005472  00005506  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000064d  008000a6  008000a6  0000554c  2**0
                  ALLOC
  3 .stab         00008d54  00000000  00000000  0000554c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000048f6  00000000  00000000  0000e2a0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 55 0e 	jmp	0x1caa	; 0x1caa <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e7       	ldi	r30, 0x72	; 114
      68:	f4 e5       	ldi	r31, 0x54	; 84
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 3a       	cpi	r26, 0xA6	; 166
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a6 ea       	ldi	r26, 0xA6	; 166
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 3f       	cpi	r26, 0xF3	; 243
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 67 0b 	call	0x16ce	; 0x16ce <main>
      8a:	0c 94 37 2a 	jmp	0x546e	; 0x546e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_WritePin>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_WritePin+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	89 83       	std	Y+1, r24	; 0x01
      9e:	6a 83       	std	Y+2, r22	; 0x02
      a0:	8a 81       	ldd	r24, Y+2	; 0x02
      a2:	81 30       	cpi	r24, 0x01	; 1
      a4:	09 f0       	breq	.+2      	; 0xa8 <DIO_WritePin+0x16>
      a6:	6d c0       	rjmp	.+218    	; 0x182 <DIO_WritePin+0xf0>
      a8:	89 81       	ldd	r24, Y+1	; 0x01
      aa:	88 30       	cpi	r24, 0x08	; 8
      ac:	a0 f4       	brcc	.+40     	; 0xd6 <DIO_WritePin+0x44>
      ae:	ab e3       	ldi	r26, 0x3B	; 59
      b0:	b0 e0       	ldi	r27, 0x00	; 0
      b2:	eb e3       	ldi	r30, 0x3B	; 59
      b4:	f0 e0       	ldi	r31, 0x00	; 0
      b6:	80 81       	ld	r24, Z
      b8:	48 2f       	mov	r20, r24
      ba:	89 81       	ldd	r24, Y+1	; 0x01
      bc:	28 2f       	mov	r18, r24
      be:	30 e0       	ldi	r19, 0x00	; 0
      c0:	81 e0       	ldi	r24, 0x01	; 1
      c2:	90 e0       	ldi	r25, 0x00	; 0
      c4:	02 2e       	mov	r0, r18
      c6:	02 c0       	rjmp	.+4      	; 0xcc <DIO_WritePin+0x3a>
      c8:	88 0f       	add	r24, r24
      ca:	99 1f       	adc	r25, r25
      cc:	0a 94       	dec	r0
      ce:	e2 f7       	brpl	.-8      	; 0xc8 <DIO_WritePin+0x36>
      d0:	84 2b       	or	r24, r20
      d2:	8c 93       	st	X, r24
      d4:	c8 c0       	rjmp	.+400    	; 0x266 <DIO_WritePin+0x1d4>
      d6:	89 81       	ldd	r24, Y+1	; 0x01
      d8:	88 30       	cpi	r24, 0x08	; 8
      da:	c8 f0       	brcs	.+50     	; 0x10e <DIO_WritePin+0x7c>
      dc:	89 81       	ldd	r24, Y+1	; 0x01
      de:	80 31       	cpi	r24, 0x10	; 16
      e0:	b0 f4       	brcc	.+44     	; 0x10e <DIO_WritePin+0x7c>
      e2:	a8 e3       	ldi	r26, 0x38	; 56
      e4:	b0 e0       	ldi	r27, 0x00	; 0
      e6:	e8 e3       	ldi	r30, 0x38	; 56
      e8:	f0 e0       	ldi	r31, 0x00	; 0
      ea:	80 81       	ld	r24, Z
      ec:	48 2f       	mov	r20, r24
      ee:	89 81       	ldd	r24, Y+1	; 0x01
      f0:	88 2f       	mov	r24, r24
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	08 97       	sbiw	r24, 0x08	; 8
      f6:	9c 01       	movw	r18, r24
      f8:	81 e0       	ldi	r24, 0x01	; 1
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	02 2e       	mov	r0, r18
      fe:	02 c0       	rjmp	.+4      	; 0x104 <DIO_WritePin+0x72>
     100:	88 0f       	add	r24, r24
     102:	99 1f       	adc	r25, r25
     104:	0a 94       	dec	r0
     106:	e2 f7       	brpl	.-8      	; 0x100 <DIO_WritePin+0x6e>
     108:	84 2b       	or	r24, r20
     10a:	8c 93       	st	X, r24
     10c:	ac c0       	rjmp	.+344    	; 0x266 <DIO_WritePin+0x1d4>
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	80 31       	cpi	r24, 0x10	; 16
     112:	c8 f0       	brcs	.+50     	; 0x146 <DIO_WritePin+0xb4>
     114:	89 81       	ldd	r24, Y+1	; 0x01
     116:	88 31       	cpi	r24, 0x18	; 24
     118:	b0 f4       	brcc	.+44     	; 0x146 <DIO_WritePin+0xb4>
     11a:	a5 e3       	ldi	r26, 0x35	; 53
     11c:	b0 e0       	ldi	r27, 0x00	; 0
     11e:	e5 e3       	ldi	r30, 0x35	; 53
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	80 81       	ld	r24, Z
     124:	48 2f       	mov	r20, r24
     126:	89 81       	ldd	r24, Y+1	; 0x01
     128:	88 2f       	mov	r24, r24
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	40 97       	sbiw	r24, 0x10	; 16
     12e:	9c 01       	movw	r18, r24
     130:	81 e0       	ldi	r24, 0x01	; 1
     132:	90 e0       	ldi	r25, 0x00	; 0
     134:	02 2e       	mov	r0, r18
     136:	02 c0       	rjmp	.+4      	; 0x13c <DIO_WritePin+0xaa>
     138:	88 0f       	add	r24, r24
     13a:	99 1f       	adc	r25, r25
     13c:	0a 94       	dec	r0
     13e:	e2 f7       	brpl	.-8      	; 0x138 <DIO_WritePin+0xa6>
     140:	84 2b       	or	r24, r20
     142:	8c 93       	st	X, r24
     144:	90 c0       	rjmp	.+288    	; 0x266 <DIO_WritePin+0x1d4>
     146:	89 81       	ldd	r24, Y+1	; 0x01
     148:	88 31       	cpi	r24, 0x18	; 24
     14a:	08 f4       	brcc	.+2      	; 0x14e <DIO_WritePin+0xbc>
     14c:	8c c0       	rjmp	.+280    	; 0x266 <DIO_WritePin+0x1d4>
     14e:	89 81       	ldd	r24, Y+1	; 0x01
     150:	80 32       	cpi	r24, 0x20	; 32
     152:	08 f0       	brcs	.+2      	; 0x156 <DIO_WritePin+0xc4>
     154:	88 c0       	rjmp	.+272    	; 0x266 <DIO_WritePin+0x1d4>
     156:	a2 e3       	ldi	r26, 0x32	; 50
     158:	b0 e0       	ldi	r27, 0x00	; 0
     15a:	e2 e3       	ldi	r30, 0x32	; 50
     15c:	f0 e0       	ldi	r31, 0x00	; 0
     15e:	80 81       	ld	r24, Z
     160:	48 2f       	mov	r20, r24
     162:	89 81       	ldd	r24, Y+1	; 0x01
     164:	88 2f       	mov	r24, r24
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	48 97       	sbiw	r24, 0x18	; 24
     16a:	9c 01       	movw	r18, r24
     16c:	81 e0       	ldi	r24, 0x01	; 1
     16e:	90 e0       	ldi	r25, 0x00	; 0
     170:	02 2e       	mov	r0, r18
     172:	02 c0       	rjmp	.+4      	; 0x178 <DIO_WritePin+0xe6>
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	0a 94       	dec	r0
     17a:	e2 f7       	brpl	.-8      	; 0x174 <DIO_WritePin+0xe2>
     17c:	84 2b       	or	r24, r20
     17e:	8c 93       	st	X, r24
     180:	72 c0       	rjmp	.+228    	; 0x266 <DIO_WritePin+0x1d4>
     182:	8a 81       	ldd	r24, Y+2	; 0x02
     184:	88 23       	and	r24, r24
     186:	09 f0       	breq	.+2      	; 0x18a <DIO_WritePin+0xf8>
     188:	6e c0       	rjmp	.+220    	; 0x266 <DIO_WritePin+0x1d4>
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	88 30       	cpi	r24, 0x08	; 8
     18e:	a8 f4       	brcc	.+42     	; 0x1ba <DIO_WritePin+0x128>
     190:	ab e3       	ldi	r26, 0x3B	; 59
     192:	b0 e0       	ldi	r27, 0x00	; 0
     194:	eb e3       	ldi	r30, 0x3B	; 59
     196:	f0 e0       	ldi	r31, 0x00	; 0
     198:	80 81       	ld	r24, Z
     19a:	48 2f       	mov	r20, r24
     19c:	89 81       	ldd	r24, Y+1	; 0x01
     19e:	28 2f       	mov	r18, r24
     1a0:	30 e0       	ldi	r19, 0x00	; 0
     1a2:	81 e0       	ldi	r24, 0x01	; 1
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	02 2e       	mov	r0, r18
     1a8:	02 c0       	rjmp	.+4      	; 0x1ae <DIO_WritePin+0x11c>
     1aa:	88 0f       	add	r24, r24
     1ac:	99 1f       	adc	r25, r25
     1ae:	0a 94       	dec	r0
     1b0:	e2 f7       	brpl	.-8      	; 0x1aa <DIO_WritePin+0x118>
     1b2:	80 95       	com	r24
     1b4:	84 23       	and	r24, r20
     1b6:	8c 93       	st	X, r24
     1b8:	56 c0       	rjmp	.+172    	; 0x266 <DIO_WritePin+0x1d4>
     1ba:	89 81       	ldd	r24, Y+1	; 0x01
     1bc:	88 30       	cpi	r24, 0x08	; 8
     1be:	d0 f0       	brcs	.+52     	; 0x1f4 <DIO_WritePin+0x162>
     1c0:	89 81       	ldd	r24, Y+1	; 0x01
     1c2:	80 31       	cpi	r24, 0x10	; 16
     1c4:	b8 f4       	brcc	.+46     	; 0x1f4 <DIO_WritePin+0x162>
     1c6:	a8 e3       	ldi	r26, 0x38	; 56
     1c8:	b0 e0       	ldi	r27, 0x00	; 0
     1ca:	e8 e3       	ldi	r30, 0x38	; 56
     1cc:	f0 e0       	ldi	r31, 0x00	; 0
     1ce:	80 81       	ld	r24, Z
     1d0:	48 2f       	mov	r20, r24
     1d2:	89 81       	ldd	r24, Y+1	; 0x01
     1d4:	88 2f       	mov	r24, r24
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	08 97       	sbiw	r24, 0x08	; 8
     1da:	9c 01       	movw	r18, r24
     1dc:	81 e0       	ldi	r24, 0x01	; 1
     1de:	90 e0       	ldi	r25, 0x00	; 0
     1e0:	02 2e       	mov	r0, r18
     1e2:	02 c0       	rjmp	.+4      	; 0x1e8 <DIO_WritePin+0x156>
     1e4:	88 0f       	add	r24, r24
     1e6:	99 1f       	adc	r25, r25
     1e8:	0a 94       	dec	r0
     1ea:	e2 f7       	brpl	.-8      	; 0x1e4 <DIO_WritePin+0x152>
     1ec:	80 95       	com	r24
     1ee:	84 23       	and	r24, r20
     1f0:	8c 93       	st	X, r24
     1f2:	39 c0       	rjmp	.+114    	; 0x266 <DIO_WritePin+0x1d4>
     1f4:	89 81       	ldd	r24, Y+1	; 0x01
     1f6:	80 31       	cpi	r24, 0x10	; 16
     1f8:	d0 f0       	brcs	.+52     	; 0x22e <DIO_WritePin+0x19c>
     1fa:	89 81       	ldd	r24, Y+1	; 0x01
     1fc:	88 31       	cpi	r24, 0x18	; 24
     1fe:	b8 f4       	brcc	.+46     	; 0x22e <DIO_WritePin+0x19c>
     200:	a5 e3       	ldi	r26, 0x35	; 53
     202:	b0 e0       	ldi	r27, 0x00	; 0
     204:	e5 e3       	ldi	r30, 0x35	; 53
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	48 2f       	mov	r20, r24
     20c:	89 81       	ldd	r24, Y+1	; 0x01
     20e:	88 2f       	mov	r24, r24
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	40 97       	sbiw	r24, 0x10	; 16
     214:	9c 01       	movw	r18, r24
     216:	81 e0       	ldi	r24, 0x01	; 1
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	02 2e       	mov	r0, r18
     21c:	02 c0       	rjmp	.+4      	; 0x222 <DIO_WritePin+0x190>
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	0a 94       	dec	r0
     224:	e2 f7       	brpl	.-8      	; 0x21e <DIO_WritePin+0x18c>
     226:	80 95       	com	r24
     228:	84 23       	and	r24, r20
     22a:	8c 93       	st	X, r24
     22c:	1c c0       	rjmp	.+56     	; 0x266 <DIO_WritePin+0x1d4>
     22e:	89 81       	ldd	r24, Y+1	; 0x01
     230:	88 31       	cpi	r24, 0x18	; 24
     232:	c8 f0       	brcs	.+50     	; 0x266 <DIO_WritePin+0x1d4>
     234:	89 81       	ldd	r24, Y+1	; 0x01
     236:	80 32       	cpi	r24, 0x20	; 32
     238:	b0 f4       	brcc	.+44     	; 0x266 <DIO_WritePin+0x1d4>
     23a:	a2 e3       	ldi	r26, 0x32	; 50
     23c:	b0 e0       	ldi	r27, 0x00	; 0
     23e:	e2 e3       	ldi	r30, 0x32	; 50
     240:	f0 e0       	ldi	r31, 0x00	; 0
     242:	80 81       	ld	r24, Z
     244:	48 2f       	mov	r20, r24
     246:	89 81       	ldd	r24, Y+1	; 0x01
     248:	88 2f       	mov	r24, r24
     24a:	90 e0       	ldi	r25, 0x00	; 0
     24c:	48 97       	sbiw	r24, 0x18	; 24
     24e:	9c 01       	movw	r18, r24
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	02 2e       	mov	r0, r18
     256:	02 c0       	rjmp	.+4      	; 0x25c <DIO_WritePin+0x1ca>
     258:	88 0f       	add	r24, r24
     25a:	99 1f       	adc	r25, r25
     25c:	0a 94       	dec	r0
     25e:	e2 f7       	brpl	.-8      	; 0x258 <DIO_WritePin+0x1c6>
     260:	80 95       	com	r24
     262:	84 23       	and	r24, r20
     264:	8c 93       	st	X, r24
     266:	0f 90       	pop	r0
     268:	0f 90       	pop	r0
     26a:	cf 91       	pop	r28
     26c:	df 91       	pop	r29
     26e:	08 95       	ret

00000270 <DIO_ReadPin>:
		}
	}

}
uint8 DIO_ReadPin(uint8 PinNum)
{
     270:	df 93       	push	r29
     272:	cf 93       	push	r28
     274:	00 d0       	rcall	.+0      	; 0x276 <DIO_ReadPin+0x6>
     276:	cd b7       	in	r28, 0x3d	; 61
     278:	de b7       	in	r29, 0x3e	; 62
     27a:	89 83       	std	Y+1, r24	; 0x01
	if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     27c:	89 81       	ldd	r24, Y+1	; 0x01
     27e:	88 30       	cpi	r24, 0x08	; 8
     280:	98 f4       	brcc	.+38     	; 0x2a8 <DIO_ReadPin+0x38>
	{
		return GET_BIT(DIO_PINA,PinNum);
     282:	e9 e3       	ldi	r30, 0x39	; 57
     284:	f0 e0       	ldi	r31, 0x00	; 0
     286:	80 81       	ld	r24, Z
     288:	28 2f       	mov	r18, r24
     28a:	30 e0       	ldi	r19, 0x00	; 0
     28c:	89 81       	ldd	r24, Y+1	; 0x01
     28e:	88 2f       	mov	r24, r24
     290:	90 e0       	ldi	r25, 0x00	; 0
     292:	a9 01       	movw	r20, r18
     294:	02 c0       	rjmp	.+4      	; 0x29a <DIO_ReadPin+0x2a>
     296:	55 95       	asr	r21
     298:	47 95       	ror	r20
     29a:	8a 95       	dec	r24
     29c:	e2 f7       	brpl	.-8      	; 0x296 <DIO_ReadPin+0x26>
     29e:	ca 01       	movw	r24, r20
     2a0:	58 2f       	mov	r21, r24
     2a2:	51 70       	andi	r21, 0x01	; 1
     2a4:	5a 83       	std	Y+2, r21	; 0x02
     2a6:	50 c0       	rjmp	.+160    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     2a8:	89 81       	ldd	r24, Y+1	; 0x01
     2aa:	88 30       	cpi	r24, 0x08	; 8
     2ac:	b8 f0       	brcs	.+46     	; 0x2dc <DIO_ReadPin+0x6c>
     2ae:	89 81       	ldd	r24, Y+1	; 0x01
     2b0:	80 31       	cpi	r24, 0x10	; 16
     2b2:	a0 f4       	brcc	.+40     	; 0x2dc <DIO_ReadPin+0x6c>
	{
		return GET_BIT(DIO_PINB,(PinNum-DIO_PIN8));
     2b4:	e6 e3       	ldi	r30, 0x36	; 54
     2b6:	f0 e0       	ldi	r31, 0x00	; 0
     2b8:	80 81       	ld	r24, Z
     2ba:	28 2f       	mov	r18, r24
     2bc:	30 e0       	ldi	r19, 0x00	; 0
     2be:	89 81       	ldd	r24, Y+1	; 0x01
     2c0:	88 2f       	mov	r24, r24
     2c2:	90 e0       	ldi	r25, 0x00	; 0
     2c4:	08 97       	sbiw	r24, 0x08	; 8
     2c6:	a9 01       	movw	r20, r18
     2c8:	02 c0       	rjmp	.+4      	; 0x2ce <DIO_ReadPin+0x5e>
     2ca:	55 95       	asr	r21
     2cc:	47 95       	ror	r20
     2ce:	8a 95       	dec	r24
     2d0:	e2 f7       	brpl	.-8      	; 0x2ca <DIO_ReadPin+0x5a>
     2d2:	ca 01       	movw	r24, r20
     2d4:	58 2f       	mov	r21, r24
     2d6:	51 70       	andi	r21, 0x01	; 1
     2d8:	5a 83       	std	Y+2, r21	; 0x02
     2da:	36 c0       	rjmp	.+108    	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	80 31       	cpi	r24, 0x10	; 16
     2e0:	b8 f0       	brcs	.+46     	; 0x310 <DIO_ReadPin+0xa0>
     2e2:	89 81       	ldd	r24, Y+1	; 0x01
     2e4:	88 31       	cpi	r24, 0x18	; 24
     2e6:	a0 f4       	brcc	.+40     	; 0x310 <DIO_ReadPin+0xa0>
	{
		return GET_BIT(DIO_PINC,(PinNum-DIO_PIN16));
     2e8:	e3 e3       	ldi	r30, 0x33	; 51
     2ea:	f0 e0       	ldi	r31, 0x00	; 0
     2ec:	80 81       	ld	r24, Z
     2ee:	28 2f       	mov	r18, r24
     2f0:	30 e0       	ldi	r19, 0x00	; 0
     2f2:	89 81       	ldd	r24, Y+1	; 0x01
     2f4:	88 2f       	mov	r24, r24
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	40 97       	sbiw	r24, 0x10	; 16
     2fa:	a9 01       	movw	r20, r18
     2fc:	02 c0       	rjmp	.+4      	; 0x302 <DIO_ReadPin+0x92>
     2fe:	55 95       	asr	r21
     300:	47 95       	ror	r20
     302:	8a 95       	dec	r24
     304:	e2 f7       	brpl	.-8      	; 0x2fe <DIO_ReadPin+0x8e>
     306:	ca 01       	movw	r24, r20
     308:	58 2f       	mov	r21, r24
     30a:	51 70       	andi	r21, 0x01	; 1
     30c:	5a 83       	std	Y+2, r21	; 0x02
     30e:	1c c0       	rjmp	.+56     	; 0x348 <DIO_ReadPin+0xd8>
	}
	else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     310:	89 81       	ldd	r24, Y+1	; 0x01
     312:	88 31       	cpi	r24, 0x18	; 24
     314:	b8 f0       	brcs	.+46     	; 0x344 <DIO_ReadPin+0xd4>
     316:	89 81       	ldd	r24, Y+1	; 0x01
     318:	80 32       	cpi	r24, 0x20	; 32
     31a:	a0 f4       	brcc	.+40     	; 0x344 <DIO_ReadPin+0xd4>
	{
		return GET_BIT(DIO_PIND,(PinNum-DIO_PIN24));
     31c:	e0 e3       	ldi	r30, 0x30	; 48
     31e:	f0 e0       	ldi	r31, 0x00	; 0
     320:	80 81       	ld	r24, Z
     322:	28 2f       	mov	r18, r24
     324:	30 e0       	ldi	r19, 0x00	; 0
     326:	89 81       	ldd	r24, Y+1	; 0x01
     328:	88 2f       	mov	r24, r24
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	48 97       	sbiw	r24, 0x18	; 24
     32e:	a9 01       	movw	r20, r18
     330:	02 c0       	rjmp	.+4      	; 0x336 <DIO_ReadPin+0xc6>
     332:	55 95       	asr	r21
     334:	47 95       	ror	r20
     336:	8a 95       	dec	r24
     338:	e2 f7       	brpl	.-8      	; 0x332 <DIO_ReadPin+0xc2>
     33a:	ca 01       	movw	r24, r20
     33c:	58 2f       	mov	r21, r24
     33e:	51 70       	andi	r21, 0x01	; 1
     340:	5a 83       	std	Y+2, r21	; 0x02
     342:	02 c0       	rjmp	.+4      	; 0x348 <DIO_ReadPin+0xd8>
	}
	return DIO_PIN8;
     344:	88 e0       	ldi	r24, 0x08	; 8
     346:	8a 83       	std	Y+2, r24	; 0x02
     348:	8a 81       	ldd	r24, Y+2	; 0x02
}
     34a:	0f 90       	pop	r0
     34c:	0f 90       	pop	r0
     34e:	cf 91       	pop	r28
     350:	df 91       	pop	r29
     352:	08 95       	ret

00000354 <DIO_SetPinDirection>:
void DIO_SetPinDirection(uint8 PinNum,uint8 PinDirection)
{
     354:	df 93       	push	r29
     356:	cf 93       	push	r28
     358:	00 d0       	rcall	.+0      	; 0x35a <DIO_SetPinDirection+0x6>
     35a:	cd b7       	in	r28, 0x3d	; 61
     35c:	de b7       	in	r29, 0x3e	; 62
     35e:	89 83       	std	Y+1, r24	; 0x01
     360:	6a 83       	std	Y+2, r22	; 0x02
	if(PinDirection==INPUT)
     362:	8a 81       	ldd	r24, Y+2	; 0x02
     364:	88 23       	and	r24, r24
     366:	09 f0       	breq	.+2      	; 0x36a <DIO_SetPinDirection+0x16>
     368:	71 c0       	rjmp	.+226    	; 0x44c <DIO_SetPinDirection+0xf8>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     36a:	89 81       	ldd	r24, Y+1	; 0x01
     36c:	88 30       	cpi	r24, 0x08	; 8
     36e:	a8 f4       	brcc	.+42     	; 0x39a <DIO_SetPinDirection+0x46>
		{
			CLEAR_BIT(DIO_DDRA,PinNum);
     370:	aa e3       	ldi	r26, 0x3A	; 58
     372:	b0 e0       	ldi	r27, 0x00	; 0
     374:	ea e3       	ldi	r30, 0x3A	; 58
     376:	f0 e0       	ldi	r31, 0x00	; 0
     378:	80 81       	ld	r24, Z
     37a:	48 2f       	mov	r20, r24
     37c:	89 81       	ldd	r24, Y+1	; 0x01
     37e:	28 2f       	mov	r18, r24
     380:	30 e0       	ldi	r19, 0x00	; 0
     382:	81 e0       	ldi	r24, 0x01	; 1
     384:	90 e0       	ldi	r25, 0x00	; 0
     386:	02 2e       	mov	r0, r18
     388:	02 c0       	rjmp	.+4      	; 0x38e <DIO_SetPinDirection+0x3a>
     38a:	88 0f       	add	r24, r24
     38c:	99 1f       	adc	r25, r25
     38e:	0a 94       	dec	r0
     390:	e2 f7       	brpl	.-8      	; 0x38a <DIO_SetPinDirection+0x36>
     392:	80 95       	com	r24
     394:	84 23       	and	r24, r20
     396:	8c 93       	st	X, r24
     398:	c7 c0       	rjmp	.+398    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     39a:	89 81       	ldd	r24, Y+1	; 0x01
     39c:	88 30       	cpi	r24, 0x08	; 8
     39e:	d0 f0       	brcs	.+52     	; 0x3d4 <DIO_SetPinDirection+0x80>
     3a0:	89 81       	ldd	r24, Y+1	; 0x01
     3a2:	80 31       	cpi	r24, 0x10	; 16
     3a4:	b8 f4       	brcc	.+46     	; 0x3d4 <DIO_SetPinDirection+0x80>
		{
			CLEAR_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     3a6:	a7 e3       	ldi	r26, 0x37	; 55
     3a8:	b0 e0       	ldi	r27, 0x00	; 0
     3aa:	e7 e3       	ldi	r30, 0x37	; 55
     3ac:	f0 e0       	ldi	r31, 0x00	; 0
     3ae:	80 81       	ld	r24, Z
     3b0:	48 2f       	mov	r20, r24
     3b2:	89 81       	ldd	r24, Y+1	; 0x01
     3b4:	88 2f       	mov	r24, r24
     3b6:	90 e0       	ldi	r25, 0x00	; 0
     3b8:	08 97       	sbiw	r24, 0x08	; 8
     3ba:	9c 01       	movw	r18, r24
     3bc:	81 e0       	ldi	r24, 0x01	; 1
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	02 2e       	mov	r0, r18
     3c2:	02 c0       	rjmp	.+4      	; 0x3c8 <DIO_SetPinDirection+0x74>
     3c4:	88 0f       	add	r24, r24
     3c6:	99 1f       	adc	r25, r25
     3c8:	0a 94       	dec	r0
     3ca:	e2 f7       	brpl	.-8      	; 0x3c4 <DIO_SetPinDirection+0x70>
     3cc:	80 95       	com	r24
     3ce:	84 23       	and	r24, r20
     3d0:	8c 93       	st	X, r24
     3d2:	aa c0       	rjmp	.+340    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     3d4:	89 81       	ldd	r24, Y+1	; 0x01
     3d6:	80 31       	cpi	r24, 0x10	; 16
     3d8:	d0 f0       	brcs	.+52     	; 0x40e <DIO_SetPinDirection+0xba>
     3da:	89 81       	ldd	r24, Y+1	; 0x01
     3dc:	88 31       	cpi	r24, 0x18	; 24
     3de:	b8 f4       	brcc	.+46     	; 0x40e <DIO_SetPinDirection+0xba>
		{
			CLEAR_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     3e0:	a4 e3       	ldi	r26, 0x34	; 52
     3e2:	b0 e0       	ldi	r27, 0x00	; 0
     3e4:	e4 e3       	ldi	r30, 0x34	; 52
     3e6:	f0 e0       	ldi	r31, 0x00	; 0
     3e8:	80 81       	ld	r24, Z
     3ea:	48 2f       	mov	r20, r24
     3ec:	89 81       	ldd	r24, Y+1	; 0x01
     3ee:	88 2f       	mov	r24, r24
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	40 97       	sbiw	r24, 0x10	; 16
     3f4:	9c 01       	movw	r18, r24
     3f6:	81 e0       	ldi	r24, 0x01	; 1
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	02 2e       	mov	r0, r18
     3fc:	02 c0       	rjmp	.+4      	; 0x402 <DIO_SetPinDirection+0xae>
     3fe:	88 0f       	add	r24, r24
     400:	99 1f       	adc	r25, r25
     402:	0a 94       	dec	r0
     404:	e2 f7       	brpl	.-8      	; 0x3fe <DIO_SetPinDirection+0xaa>
     406:	80 95       	com	r24
     408:	84 23       	and	r24, r20
     40a:	8c 93       	st	X, r24
     40c:	8d c0       	rjmp	.+282    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     40e:	89 81       	ldd	r24, Y+1	; 0x01
     410:	88 31       	cpi	r24, 0x18	; 24
     412:	08 f4       	brcc	.+2      	; 0x416 <DIO_SetPinDirection+0xc2>
     414:	89 c0       	rjmp	.+274    	; 0x528 <DIO_SetPinDirection+0x1d4>
     416:	89 81       	ldd	r24, Y+1	; 0x01
     418:	80 32       	cpi	r24, 0x20	; 32
     41a:	08 f0       	brcs	.+2      	; 0x41e <DIO_SetPinDirection+0xca>
     41c:	85 c0       	rjmp	.+266    	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			CLEAR_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     41e:	a1 e3       	ldi	r26, 0x31	; 49
     420:	b0 e0       	ldi	r27, 0x00	; 0
     422:	e1 e3       	ldi	r30, 0x31	; 49
     424:	f0 e0       	ldi	r31, 0x00	; 0
     426:	80 81       	ld	r24, Z
     428:	48 2f       	mov	r20, r24
     42a:	89 81       	ldd	r24, Y+1	; 0x01
     42c:	88 2f       	mov	r24, r24
     42e:	90 e0       	ldi	r25, 0x00	; 0
     430:	48 97       	sbiw	r24, 0x18	; 24
     432:	9c 01       	movw	r18, r24
     434:	81 e0       	ldi	r24, 0x01	; 1
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	02 2e       	mov	r0, r18
     43a:	02 c0       	rjmp	.+4      	; 0x440 <DIO_SetPinDirection+0xec>
     43c:	88 0f       	add	r24, r24
     43e:	99 1f       	adc	r25, r25
     440:	0a 94       	dec	r0
     442:	e2 f7       	brpl	.-8      	; 0x43c <DIO_SetPinDirection+0xe8>
     444:	80 95       	com	r24
     446:	84 23       	and	r24, r20
     448:	8c 93       	st	X, r24
     44a:	6e c0       	rjmp	.+220    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
	}
	else if(PinDirection==OUTPUT)
     44c:	8a 81       	ldd	r24, Y+2	; 0x02
     44e:	81 30       	cpi	r24, 0x01	; 1
     450:	09 f0       	breq	.+2      	; 0x454 <DIO_SetPinDirection+0x100>
     452:	6a c0       	rjmp	.+212    	; 0x528 <DIO_SetPinDirection+0x1d4>
	{
		if((PinNum>=DIO_PIN0)&&(PinNum<=DIO_PIN7))
     454:	89 81       	ldd	r24, Y+1	; 0x01
     456:	88 30       	cpi	r24, 0x08	; 8
     458:	a0 f4       	brcc	.+40     	; 0x482 <DIO_SetPinDirection+0x12e>
		{
			SET_BIT(DIO_DDRA,PinNum);
     45a:	aa e3       	ldi	r26, 0x3A	; 58
     45c:	b0 e0       	ldi	r27, 0x00	; 0
     45e:	ea e3       	ldi	r30, 0x3A	; 58
     460:	f0 e0       	ldi	r31, 0x00	; 0
     462:	80 81       	ld	r24, Z
     464:	48 2f       	mov	r20, r24
     466:	89 81       	ldd	r24, Y+1	; 0x01
     468:	28 2f       	mov	r18, r24
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	81 e0       	ldi	r24, 0x01	; 1
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	02 2e       	mov	r0, r18
     472:	02 c0       	rjmp	.+4      	; 0x478 <DIO_SetPinDirection+0x124>
     474:	88 0f       	add	r24, r24
     476:	99 1f       	adc	r25, r25
     478:	0a 94       	dec	r0
     47a:	e2 f7       	brpl	.-8      	; 0x474 <DIO_SetPinDirection+0x120>
     47c:	84 2b       	or	r24, r20
     47e:	8c 93       	st	X, r24
     480:	53 c0       	rjmp	.+166    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN8)&&(PinNum<=DIO_PIN15))
     482:	89 81       	ldd	r24, Y+1	; 0x01
     484:	88 30       	cpi	r24, 0x08	; 8
     486:	c8 f0       	brcs	.+50     	; 0x4ba <DIO_SetPinDirection+0x166>
     488:	89 81       	ldd	r24, Y+1	; 0x01
     48a:	80 31       	cpi	r24, 0x10	; 16
     48c:	b0 f4       	brcc	.+44     	; 0x4ba <DIO_SetPinDirection+0x166>
		{
			SET_BIT(DIO_DDRB,(PinNum-DIO_PIN8));
     48e:	a7 e3       	ldi	r26, 0x37	; 55
     490:	b0 e0       	ldi	r27, 0x00	; 0
     492:	e7 e3       	ldi	r30, 0x37	; 55
     494:	f0 e0       	ldi	r31, 0x00	; 0
     496:	80 81       	ld	r24, Z
     498:	48 2f       	mov	r20, r24
     49a:	89 81       	ldd	r24, Y+1	; 0x01
     49c:	88 2f       	mov	r24, r24
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	08 97       	sbiw	r24, 0x08	; 8
     4a2:	9c 01       	movw	r18, r24
     4a4:	81 e0       	ldi	r24, 0x01	; 1
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	02 2e       	mov	r0, r18
     4aa:	02 c0       	rjmp	.+4      	; 0x4b0 <DIO_SetPinDirection+0x15c>
     4ac:	88 0f       	add	r24, r24
     4ae:	99 1f       	adc	r25, r25
     4b0:	0a 94       	dec	r0
     4b2:	e2 f7       	brpl	.-8      	; 0x4ac <DIO_SetPinDirection+0x158>
     4b4:	84 2b       	or	r24, r20
     4b6:	8c 93       	st	X, r24
     4b8:	37 c0       	rjmp	.+110    	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN16)&&(PinNum<=DIO_PIN23))
     4ba:	89 81       	ldd	r24, Y+1	; 0x01
     4bc:	80 31       	cpi	r24, 0x10	; 16
     4be:	c8 f0       	brcs	.+50     	; 0x4f2 <DIO_SetPinDirection+0x19e>
     4c0:	89 81       	ldd	r24, Y+1	; 0x01
     4c2:	88 31       	cpi	r24, 0x18	; 24
     4c4:	b0 f4       	brcc	.+44     	; 0x4f2 <DIO_SetPinDirection+0x19e>
		{
			SET_BIT(DIO_DDRC,(PinNum-DIO_PIN16));
     4c6:	a4 e3       	ldi	r26, 0x34	; 52
     4c8:	b0 e0       	ldi	r27, 0x00	; 0
     4ca:	e4 e3       	ldi	r30, 0x34	; 52
     4cc:	f0 e0       	ldi	r31, 0x00	; 0
     4ce:	80 81       	ld	r24, Z
     4d0:	48 2f       	mov	r20, r24
     4d2:	89 81       	ldd	r24, Y+1	; 0x01
     4d4:	88 2f       	mov	r24, r24
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	40 97       	sbiw	r24, 0x10	; 16
     4da:	9c 01       	movw	r18, r24
     4dc:	81 e0       	ldi	r24, 0x01	; 1
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	02 2e       	mov	r0, r18
     4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <DIO_SetPinDirection+0x194>
     4e4:	88 0f       	add	r24, r24
     4e6:	99 1f       	adc	r25, r25
     4e8:	0a 94       	dec	r0
     4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <DIO_SetPinDirection+0x190>
     4ec:	84 2b       	or	r24, r20
     4ee:	8c 93       	st	X, r24
     4f0:	1b c0       	rjmp	.+54     	; 0x528 <DIO_SetPinDirection+0x1d4>
		}
		else if((PinNum>=DIO_PIN24)&&(PinNum<=DIO_PIN31))
     4f2:	89 81       	ldd	r24, Y+1	; 0x01
     4f4:	88 31       	cpi	r24, 0x18	; 24
     4f6:	c0 f0       	brcs	.+48     	; 0x528 <DIO_SetPinDirection+0x1d4>
     4f8:	89 81       	ldd	r24, Y+1	; 0x01
     4fa:	80 32       	cpi	r24, 0x20	; 32
     4fc:	a8 f4       	brcc	.+42     	; 0x528 <DIO_SetPinDirection+0x1d4>
		{
			SET_BIT(DIO_DDRD,(PinNum-DIO_PIN24));
     4fe:	a1 e3       	ldi	r26, 0x31	; 49
     500:	b0 e0       	ldi	r27, 0x00	; 0
     502:	e1 e3       	ldi	r30, 0x31	; 49
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	80 81       	ld	r24, Z
     508:	48 2f       	mov	r20, r24
     50a:	89 81       	ldd	r24, Y+1	; 0x01
     50c:	88 2f       	mov	r24, r24
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	48 97       	sbiw	r24, 0x18	; 24
     512:	9c 01       	movw	r18, r24
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	02 2e       	mov	r0, r18
     51a:	02 c0       	rjmp	.+4      	; 0x520 <DIO_SetPinDirection+0x1cc>
     51c:	88 0f       	add	r24, r24
     51e:	99 1f       	adc	r25, r25
     520:	0a 94       	dec	r0
     522:	e2 f7       	brpl	.-8      	; 0x51c <DIO_SetPinDirection+0x1c8>
     524:	84 2b       	or	r24, r20
     526:	8c 93       	st	X, r24
		}
	}


}
     528:	0f 90       	pop	r0
     52a:	0f 90       	pop	r0
     52c:	cf 91       	pop	r28
     52e:	df 91       	pop	r29
     530:	08 95       	ret

00000532 <init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void init_Task(void * a_Task_ptr)
{
     532:	ef 92       	push	r14
     534:	ff 92       	push	r15
     536:	0f 93       	push	r16
     538:	df 93       	push	r29
     53a:	cf 93       	push	r28
     53c:	00 d0       	rcall	.+0      	; 0x53e <init_Task+0xc>
     53e:	cd b7       	in	r28, 0x3d	; 61
     540:	de b7       	in	r29, 0x3e	; 62
     542:	9a 83       	std	Y+2, r25	; 0x02
     544:	89 83       	std	Y+1, r24	; 0x01

	xTaskCreate(All_Hardware_Init_Task  , "InitTasks" , configMINIMAL_STACK_SIZE ,
     546:	8c ed       	ldi	r24, 0xDC	; 220
     548:	92 e0       	ldi	r25, 0x02	; 2
     54a:	20 e6       	ldi	r18, 0x60	; 96
     54c:	30 e0       	ldi	r19, 0x00	; 0
     54e:	e8 ea       	ldi	r30, 0xA8	; 168
     550:	f0 e0       	ldi	r31, 0x00	; 0
     552:	b9 01       	movw	r22, r18
     554:	45 e5       	ldi	r20, 0x55	; 85
     556:	50 e0       	ldi	r21, 0x00	; 0
     558:	20 e0       	ldi	r18, 0x00	; 0
     55a:	30 e0       	ldi	r19, 0x00	; 0
     55c:	04 e0       	ldi	r16, 0x04	; 4
     55e:	7f 01       	movw	r14, r30
     560:	0e 94 0e 1d 	call	0x3a1c	; 0x3a1c <xTaskCreate>
			NULL , (4 | portPRIVILEGE_BIT) , &AllHardwareInit_Flag);
	xTaskCreate(KeyPad_Task  , "KeyPad_Task" , configMINIMAL_STACK_SIZE ,
     564:	83 ef       	ldi	r24, 0xF3	; 243
     566:	92 e0       	ldi	r25, 0x02	; 2
     568:	2a e6       	ldi	r18, 0x6A	; 106
     56a:	30 e0       	ldi	r19, 0x00	; 0
     56c:	b9 01       	movw	r22, r18
     56e:	45 e5       	ldi	r20, 0x55	; 85
     570:	50 e0       	ldi	r21, 0x00	; 0
     572:	20 e0       	ldi	r18, 0x00	; 0
     574:	30 e0       	ldi	r19, 0x00	; 0
     576:	02 e0       	ldi	r16, 0x02	; 2
     578:	ee 24       	eor	r14, r14
     57a:	ff 24       	eor	r15, r15
     57c:	0e 94 0e 1d 	call	0x3a1c	; 0x3a1c <xTaskCreate>
			NULL , (2 | portPRIVILEGE_BIT) , NULL);
	xTaskCreate(LCD_Task  , "LCD_Task" , configMINIMAL_STACK_SIZE ,
     580:	80 e3       	ldi	r24, 0x30	; 48
     582:	93 e0       	ldi	r25, 0x03	; 3
     584:	26 e7       	ldi	r18, 0x76	; 118
     586:	30 e0       	ldi	r19, 0x00	; 0
     588:	b9 01       	movw	r22, r18
     58a:	45 e5       	ldi	r20, 0x55	; 85
     58c:	50 e0       	ldi	r21, 0x00	; 0
     58e:	20 e0       	ldi	r18, 0x00	; 0
     590:	30 e0       	ldi	r19, 0x00	; 0
     592:	01 e0       	ldi	r16, 0x01	; 1
     594:	ee 24       	eor	r14, r14
     596:	ff 24       	eor	r15, r15
     598:	0e 94 0e 1d 	call	0x3a1c	; 0x3a1c <xTaskCreate>
			NULL , (1 | portPRIVILEGE_BIT) , NULL);
	vTaskSuspend( InitTask_Flag);
     59c:	80 91 ab 00 	lds	r24, 0x00AB
     5a0:	90 91 ac 00 	lds	r25, 0x00AC
     5a4:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <vTaskSuspend>
}
     5a8:	0f 90       	pop	r0
     5aa:	0f 90       	pop	r0
     5ac:	cf 91       	pop	r28
     5ae:	df 91       	pop	r29
     5b0:	0f 91       	pop	r16
     5b2:	ff 90       	pop	r15
     5b4:	ef 90       	pop	r14
     5b6:	08 95       	ret

000005b8 <All_Hardware_Init_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void All_Hardware_Init_Task(void * a_Task_ptr)
{
     5b8:	df 93       	push	r29
     5ba:	cf 93       	push	r28
     5bc:	00 d0       	rcall	.+0      	; 0x5be <All_Hardware_Init_Task+0x6>
     5be:	cd b7       	in	r28, 0x3d	; 61
     5c0:	de b7       	in	r29, 0x3e	; 62
     5c2:	9a 83       	std	Y+2, r25	; 0x02
     5c4:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		KeyPad_Init();
     5c6:	0e 94 97 07 	call	0xf2e	; 0xf2e <KeyPad_Init>
		LCD_init();
     5ca:	0e 94 a8 08 	call	0x1150	; 0x1150 <LCD_init>
		Init_Done++;
     5ce:	80 91 a7 00 	lds	r24, 0x00A7
     5d2:	8f 5f       	subi	r24, 0xFF	; 255
     5d4:	80 93 a7 00 	sts	0x00A7, r24
		vTaskSuspend( AllHardwareInit_Flag);
     5d8:	80 91 a8 00 	lds	r24, 0x00A8
     5dc:	90 91 a9 00 	lds	r25, 0x00A9
     5e0:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <vTaskSuspend>
     5e4:	f0 cf       	rjmp	.-32     	; 0x5c6 <All_Hardware_Init_Task+0xe>

000005e6 <KeyPad_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void KeyPad_Task(void * a_Task_ptr)
{
     5e6:	df 93       	push	r29
     5e8:	cf 93       	push	r28
     5ea:	00 d0       	rcall	.+0      	; 0x5ec <KeyPad_Task+0x6>
     5ec:	00 d0       	rcall	.+0      	; 0x5ee <KeyPad_Task+0x8>
     5ee:	cd b7       	in	r28, 0x3d	; 61
     5f0:	de b7       	in	r29, 0x3e	; 62
     5f2:	9c 83       	std	Y+4, r25	; 0x04
     5f4:	8b 83       	std	Y+3, r24	; 0x03
	/*de_bouncing Flag to make sure key is pressed*/
	uint8 Debouncing = 0;
     5f6:	1a 82       	std	Y+2, r1	; 0x02

	/*comparing value to check if key is pressed*/
	uint8 OldPressedValue = 0;
     5f8:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		if(Init_Done == 0)
     5fa:	80 91 a7 00 	lds	r24, 0x00A7
     5fe:	88 23       	and	r24, r24
     600:	e1 f3       	breq	.-8      	; 0x5fa <KeyPad_Task+0x14>

			/*Do Nothing*/
		}
		else
		{
			if(Debouncing == 0 && KeyPad_getPressedKey()!=10)
     602:	8a 81       	ldd	r24, Y+2	; 0x02
     604:	88 23       	and	r24, r24
     606:	79 f4       	brne	.+30     	; 0x626 <KeyPad_Task+0x40>
     608:	0e 94 ce 07 	call	0xf9c	; 0xf9c <KeyPad_getPressedKey>
     60c:	8a 30       	cpi	r24, 0x0A	; 10
     60e:	59 f0       	breq	.+22     	; 0x626 <KeyPad_Task+0x40>
			{
				OldPressedValue =  KeyPad_getPressedKey();
     610:	0e 94 ce 07 	call	0xf9c	; 0xf9c <KeyPad_getPressedKey>
     614:	89 83       	std	Y+1, r24	; 0x01
				Debouncing++;
     616:	8a 81       	ldd	r24, Y+2	; 0x02
     618:	8f 5f       	subi	r24, 0xFF	; 255
     61a:	8a 83       	std	Y+2, r24	; 0x02
				vTaskDelay(10);
     61c:	8a e0       	ldi	r24, 0x0A	; 10
     61e:	90 e0       	ldi	r25, 0x00	; 0
     620:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
     624:	ea cf       	rjmp	.-44     	; 0x5fa <KeyPad_Task+0x14>
			}
			else if(Debouncing == 1)
     626:	8a 81       	ldd	r24, Y+2	; 0x02
     628:	81 30       	cpi	r24, 0x01	; 1
     62a:	a1 f4       	brne	.+40     	; 0x654 <KeyPad_Task+0x6e>
			{
				if(OldPressedValue == KeyPad_getPressedKey())
     62c:	0e 94 ce 07 	call	0xf9c	; 0xf9c <KeyPad_getPressedKey>
     630:	98 2f       	mov	r25, r24
     632:	89 81       	ldd	r24, Y+1	; 0x01
     634:	98 17       	cp	r25, r24
     636:	31 f4       	brne	.+12     	; 0x644 <KeyPad_Task+0x5e>
				{
					PressedKey = OldPressedValue;
     638:	89 81       	ldd	r24, Y+1	; 0x01
     63a:	80 93 a6 00 	sts	0x00A6, r24
					DisplayFlag = 1;
     63e:	81 e0       	ldi	r24, 0x01	; 1
     640:	80 93 aa 00 	sts	0x00AA, r24
				}
				else
				{
					/*Do Nothing*/
				}
				Debouncing++;
     644:	8a 81       	ldd	r24, Y+2	; 0x02
     646:	8f 5f       	subi	r24, 0xFF	; 255
     648:	8a 83       	std	Y+2, r24	; 0x02
				vTaskDelay(100);
     64a:	84 e6       	ldi	r24, 0x64	; 100
     64c:	90 e0       	ldi	r25, 0x00	; 0
     64e:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
     652:	d3 cf       	rjmp	.-90     	; 0x5fa <KeyPad_Task+0x14>
			}
			else
			{
				Debouncing = 0;
     654:	1a 82       	std	Y+2, r1	; 0x02
				vTaskDelay(100);
     656:	84 e6       	ldi	r24, 0x64	; 100
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
     65e:	cd cf       	rjmp	.-102    	; 0x5fa <KeyPad_Task+0x14>

00000660 <LCD_Task>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_Task(void * a_Task_ptr)
{
     660:	df 93       	push	r29
     662:	cf 93       	push	r28
     664:	cd b7       	in	r28, 0x3d	; 61
     666:	de b7       	in	r29, 0x3e	; 62
     668:	a6 97       	sbiw	r28, 0x26	; 38
     66a:	0f b6       	in	r0, 0x3f	; 63
     66c:	f8 94       	cli
     66e:	de bf       	out	0x3e, r29	; 62
     670:	0f be       	out	0x3f, r0	; 63
     672:	cd bf       	out	0x3d, r28	; 61
     674:	9c 8f       	std	Y+28, r25	; 0x1c
     676:	8b 8f       	std	Y+27, r24	; 0x1b
	/*counter to count entered numbers*/
	uint8 PasswordCounter=0;
     678:	1a 82       	std	Y+2, r1	; 0x02

	/*Password*/
	uint8 Password[]= "153426";
     67a:	ce 01       	movw	r24, r28
     67c:	03 96       	adiw	r24, 0x03	; 3
     67e:	9e 8f       	std	Y+30, r25	; 0x1e
     680:	8d 8f       	std	Y+29, r24	; 0x1d
     682:	ef e7       	ldi	r30, 0x7F	; 127
     684:	f0 e0       	ldi	r31, 0x00	; 0
     686:	f8 a3       	std	Y+32, r31	; 0x20
     688:	ef 8f       	std	Y+31, r30	; 0x1f
     68a:	f7 e0       	ldi	r31, 0x07	; 7
     68c:	f9 a3       	std	Y+33, r31	; 0x21
     68e:	ef 8d       	ldd	r30, Y+31	; 0x1f
     690:	f8 a1       	ldd	r31, Y+32	; 0x20
     692:	00 80       	ld	r0, Z
     694:	8f 8d       	ldd	r24, Y+31	; 0x1f
     696:	98 a1       	ldd	r25, Y+32	; 0x20
     698:	01 96       	adiw	r24, 0x01	; 1
     69a:	98 a3       	std	Y+32, r25	; 0x20
     69c:	8f 8f       	std	Y+31, r24	; 0x1f
     69e:	ed 8d       	ldd	r30, Y+29	; 0x1d
     6a0:	fe 8d       	ldd	r31, Y+30	; 0x1e
     6a2:	00 82       	st	Z, r0
     6a4:	8d 8d       	ldd	r24, Y+29	; 0x1d
     6a6:	9e 8d       	ldd	r25, Y+30	; 0x1e
     6a8:	01 96       	adiw	r24, 0x01	; 1
     6aa:	9e 8f       	std	Y+30, r25	; 0x1e
     6ac:	8d 8f       	std	Y+29, r24	; 0x1d
     6ae:	99 a1       	ldd	r25, Y+33	; 0x21
     6b0:	91 50       	subi	r25, 0x01	; 1
     6b2:	99 a3       	std	Y+33, r25	; 0x21
     6b4:	e9 a1       	ldd	r30, Y+33	; 0x21
     6b6:	ee 23       	and	r30, r30
     6b8:	51 f7       	brne	.-44     	; 0x68e <LCD_Task+0x2e>

	uint8 Correct[]= "Correct Password";
     6ba:	ce 01       	movw	r24, r28
     6bc:	0a 96       	adiw	r24, 0x0a	; 10
     6be:	9b a3       	std	Y+35, r25	; 0x23
     6c0:	8a a3       	std	Y+34, r24	; 0x22
     6c2:	e6 e8       	ldi	r30, 0x86	; 134
     6c4:	f0 e0       	ldi	r31, 0x00	; 0
     6c6:	fd a3       	std	Y+37, r31	; 0x25
     6c8:	ec a3       	std	Y+36, r30	; 0x24
     6ca:	f1 e1       	ldi	r31, 0x11	; 17
     6cc:	fe a3       	std	Y+38, r31	; 0x26
     6ce:	ec a1       	ldd	r30, Y+36	; 0x24
     6d0:	fd a1       	ldd	r31, Y+37	; 0x25
     6d2:	00 80       	ld	r0, Z
     6d4:	8c a1       	ldd	r24, Y+36	; 0x24
     6d6:	9d a1       	ldd	r25, Y+37	; 0x25
     6d8:	01 96       	adiw	r24, 0x01	; 1
     6da:	9d a3       	std	Y+37, r25	; 0x25
     6dc:	8c a3       	std	Y+36, r24	; 0x24
     6de:	ea a1       	ldd	r30, Y+34	; 0x22
     6e0:	fb a1       	ldd	r31, Y+35	; 0x23
     6e2:	00 82       	st	Z, r0
     6e4:	8a a1       	ldd	r24, Y+34	; 0x22
     6e6:	9b a1       	ldd	r25, Y+35	; 0x23
     6e8:	01 96       	adiw	r24, 0x01	; 1
     6ea:	9b a3       	std	Y+35, r25	; 0x23
     6ec:	8a a3       	std	Y+34, r24	; 0x22
     6ee:	9e a1       	ldd	r25, Y+38	; 0x26
     6f0:	91 50       	subi	r25, 0x01	; 1
     6f2:	9e a3       	std	Y+38, r25	; 0x26
     6f4:	ee a1       	ldd	r30, Y+38	; 0x26
     6f6:	ee 23       	and	r30, r30
     6f8:	51 f7       	brne	.-44     	; 0x6ce <LCD_Task+0x6e>

	/*to check on correct answer*/
	uint8 CorrectFlag = 0;
     6fa:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		if(DisplayFlag == 1 && PressedKey < 7 && PasswordCounter < 6)
     6fc:	80 91 aa 00 	lds	r24, 0x00AA
     700:	81 30       	cpi	r24, 0x01	; 1
     702:	51 f5       	brne	.+84     	; 0x758 <LCD_Task+0xf8>
     704:	80 91 a6 00 	lds	r24, 0x00A6
     708:	87 30       	cpi	r24, 0x07	; 7
     70a:	30 f5       	brcc	.+76     	; 0x758 <LCD_Task+0xf8>
     70c:	8a 81       	ldd	r24, Y+2	; 0x02
     70e:	86 30       	cpi	r24, 0x06	; 6
     710:	18 f5       	brcc	.+70     	; 0x758 <LCD_Task+0xf8>
		{
			LCD_displayCharacter(PressedKey + 48);
     712:	80 91 a6 00 	lds	r24, 0x00A6
     716:	80 5d       	subi	r24, 0xD0	; 208
     718:	0e 94 36 09 	call	0x126c	; 0x126c <LCD_displayCharacter>
			DisplayFlag = 0;
     71c:	10 92 aa 00 	sts	0x00AA, r1
			if((Password[PasswordCounter] == (PressedKey+48)) && CorrectFlag == 0)
     720:	8a 81       	ldd	r24, Y+2	; 0x02
     722:	28 2f       	mov	r18, r24
     724:	30 e0       	ldi	r19, 0x00	; 0
     726:	ce 01       	movw	r24, r28
     728:	03 96       	adiw	r24, 0x03	; 3
     72a:	fc 01       	movw	r30, r24
     72c:	e2 0f       	add	r30, r18
     72e:	f3 1f       	adc	r31, r19
     730:	80 81       	ld	r24, Z
     732:	28 2f       	mov	r18, r24
     734:	30 e0       	ldi	r19, 0x00	; 0
     736:	80 91 a6 00 	lds	r24, 0x00A6
     73a:	88 2f       	mov	r24, r24
     73c:	90 e0       	ldi	r25, 0x00	; 0
     73e:	c0 96       	adiw	r24, 0x30	; 48
     740:	28 17       	cp	r18, r24
     742:	39 07       	cpc	r19, r25
     744:	19 f4       	brne	.+6      	; 0x74c <LCD_Task+0xec>
     746:	89 81       	ldd	r24, Y+1	; 0x01
     748:	88 23       	and	r24, r24
     74a:	11 f0       	breq	.+4      	; 0x750 <LCD_Task+0xf0>
			{
				/*Do Nothing*/
			}
			else
			{
				CorrectFlag = 1;
     74c:	81 e0       	ldi	r24, 0x01	; 1
     74e:	89 83       	std	Y+1, r24	; 0x01
			}
			PasswordCounter++;
     750:	8a 81       	ldd	r24, Y+2	; 0x02
     752:	8f 5f       	subi	r24, 0xFF	; 255
     754:	8a 83       	std	Y+2, r24	; 0x02
     756:	25 c0       	rjmp	.+74     	; 0x7a2 <LCD_Task+0x142>
		}
		else if(PressedKey == 7)
     758:	80 91 a6 00 	lds	r24, 0x00A6
     75c:	87 30       	cpi	r24, 0x07	; 7
     75e:	29 f4       	brne	.+10     	; 0x76a <LCD_Task+0x10a>
		{
			LCD_clearScreen();
     760:	0e 94 27 0a 	call	0x144e	; 0x144e <LCD_clearScreen>
			PasswordCounter = 0;
     764:	1a 82       	std	Y+2, r1	; 0x02
			CorrectFlag = 0;
     766:	19 82       	std	Y+1, r1	; 0x01
     768:	1c c0       	rjmp	.+56     	; 0x7a2 <LCD_Task+0x142>
		}
		else if(PressedKey == 9 && PasswordCounter == 6)
     76a:	80 91 a6 00 	lds	r24, 0x00A6
     76e:	89 30       	cpi	r24, 0x09	; 9
     770:	c1 f4       	brne	.+48     	; 0x7a2 <LCD_Task+0x142>
     772:	8a 81       	ldd	r24, Y+2	; 0x02
     774:	86 30       	cpi	r24, 0x06	; 6
     776:	a9 f4       	brne	.+42     	; 0x7a2 <LCD_Task+0x142>
		{
			if(CorrectFlag == 0)
     778:	89 81       	ldd	r24, Y+1	; 0x01
     77a:	88 23       	and	r24, r24
     77c:	71 f4       	brne	.+28     	; 0x79a <LCD_Task+0x13a>
			{
				LCD_clearScreen();
     77e:	0e 94 27 0a 	call	0x144e	; 0x144e <LCD_clearScreen>
				LCD_displayString(Correct);
     782:	ce 01       	movw	r24, r28
     784:	0a 96       	adiw	r24, 0x0a	; 10
     786:	0e 94 a3 09 	call	0x1346	; 0x1346 <LCD_displayString>
				PasswordCounter = 0;
     78a:	1a 82       	std	Y+2, r1	; 0x02
				vTaskDelay(2000);
     78c:	80 ed       	ldi	r24, 0xD0	; 208
     78e:	97 e0       	ldi	r25, 0x07	; 7
     790:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
				LCD_clearScreen();
     794:	0e 94 27 0a 	call	0x144e	; 0x144e <LCD_clearScreen>
     798:	04 c0       	rjmp	.+8      	; 0x7a2 <LCD_Task+0x142>
			}
			else
			{
				PasswordCounter = 0;
     79a:	1a 82       	std	Y+2, r1	; 0x02
				LCD_clearScreen();
     79c:	0e 94 27 0a 	call	0x144e	; 0x144e <LCD_clearScreen>
				CorrectFlag = 0;
     7a0:	19 82       	std	Y+1, r1	; 0x01
			}
		}

		vTaskDelay(150);
     7a2:	86 e9       	ldi	r24, 0x96	; 150
     7a4:	90 e0       	ldi	r25, 0x00	; 0
     7a6:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
     7aa:	a8 cf       	rjmp	.-176    	; 0x6fc <LCD_Task+0x9c>

000007ac <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     7ac:	df 93       	push	r29
     7ae:	cf 93       	push	r28
     7b0:	00 d0       	rcall	.+0      	; 0x7b2 <xEventGroupCreate+0x6>
     7b2:	cd b7       	in	r28, 0x3d	; 61
     7b4:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     7b6:	8b e0       	ldi	r24, 0x0B	; 11
     7b8:	90 e0       	ldi	r25, 0x00	; 0
     7ba:	0e 94 1b 07 	call	0xe36	; 0xe36 <pvPortMalloc>
     7be:	9a 83       	std	Y+2, r25	; 0x02
     7c0:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     7c2:	89 81       	ldd	r24, Y+1	; 0x01
     7c4:	9a 81       	ldd	r25, Y+2	; 0x02
     7c6:	00 97       	sbiw	r24, 0x00	; 0
     7c8:	49 f0       	breq	.+18     	; 0x7dc <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     7ca:	e9 81       	ldd	r30, Y+1	; 0x01
     7cc:	fa 81       	ldd	r31, Y+2	; 0x02
     7ce:	11 82       	std	Z+1, r1	; 0x01
     7d0:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     7d2:	89 81       	ldd	r24, Y+1	; 0x01
     7d4:	9a 81       	ldd	r25, Y+2	; 0x02
     7d6:	02 96       	adiw	r24, 0x02	; 2
     7d8:	0e 94 31 0a 	call	0x1462	; 0x1462 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     7dc:	89 81       	ldd	r24, Y+1	; 0x01
     7de:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     7e0:	0f 90       	pop	r0
     7e2:	0f 90       	pop	r0
     7e4:	cf 91       	pop	r28
     7e6:	df 91       	pop	r29
     7e8:	08 95       	ret

000007ea <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     7ea:	df 93       	push	r29
     7ec:	cf 93       	push	r28
     7ee:	cd b7       	in	r28, 0x3d	; 61
     7f0:	de b7       	in	r29, 0x3e	; 62
     7f2:	60 97       	sbiw	r28, 0x10	; 16
     7f4:	0f b6       	in	r0, 0x3f	; 63
     7f6:	f8 94       	cli
     7f8:	de bf       	out	0x3e, r29	; 62
     7fa:	0f be       	out	0x3f, r0	; 63
     7fc:	cd bf       	out	0x3d, r28	; 61
     7fe:	9a 87       	std	Y+10, r25	; 0x0a
     800:	89 87       	std	Y+9, r24	; 0x09
     802:	7c 87       	std	Y+12, r23	; 0x0c
     804:	6b 87       	std	Y+11, r22	; 0x0b
     806:	5e 87       	std	Y+14, r21	; 0x0e
     808:	4d 87       	std	Y+13, r20	; 0x0d
     80a:	38 8b       	std	Y+16, r19	; 0x10
     80c:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     80e:	89 85       	ldd	r24, Y+9	; 0x09
     810:	9a 85       	ldd	r25, Y+10	; 0x0a
     812:	9c 83       	std	Y+4, r25	; 0x04
     814:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     816:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     818:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     81c:	eb 81       	ldd	r30, Y+3	; 0x03
     81e:	fc 81       	ldd	r31, Y+4	; 0x04
     820:	80 81       	ld	r24, Z
     822:	91 81       	ldd	r25, Z+1	; 0x01
     824:	98 87       	std	Y+8, r25	; 0x08
     826:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     828:	89 85       	ldd	r24, Y+9	; 0x09
     82a:	9a 85       	ldd	r25, Y+10	; 0x0a
     82c:	2b 85       	ldd	r18, Y+11	; 0x0b
     82e:	3c 85       	ldd	r19, Y+12	; 0x0c
     830:	b9 01       	movw	r22, r18
     832:	0e 94 cc 05 	call	0xb98	; 0xb98 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     836:	2f 81       	ldd	r18, Y+7	; 0x07
     838:	38 85       	ldd	r19, Y+8	; 0x08
     83a:	8b 85       	ldd	r24, Y+11	; 0x0b
     83c:	9c 85       	ldd	r25, Y+12	; 0x0c
     83e:	28 2b       	or	r18, r24
     840:	39 2b       	or	r19, r25
     842:	8d 85       	ldd	r24, Y+13	; 0x0d
     844:	9e 85       	ldd	r25, Y+14	; 0x0e
     846:	28 23       	and	r18, r24
     848:	39 23       	and	r19, r25
     84a:	8d 85       	ldd	r24, Y+13	; 0x0d
     84c:	9e 85       	ldd	r25, Y+14	; 0x0e
     84e:	28 17       	cp	r18, r24
     850:	39 07       	cpc	r19, r25
     852:	c9 f4       	brne	.+50     	; 0x886 <__stack+0x27>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     854:	2f 81       	ldd	r18, Y+7	; 0x07
     856:	38 85       	ldd	r19, Y+8	; 0x08
     858:	8b 85       	ldd	r24, Y+11	; 0x0b
     85a:	9c 85       	ldd	r25, Y+12	; 0x0c
     85c:	82 2b       	or	r24, r18
     85e:	93 2b       	or	r25, r19
     860:	9e 83       	std	Y+6, r25	; 0x06
     862:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     864:	eb 81       	ldd	r30, Y+3	; 0x03
     866:	fc 81       	ldd	r31, Y+4	; 0x04
     868:	20 81       	ld	r18, Z
     86a:	31 81       	ldd	r19, Z+1	; 0x01
     86c:	8d 85       	ldd	r24, Y+13	; 0x0d
     86e:	9e 85       	ldd	r25, Y+14	; 0x0e
     870:	80 95       	com	r24
     872:	90 95       	com	r25
     874:	82 23       	and	r24, r18
     876:	93 23       	and	r25, r19
     878:	eb 81       	ldd	r30, Y+3	; 0x03
     87a:	fc 81       	ldd	r31, Y+4	; 0x04
     87c:	91 83       	std	Z+1, r25	; 0x01
     87e:	80 83       	st	Z, r24

			xTicksToWait = 0;
     880:	18 8a       	std	Y+16, r1	; 0x10
     882:	1f 86       	std	Y+15, r1	; 0x0f
     884:	1e c0       	rjmp	.+60     	; 0x8c2 <__stack+0x63>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     886:	8f 85       	ldd	r24, Y+15	; 0x0f
     888:	98 89       	ldd	r25, Y+16	; 0x10
     88a:	00 97       	sbiw	r24, 0x00	; 0
     88c:	91 f0       	breq	.+36     	; 0x8b2 <__stack+0x53>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     88e:	8b 81       	ldd	r24, Y+3	; 0x03
     890:	9c 81       	ldd	r25, Y+4	; 0x04
     892:	bc 01       	movw	r22, r24
     894:	6e 5f       	subi	r22, 0xFE	; 254
     896:	7f 4f       	sbci	r23, 0xFF	; 255
     898:	8d 85       	ldd	r24, Y+13	; 0x0d
     89a:	9e 85       	ldd	r25, Y+14	; 0x0e
     89c:	9c 01       	movw	r18, r24
     89e:	35 60       	ori	r19, 0x05	; 5
     8a0:	4f 85       	ldd	r20, Y+15	; 0x0f
     8a2:	58 89       	ldd	r21, Y+16	; 0x10
     8a4:	cb 01       	movw	r24, r22
     8a6:	b9 01       	movw	r22, r18
     8a8:	0e 94 69 23 	call	0x46d2	; 0x46d2 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     8ac:	1e 82       	std	Y+6, r1	; 0x06
     8ae:	1d 82       	std	Y+5, r1	; 0x05
     8b0:	08 c0       	rjmp	.+16     	; 0x8c2 <__stack+0x63>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     8b2:	eb 81       	ldd	r30, Y+3	; 0x03
     8b4:	fc 81       	ldd	r31, Y+4	; 0x04
     8b6:	80 81       	ld	r24, Z
     8b8:	91 81       	ldd	r25, Z+1	; 0x01
     8ba:	9e 83       	std	Y+6, r25	; 0x06
     8bc:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     8be:	81 e0       	ldi	r24, 0x01	; 1
     8c0:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     8c2:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
     8c6:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     8c8:	8f 85       	ldd	r24, Y+15	; 0x0f
     8ca:	98 89       	ldd	r25, Y+16	; 0x10
     8cc:	00 97       	sbiw	r24, 0x00	; 0
     8ce:	09 f4       	brne	.+2      	; 0x8d2 <__stack+0x73>
     8d0:	3a c0       	rjmp	.+116    	; 0x946 <__stack+0xe7>
	{
		if( xAlreadyYielded == pdFALSE )
     8d2:	8a 81       	ldd	r24, Y+2	; 0x02
     8d4:	88 23       	and	r24, r24
     8d6:	11 f4       	brne	.+4      	; 0x8dc <__stack+0x7d>
		{
			portYIELD_WITHIN_API();
     8d8:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     8dc:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <uxTaskResetEventItemValue>
     8e0:	9e 83       	std	Y+6, r25	; 0x06
     8e2:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     8e4:	8d 81       	ldd	r24, Y+5	; 0x05
     8e6:	9e 81       	ldd	r25, Y+6	; 0x06
     8e8:	80 70       	andi	r24, 0x00	; 0
     8ea:	92 70       	andi	r25, 0x02	; 2
     8ec:	00 97       	sbiw	r24, 0x00	; 0
     8ee:	31 f5       	brne	.+76     	; 0x93c <__stack+0xdd>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     8f0:	0f b6       	in	r0, 0x3f	; 63
     8f2:	f8 94       	cli
     8f4:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     8f6:	eb 81       	ldd	r30, Y+3	; 0x03
     8f8:	fc 81       	ldd	r31, Y+4	; 0x04
     8fa:	80 81       	ld	r24, Z
     8fc:	91 81       	ldd	r25, Z+1	; 0x01
     8fe:	9e 83       	std	Y+6, r25	; 0x06
     900:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     902:	2d 81       	ldd	r18, Y+5	; 0x05
     904:	3e 81       	ldd	r19, Y+6	; 0x06
     906:	8d 85       	ldd	r24, Y+13	; 0x0d
     908:	9e 85       	ldd	r25, Y+14	; 0x0e
     90a:	28 23       	and	r18, r24
     90c:	39 23       	and	r19, r25
     90e:	8d 85       	ldd	r24, Y+13	; 0x0d
     910:	9e 85       	ldd	r25, Y+14	; 0x0e
     912:	28 17       	cp	r18, r24
     914:	39 07       	cpc	r19, r25
     916:	71 f4       	brne	.+28     	; 0x934 <__stack+0xd5>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     918:	eb 81       	ldd	r30, Y+3	; 0x03
     91a:	fc 81       	ldd	r31, Y+4	; 0x04
     91c:	20 81       	ld	r18, Z
     91e:	31 81       	ldd	r19, Z+1	; 0x01
     920:	8d 85       	ldd	r24, Y+13	; 0x0d
     922:	9e 85       	ldd	r25, Y+14	; 0x0e
     924:	80 95       	com	r24
     926:	90 95       	com	r25
     928:	82 23       	and	r24, r18
     92a:	93 23       	and	r25, r19
     92c:	eb 81       	ldd	r30, Y+3	; 0x03
     92e:	fc 81       	ldd	r31, Y+4	; 0x04
     930:	91 83       	std	Z+1, r25	; 0x01
     932:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     934:	0f 90       	pop	r0
     936:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     938:	81 e0       	ldi	r24, 0x01	; 1
     93a:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     93c:	8d 81       	ldd	r24, Y+5	; 0x05
     93e:	9e 81       	ldd	r25, Y+6	; 0x06
     940:	90 70       	andi	r25, 0x00	; 0
     942:	9e 83       	std	Y+6, r25	; 0x06
     944:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     946:	8d 81       	ldd	r24, Y+5	; 0x05
     948:	9e 81       	ldd	r25, Y+6	; 0x06
}
     94a:	60 96       	adiw	r28, 0x10	; 16
     94c:	0f b6       	in	r0, 0x3f	; 63
     94e:	f8 94       	cli
     950:	de bf       	out	0x3e, r29	; 62
     952:	0f be       	out	0x3f, r0	; 63
     954:	cd bf       	out	0x3d, r28	; 61
     956:	cf 91       	pop	r28
     958:	df 91       	pop	r29
     95a:	08 95       	ret

0000095c <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     95c:	0f 93       	push	r16
     95e:	1f 93       	push	r17
     960:	df 93       	push	r29
     962:	cf 93       	push	r28
     964:	cd b7       	in	r28, 0x3d	; 61
     966:	de b7       	in	r29, 0x3e	; 62
     968:	63 97       	sbiw	r28, 0x13	; 19
     96a:	0f b6       	in	r0, 0x3f	; 63
     96c:	f8 94       	cli
     96e:	de bf       	out	0x3e, r29	; 62
     970:	0f be       	out	0x3f, r0	; 63
     972:	cd bf       	out	0x3d, r28	; 61
     974:	9d 87       	std	Y+13, r25	; 0x0d
     976:	8c 87       	std	Y+12, r24	; 0x0c
     978:	7f 87       	std	Y+15, r23	; 0x0f
     97a:	6e 87       	std	Y+14, r22	; 0x0e
     97c:	48 8b       	std	Y+16, r20	; 0x10
     97e:	29 8b       	std	Y+17, r18	; 0x11
     980:	1b 8b       	std	Y+19, r17	; 0x13
     982:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     984:	8c 85       	ldd	r24, Y+12	; 0x0c
     986:	9d 85       	ldd	r25, Y+13	; 0x0d
     988:	9b 87       	std	Y+11, r25	; 0x0b
     98a:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     98c:	1f 82       	std	Y+7, r1	; 0x07
     98e:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     990:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     992:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     996:	ea 85       	ldd	r30, Y+10	; 0x0a
     998:	fb 85       	ldd	r31, Y+11	; 0x0b
     99a:	80 81       	ld	r24, Z
     99c:	91 81       	ldd	r25, Z+1	; 0x01
     99e:	9a 83       	std	Y+2, r25	; 0x02
     9a0:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     9a2:	89 81       	ldd	r24, Y+1	; 0x01
     9a4:	9a 81       	ldd	r25, Y+2	; 0x02
     9a6:	2e 85       	ldd	r18, Y+14	; 0x0e
     9a8:	3f 85       	ldd	r19, Y+15	; 0x0f
     9aa:	b9 01       	movw	r22, r18
     9ac:	49 89       	ldd	r20, Y+17	; 0x11
     9ae:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <prvTestWaitCondition>
     9b2:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     9b4:	8d 81       	ldd	r24, Y+5	; 0x05
     9b6:	88 23       	and	r24, r24
     9b8:	c1 f0       	breq	.+48     	; 0x9ea <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     9ba:	89 81       	ldd	r24, Y+1	; 0x01
     9bc:	9a 81       	ldd	r25, Y+2	; 0x02
     9be:	99 87       	std	Y+9, r25	; 0x09
     9c0:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     9c2:	1b 8a       	std	Y+19, r1	; 0x13
     9c4:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     9c6:	88 89       	ldd	r24, Y+16	; 0x10
     9c8:	88 23       	and	r24, r24
     9ca:	e9 f1       	breq	.+122    	; 0xa46 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     9cc:	ea 85       	ldd	r30, Y+10	; 0x0a
     9ce:	fb 85       	ldd	r31, Y+11	; 0x0b
     9d0:	20 81       	ld	r18, Z
     9d2:	31 81       	ldd	r19, Z+1	; 0x01
     9d4:	8e 85       	ldd	r24, Y+14	; 0x0e
     9d6:	9f 85       	ldd	r25, Y+15	; 0x0f
     9d8:	80 95       	com	r24
     9da:	90 95       	com	r25
     9dc:	82 23       	and	r24, r18
     9de:	93 23       	and	r25, r19
     9e0:	ea 85       	ldd	r30, Y+10	; 0x0a
     9e2:	fb 85       	ldd	r31, Y+11	; 0x0b
     9e4:	91 83       	std	Z+1, r25	; 0x01
     9e6:	80 83       	st	Z, r24
     9e8:	2e c0       	rjmp	.+92     	; 0xa46 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     9ea:	8a 89       	ldd	r24, Y+18	; 0x12
     9ec:	9b 89       	ldd	r25, Y+19	; 0x13
     9ee:	00 97       	sbiw	r24, 0x00	; 0
     9f0:	39 f4       	brne	.+14     	; 0xa00 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     9f2:	89 81       	ldd	r24, Y+1	; 0x01
     9f4:	9a 81       	ldd	r25, Y+2	; 0x02
     9f6:	99 87       	std	Y+9, r25	; 0x09
     9f8:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     9fa:	81 e0       	ldi	r24, 0x01	; 1
     9fc:	8b 83       	std	Y+3, r24	; 0x03
     9fe:	23 c0       	rjmp	.+70     	; 0xa46 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     a00:	88 89       	ldd	r24, Y+16	; 0x10
     a02:	88 23       	and	r24, r24
     a04:	29 f0       	breq	.+10     	; 0xa10 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     a06:	8e 81       	ldd	r24, Y+6	; 0x06
     a08:	9f 81       	ldd	r25, Y+7	; 0x07
     a0a:	91 60       	ori	r25, 0x01	; 1
     a0c:	9f 83       	std	Y+7, r25	; 0x07
     a0e:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     a10:	89 89       	ldd	r24, Y+17	; 0x11
     a12:	88 23       	and	r24, r24
     a14:	29 f0       	breq	.+10     	; 0xa20 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     a16:	8e 81       	ldd	r24, Y+6	; 0x06
     a18:	9f 81       	ldd	r25, Y+7	; 0x07
     a1a:	94 60       	ori	r25, 0x04	; 4
     a1c:	9f 83       	std	Y+7, r25	; 0x07
     a1e:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     a20:	8a 85       	ldd	r24, Y+10	; 0x0a
     a22:	9b 85       	ldd	r25, Y+11	; 0x0b
     a24:	bc 01       	movw	r22, r24
     a26:	6e 5f       	subi	r22, 0xFE	; 254
     a28:	7f 4f       	sbci	r23, 0xFF	; 255
     a2a:	2e 85       	ldd	r18, Y+14	; 0x0e
     a2c:	3f 85       	ldd	r19, Y+15	; 0x0f
     a2e:	8e 81       	ldd	r24, Y+6	; 0x06
     a30:	9f 81       	ldd	r25, Y+7	; 0x07
     a32:	28 2b       	or	r18, r24
     a34:	39 2b       	or	r19, r25
     a36:	4a 89       	ldd	r20, Y+18	; 0x12
     a38:	5b 89       	ldd	r21, Y+19	; 0x13
     a3a:	cb 01       	movw	r24, r22
     a3c:	b9 01       	movw	r22, r18
     a3e:	0e 94 69 23 	call	0x46d2	; 0x46d2 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     a42:	19 86       	std	Y+9, r1	; 0x09
     a44:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     a46:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
     a4a:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     a4c:	8a 89       	ldd	r24, Y+18	; 0x12
     a4e:	9b 89       	ldd	r25, Y+19	; 0x13
     a50:	00 97       	sbiw	r24, 0x00	; 0
     a52:	09 f4       	brne	.+2      	; 0xa56 <xEventGroupWaitBits+0xfa>
     a54:	3c c0       	rjmp	.+120    	; 0xace <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     a56:	8c 81       	ldd	r24, Y+4	; 0x04
     a58:	88 23       	and	r24, r24
     a5a:	11 f4       	brne	.+4      	; 0xa60 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     a5c:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     a60:	0e 94 dc 25 	call	0x4bb8	; 0x4bb8 <uxTaskResetEventItemValue>
     a64:	99 87       	std	Y+9, r25	; 0x09
     a66:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     a68:	88 85       	ldd	r24, Y+8	; 0x08
     a6a:	99 85       	ldd	r25, Y+9	; 0x09
     a6c:	80 70       	andi	r24, 0x00	; 0
     a6e:	92 70       	andi	r25, 0x02	; 2
     a70:	00 97       	sbiw	r24, 0x00	; 0
     a72:	41 f5       	brne	.+80     	; 0xac4 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     a74:	0f b6       	in	r0, 0x3f	; 63
     a76:	f8 94       	cli
     a78:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     a7a:	ea 85       	ldd	r30, Y+10	; 0x0a
     a7c:	fb 85       	ldd	r31, Y+11	; 0x0b
     a7e:	80 81       	ld	r24, Z
     a80:	91 81       	ldd	r25, Z+1	; 0x01
     a82:	99 87       	std	Y+9, r25	; 0x09
     a84:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     a86:	88 85       	ldd	r24, Y+8	; 0x08
     a88:	99 85       	ldd	r25, Y+9	; 0x09
     a8a:	2e 85       	ldd	r18, Y+14	; 0x0e
     a8c:	3f 85       	ldd	r19, Y+15	; 0x0f
     a8e:	b9 01       	movw	r22, r18
     a90:	49 89       	ldd	r20, Y+17	; 0x11
     a92:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <prvTestWaitCondition>
     a96:	88 23       	and	r24, r24
     a98:	89 f0       	breq	.+34     	; 0xabc <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     a9a:	88 89       	ldd	r24, Y+16	; 0x10
     a9c:	88 23       	and	r24, r24
     a9e:	71 f0       	breq	.+28     	; 0xabc <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     aa0:	ea 85       	ldd	r30, Y+10	; 0x0a
     aa2:	fb 85       	ldd	r31, Y+11	; 0x0b
     aa4:	20 81       	ld	r18, Z
     aa6:	31 81       	ldd	r19, Z+1	; 0x01
     aa8:	8e 85       	ldd	r24, Y+14	; 0x0e
     aaa:	9f 85       	ldd	r25, Y+15	; 0x0f
     aac:	80 95       	com	r24
     aae:	90 95       	com	r25
     ab0:	82 23       	and	r24, r18
     ab2:	93 23       	and	r25, r19
     ab4:	ea 85       	ldd	r30, Y+10	; 0x0a
     ab6:	fb 85       	ldd	r31, Y+11	; 0x0b
     ab8:	91 83       	std	Z+1, r25	; 0x01
     aba:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     abc:	81 e0       	ldi	r24, 0x01	; 1
     abe:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     ac0:	0f 90       	pop	r0
     ac2:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     ac4:	88 85       	ldd	r24, Y+8	; 0x08
     ac6:	99 85       	ldd	r25, Y+9	; 0x09
     ac8:	90 70       	andi	r25, 0x00	; 0
     aca:	99 87       	std	Y+9, r25	; 0x09
     acc:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     ace:	88 85       	ldd	r24, Y+8	; 0x08
     ad0:	99 85       	ldd	r25, Y+9	; 0x09
}
     ad2:	63 96       	adiw	r28, 0x13	; 19
     ad4:	0f b6       	in	r0, 0x3f	; 63
     ad6:	f8 94       	cli
     ad8:	de bf       	out	0x3e, r29	; 62
     ada:	0f be       	out	0x3f, r0	; 63
     adc:	cd bf       	out	0x3d, r28	; 61
     ade:	cf 91       	pop	r28
     ae0:	df 91       	pop	r29
     ae2:	1f 91       	pop	r17
     ae4:	0f 91       	pop	r16
     ae6:	08 95       	ret

00000ae8 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     ae8:	df 93       	push	r29
     aea:	cf 93       	push	r28
     aec:	cd b7       	in	r28, 0x3d	; 61
     aee:	de b7       	in	r29, 0x3e	; 62
     af0:	28 97       	sbiw	r28, 0x08	; 8
     af2:	0f b6       	in	r0, 0x3f	; 63
     af4:	f8 94       	cli
     af6:	de bf       	out	0x3e, r29	; 62
     af8:	0f be       	out	0x3f, r0	; 63
     afa:	cd bf       	out	0x3d, r28	; 61
     afc:	9e 83       	std	Y+6, r25	; 0x06
     afe:	8d 83       	std	Y+5, r24	; 0x05
     b00:	78 87       	std	Y+8, r23	; 0x08
     b02:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     b04:	8d 81       	ldd	r24, Y+5	; 0x05
     b06:	9e 81       	ldd	r25, Y+6	; 0x06
     b08:	9c 83       	std	Y+4, r25	; 0x04
     b0a:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     b0c:	0f b6       	in	r0, 0x3f	; 63
     b0e:	f8 94       	cli
     b10:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     b12:	eb 81       	ldd	r30, Y+3	; 0x03
     b14:	fc 81       	ldd	r31, Y+4	; 0x04
     b16:	80 81       	ld	r24, Z
     b18:	91 81       	ldd	r25, Z+1	; 0x01
     b1a:	9a 83       	std	Y+2, r25	; 0x02
     b1c:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     b1e:	eb 81       	ldd	r30, Y+3	; 0x03
     b20:	fc 81       	ldd	r31, Y+4	; 0x04
     b22:	20 81       	ld	r18, Z
     b24:	31 81       	ldd	r19, Z+1	; 0x01
     b26:	8f 81       	ldd	r24, Y+7	; 0x07
     b28:	98 85       	ldd	r25, Y+8	; 0x08
     b2a:	80 95       	com	r24
     b2c:	90 95       	com	r25
     b2e:	82 23       	and	r24, r18
     b30:	93 23       	and	r25, r19
     b32:	eb 81       	ldd	r30, Y+3	; 0x03
     b34:	fc 81       	ldd	r31, Y+4	; 0x04
     b36:	91 83       	std	Z+1, r25	; 0x01
     b38:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     b3a:	0f 90       	pop	r0
     b3c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     b3e:	89 81       	ldd	r24, Y+1	; 0x01
     b40:	9a 81       	ldd	r25, Y+2	; 0x02
}
     b42:	28 96       	adiw	r28, 0x08	; 8
     b44:	0f b6       	in	r0, 0x3f	; 63
     b46:	f8 94       	cli
     b48:	de bf       	out	0x3e, r29	; 62
     b4a:	0f be       	out	0x3f, r0	; 63
     b4c:	cd bf       	out	0x3d, r28	; 61
     b4e:	cf 91       	pop	r28
     b50:	df 91       	pop	r29
     b52:	08 95       	ret

00000b54 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     b54:	df 93       	push	r29
     b56:	cf 93       	push	r28
     b58:	cd b7       	in	r28, 0x3d	; 61
     b5a:	de b7       	in	r29, 0x3e	; 62
     b5c:	27 97       	sbiw	r28, 0x07	; 7
     b5e:	0f b6       	in	r0, 0x3f	; 63
     b60:	f8 94       	cli
     b62:	de bf       	out	0x3e, r29	; 62
     b64:	0f be       	out	0x3f, r0	; 63
     b66:	cd bf       	out	0x3d, r28	; 61
     b68:	9f 83       	std	Y+7, r25	; 0x07
     b6a:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     b6c:	8e 81       	ldd	r24, Y+6	; 0x06
     b6e:	9f 81       	ldd	r25, Y+7	; 0x07
     b70:	9c 83       	std	Y+4, r25	; 0x04
     b72:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     b74:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     b76:	eb 81       	ldd	r30, Y+3	; 0x03
     b78:	fc 81       	ldd	r31, Y+4	; 0x04
     b7a:	80 81       	ld	r24, Z
     b7c:	91 81       	ldd	r25, Z+1	; 0x01
     b7e:	9a 83       	std	Y+2, r25	; 0x02
     b80:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     b82:	89 81       	ldd	r24, Y+1	; 0x01
     b84:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     b86:	27 96       	adiw	r28, 0x07	; 7
     b88:	0f b6       	in	r0, 0x3f	; 63
     b8a:	f8 94       	cli
     b8c:	de bf       	out	0x3e, r29	; 62
     b8e:	0f be       	out	0x3f, r0	; 63
     b90:	cd bf       	out	0x3d, r28	; 61
     b92:	cf 91       	pop	r28
     b94:	df 91       	pop	r29
     b96:	08 95       	ret

00000b98 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     b98:	df 93       	push	r29
     b9a:	cf 93       	push	r28
     b9c:	cd b7       	in	r28, 0x3d	; 61
     b9e:	de b7       	in	r29, 0x3e	; 62
     ba0:	65 97       	sbiw	r28, 0x15	; 21
     ba2:	0f b6       	in	r0, 0x3f	; 63
     ba4:	f8 94       	cli
     ba6:	de bf       	out	0x3e, r29	; 62
     ba8:	0f be       	out	0x3f, r0	; 63
     baa:	cd bf       	out	0x3d, r28	; 61
     bac:	9b 8b       	std	Y+19, r25	; 0x13
     bae:	8a 8b       	std	Y+18, r24	; 0x12
     bb0:	7d 8b       	std	Y+21, r23	; 0x15
     bb2:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     bb4:	19 86       	std	Y+9, r1	; 0x09
     bb6:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     bb8:	8a 89       	ldd	r24, Y+18	; 0x12
     bba:	9b 89       	ldd	r25, Y+19	; 0x13
     bbc:	9b 83       	std	Y+3, r25	; 0x03
     bbe:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     bc0:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     bc2:	8a 81       	ldd	r24, Y+2	; 0x02
     bc4:	9b 81       	ldd	r25, Y+3	; 0x03
     bc6:	02 96       	adiw	r24, 0x02	; 2
     bc8:	9b 87       	std	Y+11, r25	; 0x0b
     bca:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     bcc:	8a 85       	ldd	r24, Y+10	; 0x0a
     bce:	9b 85       	ldd	r25, Y+11	; 0x0b
     bd0:	03 96       	adiw	r24, 0x03	; 3
     bd2:	9d 87       	std	Y+13, r25	; 0x0d
     bd4:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     bd6:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     bda:	ea 85       	ldd	r30, Y+10	; 0x0a
     bdc:	fb 85       	ldd	r31, Y+11	; 0x0b
     bde:	85 81       	ldd	r24, Z+5	; 0x05
     be0:	96 81       	ldd	r25, Z+6	; 0x06
     be2:	99 8b       	std	Y+17, r25	; 0x11
     be4:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     be6:	ea 81       	ldd	r30, Y+2	; 0x02
     be8:	fb 81       	ldd	r31, Y+3	; 0x03
     bea:	20 81       	ld	r18, Z
     bec:	31 81       	ldd	r19, Z+1	; 0x01
     bee:	8c 89       	ldd	r24, Y+20	; 0x14
     bf0:	9d 89       	ldd	r25, Y+21	; 0x15
     bf2:	82 2b       	or	r24, r18
     bf4:	93 2b       	or	r25, r19
     bf6:	ea 81       	ldd	r30, Y+2	; 0x02
     bf8:	fb 81       	ldd	r31, Y+3	; 0x03
     bfa:	91 83       	std	Z+1, r25	; 0x01
     bfc:	80 83       	st	Z, r24
     bfe:	59 c0       	rjmp	.+178    	; 0xcb2 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     c00:	e8 89       	ldd	r30, Y+16	; 0x10
     c02:	f9 89       	ldd	r31, Y+17	; 0x11
     c04:	82 81       	ldd	r24, Z+2	; 0x02
     c06:	93 81       	ldd	r25, Z+3	; 0x03
     c08:	9f 87       	std	Y+15, r25	; 0x0f
     c0a:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     c0c:	e8 89       	ldd	r30, Y+16	; 0x10
     c0e:	f9 89       	ldd	r31, Y+17	; 0x11
     c10:	80 81       	ld	r24, Z
     c12:	91 81       	ldd	r25, Z+1	; 0x01
     c14:	9f 83       	std	Y+7, r25	; 0x07
     c16:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     c18:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     c1a:	8e 81       	ldd	r24, Y+6	; 0x06
     c1c:	9f 81       	ldd	r25, Y+7	; 0x07
     c1e:	80 70       	andi	r24, 0x00	; 0
     c20:	9d 83       	std	Y+5, r25	; 0x05
     c22:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     c24:	8e 81       	ldd	r24, Y+6	; 0x06
     c26:	9f 81       	ldd	r25, Y+7	; 0x07
     c28:	90 70       	andi	r25, 0x00	; 0
     c2a:	9f 83       	std	Y+7, r25	; 0x07
     c2c:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     c2e:	8c 81       	ldd	r24, Y+4	; 0x04
     c30:	9d 81       	ldd	r25, Y+5	; 0x05
     c32:	80 70       	andi	r24, 0x00	; 0
     c34:	94 70       	andi	r25, 0x04	; 4
     c36:	00 97       	sbiw	r24, 0x00	; 0
     c38:	69 f4       	brne	.+26     	; 0xc54 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     c3a:	ea 81       	ldd	r30, Y+2	; 0x02
     c3c:	fb 81       	ldd	r31, Y+3	; 0x03
     c3e:	20 81       	ld	r18, Z
     c40:	31 81       	ldd	r19, Z+1	; 0x01
     c42:	8e 81       	ldd	r24, Y+6	; 0x06
     c44:	9f 81       	ldd	r25, Y+7	; 0x07
     c46:	82 23       	and	r24, r18
     c48:	93 23       	and	r25, r19
     c4a:	00 97       	sbiw	r24, 0x00	; 0
     c4c:	91 f0       	breq	.+36     	; 0xc72 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     c4e:	81 e0       	ldi	r24, 0x01	; 1
     c50:	89 83       	std	Y+1, r24	; 0x01
     c52:	0f c0       	rjmp	.+30     	; 0xc72 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     c54:	ea 81       	ldd	r30, Y+2	; 0x02
     c56:	fb 81       	ldd	r31, Y+3	; 0x03
     c58:	20 81       	ld	r18, Z
     c5a:	31 81       	ldd	r19, Z+1	; 0x01
     c5c:	8e 81       	ldd	r24, Y+6	; 0x06
     c5e:	9f 81       	ldd	r25, Y+7	; 0x07
     c60:	28 23       	and	r18, r24
     c62:	39 23       	and	r19, r25
     c64:	8e 81       	ldd	r24, Y+6	; 0x06
     c66:	9f 81       	ldd	r25, Y+7	; 0x07
     c68:	28 17       	cp	r18, r24
     c6a:	39 07       	cpc	r19, r25
     c6c:	11 f4       	brne	.+4      	; 0xc72 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     c6e:	81 e0       	ldi	r24, 0x01	; 1
     c70:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     c72:	89 81       	ldd	r24, Y+1	; 0x01
     c74:	88 23       	and	r24, r24
     c76:	c9 f0       	breq	.+50     	; 0xcaa <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     c78:	8c 81       	ldd	r24, Y+4	; 0x04
     c7a:	9d 81       	ldd	r25, Y+5	; 0x05
     c7c:	80 70       	andi	r24, 0x00	; 0
     c7e:	91 70       	andi	r25, 0x01	; 1
     c80:	00 97       	sbiw	r24, 0x00	; 0
     c82:	41 f0       	breq	.+16     	; 0xc94 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     c84:	88 85       	ldd	r24, Y+8	; 0x08
     c86:	99 85       	ldd	r25, Y+9	; 0x09
     c88:	2e 81       	ldd	r18, Y+6	; 0x06
     c8a:	3f 81       	ldd	r19, Y+7	; 0x07
     c8c:	82 2b       	or	r24, r18
     c8e:	93 2b       	or	r25, r19
     c90:	99 87       	std	Y+9, r25	; 0x09
     c92:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     c94:	ea 81       	ldd	r30, Y+2	; 0x02
     c96:	fb 81       	ldd	r31, Y+3	; 0x03
     c98:	80 81       	ld	r24, Z
     c9a:	91 81       	ldd	r25, Z+1	; 0x01
     c9c:	9c 01       	movw	r18, r24
     c9e:	32 60       	ori	r19, 0x02	; 2
     ca0:	88 89       	ldd	r24, Y+16	; 0x10
     ca2:	99 89       	ldd	r25, Y+17	; 0x11
     ca4:	b9 01       	movw	r22, r18
     ca6:	0e 94 04 24 	call	0x4808	; 0x4808 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     caa:	8e 85       	ldd	r24, Y+14	; 0x0e
     cac:	9f 85       	ldd	r25, Y+15	; 0x0f
     cae:	99 8b       	std	Y+17, r25	; 0x11
     cb0:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     cb2:	28 89       	ldd	r18, Y+16	; 0x10
     cb4:	39 89       	ldd	r19, Y+17	; 0x11
     cb6:	8c 85       	ldd	r24, Y+12	; 0x0c
     cb8:	9d 85       	ldd	r25, Y+13	; 0x0d
     cba:	28 17       	cp	r18, r24
     cbc:	39 07       	cpc	r19, r25
     cbe:	09 f0       	breq	.+2      	; 0xcc2 <xEventGroupSetBits+0x12a>
     cc0:	9f cf       	rjmp	.-194    	; 0xc00 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     cc2:	ea 81       	ldd	r30, Y+2	; 0x02
     cc4:	fb 81       	ldd	r31, Y+3	; 0x03
     cc6:	20 81       	ld	r18, Z
     cc8:	31 81       	ldd	r19, Z+1	; 0x01
     cca:	88 85       	ldd	r24, Y+8	; 0x08
     ccc:	99 85       	ldd	r25, Y+9	; 0x09
     cce:	80 95       	com	r24
     cd0:	90 95       	com	r25
     cd2:	82 23       	and	r24, r18
     cd4:	93 23       	and	r25, r19
     cd6:	ea 81       	ldd	r30, Y+2	; 0x02
     cd8:	fb 81       	ldd	r31, Y+3	; 0x03
     cda:	91 83       	std	Z+1, r25	; 0x01
     cdc:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     cde:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     ce2:	ea 81       	ldd	r30, Y+2	; 0x02
     ce4:	fb 81       	ldd	r31, Y+3	; 0x03
     ce6:	80 81       	ld	r24, Z
     ce8:	91 81       	ldd	r25, Z+1	; 0x01
}
     cea:	65 96       	adiw	r28, 0x15	; 21
     cec:	0f b6       	in	r0, 0x3f	; 63
     cee:	f8 94       	cli
     cf0:	de bf       	out	0x3e, r29	; 62
     cf2:	0f be       	out	0x3f, r0	; 63
     cf4:	cd bf       	out	0x3d, r28	; 61
     cf6:	cf 91       	pop	r28
     cf8:	df 91       	pop	r29
     cfa:	08 95       	ret

00000cfc <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     cfc:	df 93       	push	r29
     cfe:	cf 93       	push	r28
     d00:	00 d0       	rcall	.+0      	; 0xd02 <vEventGroupDelete+0x6>
     d02:	00 d0       	rcall	.+0      	; 0xd04 <vEventGroupDelete+0x8>
     d04:	00 d0       	rcall	.+0      	; 0xd06 <vEventGroupDelete+0xa>
     d06:	cd b7       	in	r28, 0x3d	; 61
     d08:	de b7       	in	r29, 0x3e	; 62
     d0a:	9e 83       	std	Y+6, r25	; 0x06
     d0c:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     d0e:	8d 81       	ldd	r24, Y+5	; 0x05
     d10:	9e 81       	ldd	r25, Y+6	; 0x06
     d12:	9c 83       	std	Y+4, r25	; 0x04
     d14:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     d16:	8b 81       	ldd	r24, Y+3	; 0x03
     d18:	9c 81       	ldd	r25, Y+4	; 0x04
     d1a:	02 96       	adiw	r24, 0x02	; 2
     d1c:	9a 83       	std	Y+2, r25	; 0x02
     d1e:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     d20:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <vTaskSuspendAll>
     d24:	08 c0       	rjmp	.+16     	; 0xd36 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     d26:	e9 81       	ldd	r30, Y+1	; 0x01
     d28:	fa 81       	ldd	r31, Y+2	; 0x02
     d2a:	85 81       	ldd	r24, Z+5	; 0x05
     d2c:	96 81       	ldd	r25, Z+6	; 0x06
     d2e:	60 e0       	ldi	r22, 0x00	; 0
     d30:	72 e0       	ldi	r23, 0x02	; 2
     d32:	0e 94 04 24 	call	0x4808	; 0x4808 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     d36:	e9 81       	ldd	r30, Y+1	; 0x01
     d38:	fa 81       	ldd	r31, Y+2	; 0x02
     d3a:	80 81       	ld	r24, Z
     d3c:	88 23       	and	r24, r24
     d3e:	99 f7       	brne	.-26     	; 0xd26 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     d40:	8b 81       	ldd	r24, Y+3	; 0x03
     d42:	9c 81       	ldd	r25, Y+4	; 0x04
     d44:	0e 94 71 07 	call	0xee2	; 0xee2 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     d48:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
}
     d4c:	26 96       	adiw	r28, 0x06	; 6
     d4e:	0f b6       	in	r0, 0x3f	; 63
     d50:	f8 94       	cli
     d52:	de bf       	out	0x3e, r29	; 62
     d54:	0f be       	out	0x3f, r0	; 63
     d56:	cd bf       	out	0x3d, r28	; 61
     d58:	cf 91       	pop	r28
     d5a:	df 91       	pop	r29
     d5c:	08 95       	ret

00000d5e <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     d5e:	df 93       	push	r29
     d60:	cf 93       	push	r28
     d62:	00 d0       	rcall	.+0      	; 0xd64 <vEventGroupSetBitsCallback+0x6>
     d64:	00 d0       	rcall	.+0      	; 0xd66 <vEventGroupSetBitsCallback+0x8>
     d66:	00 d0       	rcall	.+0      	; 0xd68 <vEventGroupSetBitsCallback+0xa>
     d68:	cd b7       	in	r28, 0x3d	; 61
     d6a:	de b7       	in	r29, 0x3e	; 62
     d6c:	9a 83       	std	Y+2, r25	; 0x02
     d6e:	89 83       	std	Y+1, r24	; 0x01
     d70:	4b 83       	std	Y+3, r20	; 0x03
     d72:	5c 83       	std	Y+4, r21	; 0x04
     d74:	6d 83       	std	Y+5, r22	; 0x05
     d76:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     d78:	89 81       	ldd	r24, Y+1	; 0x01
     d7a:	9a 81       	ldd	r25, Y+2	; 0x02
     d7c:	2b 81       	ldd	r18, Y+3	; 0x03
     d7e:	3c 81       	ldd	r19, Y+4	; 0x04
     d80:	b9 01       	movw	r22, r18
     d82:	0e 94 cc 05 	call	0xb98	; 0xb98 <xEventGroupSetBits>
}
     d86:	26 96       	adiw	r28, 0x06	; 6
     d88:	0f b6       	in	r0, 0x3f	; 63
     d8a:	f8 94       	cli
     d8c:	de bf       	out	0x3e, r29	; 62
     d8e:	0f be       	out	0x3f, r0	; 63
     d90:	cd bf       	out	0x3d, r28	; 61
     d92:	cf 91       	pop	r28
     d94:	df 91       	pop	r29
     d96:	08 95       	ret

00000d98 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     d98:	df 93       	push	r29
     d9a:	cf 93       	push	r28
     d9c:	00 d0       	rcall	.+0      	; 0xd9e <vEventGroupClearBitsCallback+0x6>
     d9e:	00 d0       	rcall	.+0      	; 0xda0 <vEventGroupClearBitsCallback+0x8>
     da0:	00 d0       	rcall	.+0      	; 0xda2 <vEventGroupClearBitsCallback+0xa>
     da2:	cd b7       	in	r28, 0x3d	; 61
     da4:	de b7       	in	r29, 0x3e	; 62
     da6:	9a 83       	std	Y+2, r25	; 0x02
     da8:	89 83       	std	Y+1, r24	; 0x01
     daa:	4b 83       	std	Y+3, r20	; 0x03
     dac:	5c 83       	std	Y+4, r21	; 0x04
     dae:	6d 83       	std	Y+5, r22	; 0x05
     db0:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     db2:	89 81       	ldd	r24, Y+1	; 0x01
     db4:	9a 81       	ldd	r25, Y+2	; 0x02
     db6:	2b 81       	ldd	r18, Y+3	; 0x03
     db8:	3c 81       	ldd	r19, Y+4	; 0x04
     dba:	b9 01       	movw	r22, r18
     dbc:	0e 94 74 05 	call	0xae8	; 0xae8 <xEventGroupClearBits>
}
     dc0:	26 96       	adiw	r28, 0x06	; 6
     dc2:	0f b6       	in	r0, 0x3f	; 63
     dc4:	f8 94       	cli
     dc6:	de bf       	out	0x3e, r29	; 62
     dc8:	0f be       	out	0x3f, r0	; 63
     dca:	cd bf       	out	0x3d, r28	; 61
     dcc:	cf 91       	pop	r28
     dce:	df 91       	pop	r29
     dd0:	08 95       	ret

00000dd2 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     dd2:	df 93       	push	r29
     dd4:	cf 93       	push	r28
     dd6:	00 d0       	rcall	.+0      	; 0xdd8 <prvTestWaitCondition+0x6>
     dd8:	00 d0       	rcall	.+0      	; 0xdda <prvTestWaitCondition+0x8>
     dda:	00 d0       	rcall	.+0      	; 0xddc <prvTestWaitCondition+0xa>
     ddc:	cd b7       	in	r28, 0x3d	; 61
     dde:	de b7       	in	r29, 0x3e	; 62
     de0:	9b 83       	std	Y+3, r25	; 0x03
     de2:	8a 83       	std	Y+2, r24	; 0x02
     de4:	7d 83       	std	Y+5, r23	; 0x05
     de6:	6c 83       	std	Y+4, r22	; 0x04
     de8:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     dea:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     dec:	8e 81       	ldd	r24, Y+6	; 0x06
     dee:	88 23       	and	r24, r24
     df0:	59 f4       	brne	.+22     	; 0xe08 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     df2:	8a 81       	ldd	r24, Y+2	; 0x02
     df4:	9b 81       	ldd	r25, Y+3	; 0x03
     df6:	2c 81       	ldd	r18, Y+4	; 0x04
     df8:	3d 81       	ldd	r19, Y+5	; 0x05
     dfa:	82 23       	and	r24, r18
     dfc:	93 23       	and	r25, r19
     dfe:	00 97       	sbiw	r24, 0x00	; 0
     e00:	81 f0       	breq	.+32     	; 0xe22 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     e02:	81 e0       	ldi	r24, 0x01	; 1
     e04:	89 83       	std	Y+1, r24	; 0x01
     e06:	0d c0       	rjmp	.+26     	; 0xe22 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     e08:	2a 81       	ldd	r18, Y+2	; 0x02
     e0a:	3b 81       	ldd	r19, Y+3	; 0x03
     e0c:	8c 81       	ldd	r24, Y+4	; 0x04
     e0e:	9d 81       	ldd	r25, Y+5	; 0x05
     e10:	28 23       	and	r18, r24
     e12:	39 23       	and	r19, r25
     e14:	8c 81       	ldd	r24, Y+4	; 0x04
     e16:	9d 81       	ldd	r25, Y+5	; 0x05
     e18:	28 17       	cp	r18, r24
     e1a:	39 07       	cpc	r19, r25
     e1c:	11 f4       	brne	.+4      	; 0xe22 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     e1e:	81 e0       	ldi	r24, 0x01	; 1
     e20:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     e22:	89 81       	ldd	r24, Y+1	; 0x01
}
     e24:	26 96       	adiw	r28, 0x06	; 6
     e26:	0f b6       	in	r0, 0x3f	; 63
     e28:	f8 94       	cli
     e2a:	de bf       	out	0x3e, r29	; 62
     e2c:	0f be       	out	0x3f, r0	; 63
     e2e:	cd bf       	out	0x3d, r28	; 61
     e30:	cf 91       	pop	r28
     e32:	df 91       	pop	r29
     e34:	08 95       	ret

00000e36 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     e36:	df 93       	push	r29
     e38:	cf 93       	push	r28
     e3a:	00 d0       	rcall	.+0      	; 0xe3c <pvPortMalloc+0x6>
     e3c:	00 d0       	rcall	.+0      	; 0xe3e <pvPortMalloc+0x8>
     e3e:	cd b7       	in	r28, 0x3d	; 61
     e40:	de b7       	in	r29, 0x3e	; 62
     e42:	9c 83       	std	Y+4, r25	; 0x04
     e44:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     e46:	1a 82       	std	Y+2, r1	; 0x02
     e48:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     e4a:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     e4e:	80 91 af 00 	lds	r24, 0x00AF
     e52:	90 91 b0 00 	lds	r25, 0x00B0
     e56:	00 97       	sbiw	r24, 0x00	; 0
     e58:	31 f4       	brne	.+12     	; 0xe66 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     e5a:	82 eb       	ldi	r24, 0xB2	; 178
     e5c:	90 e0       	ldi	r25, 0x00	; 0
     e5e:	90 93 b0 00 	sts	0x00B0, r25
     e62:	80 93 af 00 	sts	0x00AF, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     e66:	80 91 ad 00 	lds	r24, 0x00AD
     e6a:	90 91 ae 00 	lds	r25, 0x00AE
     e6e:	2b 81       	ldd	r18, Y+3	; 0x03
     e70:	3c 81       	ldd	r19, Y+4	; 0x04
     e72:	82 0f       	add	r24, r18
     e74:	93 1f       	adc	r25, r19
     e76:	25 e0       	ldi	r18, 0x05	; 5
     e78:	8b 3d       	cpi	r24, 0xDB	; 219
     e7a:	92 07       	cpc	r25, r18
     e7c:	38 f5       	brcc	.+78     	; 0xecc <pvPortMalloc+0x96>
     e7e:	20 91 ad 00 	lds	r18, 0x00AD
     e82:	30 91 ae 00 	lds	r19, 0x00AE
     e86:	8b 81       	ldd	r24, Y+3	; 0x03
     e88:	9c 81       	ldd	r25, Y+4	; 0x04
     e8a:	28 0f       	add	r18, r24
     e8c:	39 1f       	adc	r19, r25
     e8e:	80 91 ad 00 	lds	r24, 0x00AD
     e92:	90 91 ae 00 	lds	r25, 0x00AE
     e96:	82 17       	cp	r24, r18
     e98:	93 07       	cpc	r25, r19
     e9a:	c0 f4       	brcc	.+48     	; 0xecc <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     e9c:	20 91 af 00 	lds	r18, 0x00AF
     ea0:	30 91 b0 00 	lds	r19, 0x00B0
     ea4:	80 91 ad 00 	lds	r24, 0x00AD
     ea8:	90 91 ae 00 	lds	r25, 0x00AE
     eac:	82 0f       	add	r24, r18
     eae:	93 1f       	adc	r25, r19
     eb0:	9a 83       	std	Y+2, r25	; 0x02
     eb2:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     eb4:	20 91 ad 00 	lds	r18, 0x00AD
     eb8:	30 91 ae 00 	lds	r19, 0x00AE
     ebc:	8b 81       	ldd	r24, Y+3	; 0x03
     ebe:	9c 81       	ldd	r25, Y+4	; 0x04
     ec0:	82 0f       	add	r24, r18
     ec2:	93 1f       	adc	r25, r19
     ec4:	90 93 ae 00 	sts	0x00AE, r25
     ec8:	80 93 ad 00 	sts	0x00AD, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     ecc:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     ed0:	89 81       	ldd	r24, Y+1	; 0x01
     ed2:	9a 81       	ldd	r25, Y+2	; 0x02
}
     ed4:	0f 90       	pop	r0
     ed6:	0f 90       	pop	r0
     ed8:	0f 90       	pop	r0
     eda:	0f 90       	pop	r0
     edc:	cf 91       	pop	r28
     ede:	df 91       	pop	r29
     ee0:	08 95       	ret

00000ee2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     ee2:	df 93       	push	r29
     ee4:	cf 93       	push	r28
     ee6:	00 d0       	rcall	.+0      	; 0xee8 <vPortFree+0x6>
     ee8:	cd b7       	in	r28, 0x3d	; 61
     eea:	de b7       	in	r29, 0x3e	; 62
     eec:	9a 83       	std	Y+2, r25	; 0x02
     eee:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     ef0:	0f 90       	pop	r0
     ef2:	0f 90       	pop	r0
     ef4:	cf 91       	pop	r28
     ef6:	df 91       	pop	r29
     ef8:	08 95       	ret

00000efa <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     efa:	df 93       	push	r29
     efc:	cf 93       	push	r28
     efe:	cd b7       	in	r28, 0x3d	; 61
     f00:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     f02:	10 92 ae 00 	sts	0x00AE, r1
     f06:	10 92 ad 00 	sts	0x00AD, r1
}
     f0a:	cf 91       	pop	r28
     f0c:	df 91       	pop	r29
     f0e:	08 95       	ret

00000f10 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     f10:	df 93       	push	r29
     f12:	cf 93       	push	r28
     f14:	cd b7       	in	r28, 0x3d	; 61
     f16:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     f18:	20 91 ad 00 	lds	r18, 0x00AD
     f1c:	30 91 ae 00 	lds	r19, 0x00AE
     f20:	8b ed       	ldi	r24, 0xDB	; 219
     f22:	95 e0       	ldi	r25, 0x05	; 5
     f24:	82 1b       	sub	r24, r18
     f26:	93 0b       	sbc	r25, r19
}
     f28:	cf 91       	pop	r28
     f2a:	df 91       	pop	r29
     f2c:	08 95       	ret

00000f2e <KeyPad_Init>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void KeyPad_Init(void)
{
     f2e:	df 93       	push	r29
     f30:	cf 93       	push	r28
     f32:	cd b7       	in	r28, 0x3d	; 61
     f34:	de b7       	in	r29, 0x3e	; 62
	/*set Pins Of KeyPad*/
	DIO_SetPinDirection(DIO_PIN18,INPUT);
     f36:	82 e1       	ldi	r24, 0x12	; 18
     f38:	60 e0       	ldi	r22, 0x00	; 0
     f3a:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN19,INPUT);
     f3e:	83 e1       	ldi	r24, 0x13	; 19
     f40:	60 e0       	ldi	r22, 0x00	; 0
     f42:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN20,INPUT);
     f46:	84 e1       	ldi	r24, 0x14	; 20
     f48:	60 e0       	ldi	r22, 0x00	; 0
     f4a:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN21,OUTPUT);
     f4e:	85 e1       	ldi	r24, 0x15	; 21
     f50:	61 e0       	ldi	r22, 0x01	; 1
     f52:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN22,OUTPUT);
     f56:	86 e1       	ldi	r24, 0x16	; 22
     f58:	61 e0       	ldi	r22, 0x01	; 1
     f5a:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_SetPinDirection(DIO_PIN23,OUTPUT);
     f5e:	87 e1       	ldi	r24, 0x17	; 23
     f60:	61 e0       	ldi	r22, 0x01	; 1
     f62:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>
	DIO_WritePin(DIO_PIN18,HIGH);
     f66:	82 e1       	ldi	r24, 0x12	; 18
     f68:	61 e0       	ldi	r22, 0x01	; 1
     f6a:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN19,HIGH);
     f6e:	83 e1       	ldi	r24, 0x13	; 19
     f70:	61 e0       	ldi	r22, 0x01	; 1
     f72:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN20,HIGH);
     f76:	84 e1       	ldi	r24, 0x14	; 20
     f78:	61 e0       	ldi	r22, 0x01	; 1
     f7a:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN21,LOW);
     f7e:	85 e1       	ldi	r24, 0x15	; 21
     f80:	60 e0       	ldi	r22, 0x00	; 0
     f82:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN22,LOW);
     f86:	86 e1       	ldi	r24, 0x16	; 22
     f88:	60 e0       	ldi	r22, 0x00	; 0
     f8a:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
	DIO_WritePin(DIO_PIN23,LOW);
     f8e:	87 e1       	ldi	r24, 0x17	; 23
     f90:	60 e0       	ldi	r22, 0x00	; 0
     f92:	0e 94 49 00 	call	0x92	; 0x92 <DIO_WritePin>
}
     f96:	cf 91       	pop	r28
     f98:	df 91       	pop	r29
     f9a:	08 95       	ret

00000f9c <KeyPad_getPressedKey>:
 * Outputs:			NULL
 *
 * Return:			pressed key (uint8)
 *******************************************************************************/
uint8 KeyPad_getPressedKey(void)
{
     f9c:	df 93       	push	r29
     f9e:	cf 93       	push	r28
     fa0:	00 d0       	rcall	.+0      	; 0xfa2 <KeyPad_getPressedKey+0x6>
     fa2:	00 d0       	rcall	.+0      	; 0xfa4 <KeyPad_getPressedKey+0x8>
     fa4:	cd b7       	in	r28, 0x3d	; 61
     fa6:	de b7       	in	r29, 0x3e	; 62
	/*return value*/
	uint8 ReturnVal=10;
     fa8:	8a e0       	ldi	r24, 0x0A	; 10
     faa:	8b 83       	std	Y+3, r24	; 0x03

	/*variables use to loop pn rows and column*/
	uint8 row,col;

	/*Loop to check if Key is pressed to return its value*/
	for(col=0;col<N_COL;col++)
     fac:	19 82       	std	Y+1, r1	; 0x01
     fae:	42 c0       	rjmp	.+132    	; 0x1034 <KeyPad_getPressedKey+0x98>
	{
		KEYPAD_PORT_DIR = (0b00100000<<col);
     fb0:	e4 e3       	ldi	r30, 0x34	; 52
     fb2:	f0 e0       	ldi	r31, 0x00	; 0
     fb4:	89 81       	ldd	r24, Y+1	; 0x01
     fb6:	28 2f       	mov	r18, r24
     fb8:	30 e0       	ldi	r19, 0x00	; 0
     fba:	80 e2       	ldi	r24, 0x20	; 32
     fbc:	90 e0       	ldi	r25, 0x00	; 0
     fbe:	02 c0       	rjmp	.+4      	; 0xfc4 <KeyPad_getPressedKey+0x28>
     fc0:	88 0f       	add	r24, r24
     fc2:	99 1f       	adc	r25, r25
     fc4:	2a 95       	dec	r18
     fc6:	e2 f7       	brpl	.-8      	; 0xfc0 <KeyPad_getPressedKey+0x24>
     fc8:	80 83       	st	Z, r24
		KEYPAD_PORT_OUT = (~(0b00100000<<col));
     fca:	e5 e3       	ldi	r30, 0x35	; 53
     fcc:	f0 e0       	ldi	r31, 0x00	; 0
     fce:	89 81       	ldd	r24, Y+1	; 0x01
     fd0:	28 2f       	mov	r18, r24
     fd2:	30 e0       	ldi	r19, 0x00	; 0
     fd4:	80 e2       	ldi	r24, 0x20	; 32
     fd6:	90 e0       	ldi	r25, 0x00	; 0
     fd8:	02 2e       	mov	r0, r18
     fda:	02 c0       	rjmp	.+4      	; 0xfe0 <KeyPad_getPressedKey+0x44>
     fdc:	88 0f       	add	r24, r24
     fde:	99 1f       	adc	r25, r25
     fe0:	0a 94       	dec	r0
     fe2:	e2 f7       	brpl	.-8      	; 0xfdc <KeyPad_getPressedKey+0x40>
     fe4:	80 95       	com	r24
     fe6:	80 83       	st	Z, r24

		for(row=START_ROW;row<END_ROW;row++)
     fe8:	82 e0       	ldi	r24, 0x02	; 2
     fea:	8a 83       	std	Y+2, r24	; 0x02
     fec:	1d c0       	rjmp	.+58     	; 0x1028 <KeyPad_getPressedKey+0x8c>
		{
			if(GET_BIT(KEYPAD_PORT_IN,row) == 0)
     fee:	e3 e3       	ldi	r30, 0x33	; 51
     ff0:	f0 e0       	ldi	r31, 0x00	; 0
     ff2:	80 81       	ld	r24, Z
     ff4:	28 2f       	mov	r18, r24
     ff6:	30 e0       	ldi	r19, 0x00	; 0
     ff8:	8a 81       	ldd	r24, Y+2	; 0x02
     ffa:	88 2f       	mov	r24, r24
     ffc:	90 e0       	ldi	r25, 0x00	; 0
     ffe:	a9 01       	movw	r20, r18
    1000:	02 c0       	rjmp	.+4      	; 0x1006 <KeyPad_getPressedKey+0x6a>
    1002:	55 95       	asr	r21
    1004:	47 95       	ror	r20
    1006:	8a 95       	dec	r24
    1008:	e2 f7       	brpl	.-8      	; 0x1002 <KeyPad_getPressedKey+0x66>
    100a:	ca 01       	movw	r24, r20
    100c:	81 70       	andi	r24, 0x01	; 1
    100e:	90 70       	andi	r25, 0x00	; 0
    1010:	00 97       	sbiw	r24, 0x00	; 0
    1012:	39 f4       	brne	.+14     	; 0x1022 <KeyPad_getPressedKey+0x86>
				/*check on Configurations Mode*/
#if(N_COL ==3)
#if(N_ROW == 3)

				/*return value of pressed Key*/
				return  KeyPad_3x3_switch(row-START_ROW,col);
    1014:	8a 81       	ldd	r24, Y+2	; 0x02
    1016:	82 50       	subi	r24, 0x02	; 2
    1018:	69 81       	ldd	r22, Y+1	; 0x01
    101a:	0e 94 28 08 	call	0x1050	; 0x1050 <KeyPad_3x3_switch>
    101e:	8c 83       	std	Y+4, r24	; 0x04
    1020:	0f c0       	rjmp	.+30     	; 0x1040 <KeyPad_getPressedKey+0xa4>
	for(col=0;col<N_COL;col++)
	{
		KEYPAD_PORT_DIR = (0b00100000<<col);
		KEYPAD_PORT_OUT = (~(0b00100000<<col));

		for(row=START_ROW;row<END_ROW;row++)
    1022:	8a 81       	ldd	r24, Y+2	; 0x02
    1024:	8f 5f       	subi	r24, 0xFF	; 255
    1026:	8a 83       	std	Y+2, r24	; 0x02
    1028:	8a 81       	ldd	r24, Y+2	; 0x02
    102a:	85 30       	cpi	r24, 0x05	; 5
    102c:	00 f3       	brcs	.-64     	; 0xfee <KeyPad_getPressedKey+0x52>

	/*variables use to loop pn rows and column*/
	uint8 row,col;

	/*Loop to check if Key is pressed to return its value*/
	for(col=0;col<N_COL;col++)
    102e:	89 81       	ldd	r24, Y+1	; 0x01
    1030:	8f 5f       	subi	r24, 0xFF	; 255
    1032:	89 83       	std	Y+1, r24	; 0x01
    1034:	89 81       	ldd	r24, Y+1	; 0x01
    1036:	83 30       	cpi	r24, 0x03	; 3
    1038:	08 f4       	brcc	.+2      	; 0x103c <KeyPad_getPressedKey+0xa0>
    103a:	ba cf       	rjmp	.-140    	; 0xfb0 <KeyPad_getPressedKey+0x14>
				return KeyPad_4x4_switch(row-START_ROW,col);
#endif
			}
		}
	}
	return ReturnVal;
    103c:	5b 81       	ldd	r21, Y+3	; 0x03
    103e:	5c 83       	std	Y+4, r21	; 0x04
    1040:	8c 81       	ldd	r24, Y+4	; 0x04
}
    1042:	0f 90       	pop	r0
    1044:	0f 90       	pop	r0
    1046:	0f 90       	pop	r0
    1048:	0f 90       	pop	r0
    104a:	cf 91       	pop	r28
    104c:	df 91       	pop	r29
    104e:	08 95       	ret

00001050 <KeyPad_3x3_switch>:
 * Outputs:			NULL
 *
 * Return:			value of Pressed Key (uint8)
 *******************************************************************************/
static uint8 KeyPad_3x3_switch(uint8 row, uint8 col)
{
    1050:	df 93       	push	r29
    1052:	cf 93       	push	r28
    1054:	cd b7       	in	r28, 0x3d	; 61
    1056:	de b7       	in	r29, 0x3e	; 62
    1058:	2b 97       	sbiw	r28, 0x0b	; 11
    105a:	0f b6       	in	r0, 0x3f	; 63
    105c:	f8 94       	cli
    105e:	de bf       	out	0x3e, r29	; 62
    1060:	0f be       	out	0x3f, r0	; 63
    1062:	cd bf       	out	0x3d, r28	; 61
    1064:	8a 83       	std	Y+2, r24	; 0x02
    1066:	6b 83       	std	Y+3, r22	; 0x03
	/*variable of return value*/
	uint8 ReturnVal = 0;
    1068:	19 82       	std	Y+1, r1	; 0x01

	/*determine row of pressed key*/
	switch(row)
    106a:	8a 81       	ldd	r24, Y+2	; 0x02
    106c:	28 2f       	mov	r18, r24
    106e:	30 e0       	ldi	r19, 0x00	; 0
    1070:	3b 87       	std	Y+11, r19	; 0x0b
    1072:	2a 87       	std	Y+10, r18	; 0x0a
    1074:	8a 85       	ldd	r24, Y+10	; 0x0a
    1076:	9b 85       	ldd	r25, Y+11	; 0x0b
    1078:	81 30       	cpi	r24, 0x01	; 1
    107a:	91 05       	cpc	r25, r1
    107c:	41 f1       	breq	.+80     	; 0x10ce <KeyPad_3x3_switch+0x7e>
    107e:	2a 85       	ldd	r18, Y+10	; 0x0a
    1080:	3b 85       	ldd	r19, Y+11	; 0x0b
    1082:	22 30       	cpi	r18, 0x02	; 2
    1084:	31 05       	cpc	r19, r1
    1086:	09 f4       	brne	.+2      	; 0x108a <KeyPad_3x3_switch+0x3a>
    1088:	3e c0       	rjmp	.+124    	; 0x1106 <KeyPad_3x3_switch+0xb6>
    108a:	8a 85       	ldd	r24, Y+10	; 0x0a
    108c:	9b 85       	ldd	r25, Y+11	; 0x0b
    108e:	00 97       	sbiw	r24, 0x00	; 0
    1090:	09 f0       	breq	.+2      	; 0x1094 <KeyPad_3x3_switch+0x44>
    1092:	54 c0       	rjmp	.+168    	; 0x113c <KeyPad_3x3_switch+0xec>
	{
	case 0:
		/*determine column of pressed key*/
		switch(col)
    1094:	8b 81       	ldd	r24, Y+3	; 0x03
    1096:	28 2f       	mov	r18, r24
    1098:	30 e0       	ldi	r19, 0x00	; 0
    109a:	39 87       	std	Y+9, r19	; 0x09
    109c:	28 87       	std	Y+8, r18	; 0x08
    109e:	88 85       	ldd	r24, Y+8	; 0x08
    10a0:	99 85       	ldd	r25, Y+9	; 0x09
    10a2:	81 30       	cpi	r24, 0x01	; 1
    10a4:	91 05       	cpc	r25, r1
    10a6:	69 f0       	breq	.+26     	; 0x10c2 <KeyPad_3x3_switch+0x72>
    10a8:	28 85       	ldd	r18, Y+8	; 0x08
    10aa:	39 85       	ldd	r19, Y+9	; 0x09
    10ac:	22 30       	cpi	r18, 0x02	; 2
    10ae:	31 05       	cpc	r19, r1
    10b0:	59 f0       	breq	.+22     	; 0x10c8 <KeyPad_3x3_switch+0x78>
    10b2:	88 85       	ldd	r24, Y+8	; 0x08
    10b4:	99 85       	ldd	r25, Y+9	; 0x09
    10b6:	00 97       	sbiw	r24, 0x00	; 0
    10b8:	09 f0       	breq	.+2      	; 0x10bc <KeyPad_3x3_switch+0x6c>
    10ba:	40 c0       	rjmp	.+128    	; 0x113c <KeyPad_3x3_switch+0xec>
		{
		case 0: ReturnVal = R1C1;
    10bc:	81 e0       	ldi	r24, 0x01	; 1
    10be:	89 83       	std	Y+1, r24	; 0x01
    10c0:	3d c0       	rjmp	.+122    	; 0x113c <KeyPad_3x3_switch+0xec>
			break;
		case 1: ReturnVal = R1C2;
    10c2:	82 e0       	ldi	r24, 0x02	; 2
    10c4:	89 83       	std	Y+1, r24	; 0x01
    10c6:	3a c0       	rjmp	.+116    	; 0x113c <KeyPad_3x3_switch+0xec>
			break;
		case 2: ReturnVal = R1C3;
    10c8:	83 e0       	ldi	r24, 0x03	; 3
    10ca:	89 83       	std	Y+1, r24	; 0x01
    10cc:	37 c0       	rjmp	.+110    	; 0x113c <KeyPad_3x3_switch+0xec>
		}
		break;

	case 1:
		/*determine column of pressed key*/
		switch(col)
    10ce:	8b 81       	ldd	r24, Y+3	; 0x03
    10d0:	28 2f       	mov	r18, r24
    10d2:	30 e0       	ldi	r19, 0x00	; 0
    10d4:	3f 83       	std	Y+7, r19	; 0x07
    10d6:	2e 83       	std	Y+6, r18	; 0x06
    10d8:	8e 81       	ldd	r24, Y+6	; 0x06
    10da:	9f 81       	ldd	r25, Y+7	; 0x07
    10dc:	81 30       	cpi	r24, 0x01	; 1
    10de:	91 05       	cpc	r25, r1
    10e0:	61 f0       	breq	.+24     	; 0x10fa <KeyPad_3x3_switch+0xaa>
    10e2:	2e 81       	ldd	r18, Y+6	; 0x06
    10e4:	3f 81       	ldd	r19, Y+7	; 0x07
    10e6:	22 30       	cpi	r18, 0x02	; 2
    10e8:	31 05       	cpc	r19, r1
    10ea:	51 f0       	breq	.+20     	; 0x1100 <KeyPad_3x3_switch+0xb0>
    10ec:	8e 81       	ldd	r24, Y+6	; 0x06
    10ee:	9f 81       	ldd	r25, Y+7	; 0x07
    10f0:	00 97       	sbiw	r24, 0x00	; 0
    10f2:	21 f5       	brne	.+72     	; 0x113c <KeyPad_3x3_switch+0xec>
		{
		case 0: ReturnVal = R2C1;
    10f4:	84 e0       	ldi	r24, 0x04	; 4
    10f6:	89 83       	std	Y+1, r24	; 0x01
    10f8:	21 c0       	rjmp	.+66     	; 0x113c <KeyPad_3x3_switch+0xec>
			break;
		case 1: ReturnVal = R2C2;
    10fa:	85 e0       	ldi	r24, 0x05	; 5
    10fc:	89 83       	std	Y+1, r24	; 0x01
    10fe:	1e c0       	rjmp	.+60     	; 0x113c <KeyPad_3x3_switch+0xec>
			break;
		case 2: ReturnVal = R2C3;
    1100:	86 e0       	ldi	r24, 0x06	; 6
    1102:	89 83       	std	Y+1, r24	; 0x01
    1104:	1b c0       	rjmp	.+54     	; 0x113c <KeyPad_3x3_switch+0xec>
			break;
		}
			break;
	case 2:
		/*determine column of pressed key*/
		switch(col)
    1106:	8b 81       	ldd	r24, Y+3	; 0x03
    1108:	28 2f       	mov	r18, r24
    110a:	30 e0       	ldi	r19, 0x00	; 0
    110c:	3d 83       	std	Y+5, r19	; 0x05
    110e:	2c 83       	std	Y+4, r18	; 0x04
    1110:	8c 81       	ldd	r24, Y+4	; 0x04
    1112:	9d 81       	ldd	r25, Y+5	; 0x05
    1114:	81 30       	cpi	r24, 0x01	; 1
    1116:	91 05       	cpc	r25, r1
    1118:	61 f0       	breq	.+24     	; 0x1132 <KeyPad_3x3_switch+0xe2>
    111a:	2c 81       	ldd	r18, Y+4	; 0x04
    111c:	3d 81       	ldd	r19, Y+5	; 0x05
    111e:	22 30       	cpi	r18, 0x02	; 2
    1120:	31 05       	cpc	r19, r1
    1122:	51 f0       	breq	.+20     	; 0x1138 <KeyPad_3x3_switch+0xe8>
    1124:	8c 81       	ldd	r24, Y+4	; 0x04
    1126:	9d 81       	ldd	r25, Y+5	; 0x05
    1128:	00 97       	sbiw	r24, 0x00	; 0
    112a:	41 f4       	brne	.+16     	; 0x113c <KeyPad_3x3_switch+0xec>
		{
		case 0: ReturnVal = R3C1;
    112c:	87 e0       	ldi	r24, 0x07	; 7
    112e:	89 83       	std	Y+1, r24	; 0x01
    1130:	05 c0       	rjmp	.+10     	; 0x113c <KeyPad_3x3_switch+0xec>
			break;
		case 1: ReturnVal = R3C2;
    1132:	88 e0       	ldi	r24, 0x08	; 8
    1134:	89 83       	std	Y+1, r24	; 0x01
    1136:	02 c0       	rjmp	.+4      	; 0x113c <KeyPad_3x3_switch+0xec>
			break;
		case 2: ReturnVal = R3C3;
    1138:	89 e0       	ldi	r24, 0x09	; 9
    113a:	89 83       	std	Y+1, r24	; 0x01
		}
		break;
	}

	/*return value of pressed key*/
	return ReturnVal;
    113c:	89 81       	ldd	r24, Y+1	; 0x01
}
    113e:	2b 96       	adiw	r28, 0x0b	; 11
    1140:	0f b6       	in	r0, 0x3f	; 63
    1142:	f8 94       	cli
    1144:	de bf       	out	0x3e, r29	; 62
    1146:	0f be       	out	0x3f, r0	; 63
    1148:	cd bf       	out	0x3d, r28	; 61
    114a:	cf 91       	pop	r28
    114c:	df 91       	pop	r29
    114e:	08 95       	ret

00001150 <LCD_init>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_init(void)
{
    1150:	df 93       	push	r29
    1152:	cf 93       	push	r28
    1154:	cd b7       	in	r28, 0x3d	; 61
    1156:	de b7       	in	r29, 0x3e	; 62

	LCD_CTRL_PORT_DIR |= (1<<E) | (1<<RS) | (1<<RW); /* Configure the control pins(E,RS,RW) as output pins */
    1158:	aa e3       	ldi	r26, 0x3A	; 58
    115a:	b0 e0       	ldi	r27, 0x00	; 0
    115c:	ea e3       	ldi	r30, 0x3A	; 58
    115e:	f0 e0       	ldi	r31, 0x00	; 0
    1160:	80 81       	ld	r24, Z
    1162:	8e 60       	ori	r24, 0x0E	; 14
    1164:	8c 93       	st	X, r24

#if (DATA_BITS_MODE == 4)
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT_DIR |= 0xF0; /* Configure the highest 4 bits of the data port as output pins */
    1166:	aa e3       	ldi	r26, 0x3A	; 58
    1168:	b0 e0       	ldi	r27, 0x00	; 0
    116a:	ea e3       	ldi	r30, 0x3A	; 58
    116c:	f0 e0       	ldi	r31, 0x00	; 0
    116e:	80 81       	ld	r24, Z
    1170:	80 6f       	ori	r24, 0xF0	; 240
    1172:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT_DIR |= 0x0F; /* Configure the lowest 4 bits of the data port as output pins */
#endif

	LCD_sendCommand(FOUR_BITS_DATA_MODE); /* initialize LCD in 4-bit mode */
    1174:	82 e0       	ldi	r24, 0x02	; 2
    1176:	0e 94 c9 08 	call	0x1192	; 0x1192 <LCD_sendCommand>

	LCD_sendCommand(TWO_LINE_LCD_Four_BIT_MODE); /* use 2-line lcd + 4-bit Data Mode + 5*7 dot display Mode */
    117a:	88 e2       	ldi	r24, 0x28	; 40
    117c:	0e 94 c9 08 	call	0x1192	; 0x1192 <LCD_sendCommand>
#elif (DATA_BITS_MODE == 8)
	LCD_DATA_PORT_DIR = 0xFF; /* Configure the data port as output port */
	LCD_sendCommand(TWO_LINE_LCD_Eight_BIT_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
#endif

	LCD_sendCommand(CURSOR_OFF); /* cursor off */
    1180:	8c e0       	ldi	r24, 0x0C	; 12
    1182:	0e 94 c9 08 	call	0x1192	; 0x1192 <LCD_sendCommand>
	LCD_sendCommand(CLEAR_COMMAND); /* clear LCD at the beginning */
    1186:	81 e0       	ldi	r24, 0x01	; 1
    1188:	0e 94 c9 08 	call	0x1192	; 0x1192 <LCD_sendCommand>

}
    118c:	cf 91       	pop	r28
    118e:	df 91       	pop	r29
    1190:	08 95       	ret

00001192 <LCD_sendCommand>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_sendCommand(uint8 command)
{
    1192:	df 93       	push	r29
    1194:	cf 93       	push	r28
    1196:	0f 92       	push	r0
    1198:	cd b7       	in	r28, 0x3d	; 61
    119a:	de b7       	in	r29, 0x3e	; 62
    119c:	89 83       	std	Y+1, r24	; 0x01
	CLEAR_BIT(LCD_CTRL_PORT,RS); /* Instruction Mode RS=0 */
    119e:	ab e3       	ldi	r26, 0x3B	; 59
    11a0:	b0 e0       	ldi	r27, 0x00	; 0
    11a2:	eb e3       	ldi	r30, 0x3B	; 59
    11a4:	f0 e0       	ldi	r31, 0x00	; 0
    11a6:	80 81       	ld	r24, Z
    11a8:	8d 7f       	andi	r24, 0xFD	; 253
    11aa:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    11ac:	ab e3       	ldi	r26, 0x3B	; 59
    11ae:	b0 e0       	ldi	r27, 0x00	; 0
    11b0:	eb e3       	ldi	r30, 0x3B	; 59
    11b2:	f0 e0       	ldi	r31, 0x00	; 0
    11b4:	80 81       	ld	r24, Z
    11b6:	8b 7f       	andi	r24, 0xFB	; 251
    11b8:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    11ba:	81 e0       	ldi	r24, 0x01	; 1
    11bc:	90 e0       	ldi	r25, 0x00	; 0
    11be:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    11c2:	ab e3       	ldi	r26, 0x3B	; 59
    11c4:	b0 e0       	ldi	r27, 0x00	; 0
    11c6:	eb e3       	ldi	r30, 0x3B	; 59
    11c8:	f0 e0       	ldi	r31, 0x00	; 0
    11ca:	80 81       	ld	r24, Z
    11cc:	88 60       	ori	r24, 0x08	; 8
    11ce:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    11d0:	81 e0       	ldi	r24, 0x01	; 1
    11d2:	90 e0       	ldi	r25, 0x00	; 0
    11d4:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (command & 0xF0);
    11d8:	ab e3       	ldi	r26, 0x3B	; 59
    11da:	b0 e0       	ldi	r27, 0x00	; 0
    11dc:	eb e3       	ldi	r30, 0x3B	; 59
    11de:	f0 e0       	ldi	r31, 0x00	; 0
    11e0:	80 81       	ld	r24, Z
    11e2:	98 2f       	mov	r25, r24
    11e4:	9f 70       	andi	r25, 0x0F	; 15
    11e6:	89 81       	ldd	r24, Y+1	; 0x01
    11e8:	80 7f       	andi	r24, 0xF0	; 240
    11ea:	89 2b       	or	r24, r25
    11ec:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((command & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    11ee:	81 e0       	ldi	r24, 0x01	; 1
    11f0:	90 e0       	ldi	r25, 0x00	; 0
    11f2:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    11f6:	ab e3       	ldi	r26, 0x3B	; 59
    11f8:	b0 e0       	ldi	r27, 0x00	; 0
    11fa:	eb e3       	ldi	r30, 0x3B	; 59
    11fc:	f0 e0       	ldi	r31, 0x00	; 0
    11fe:	80 81       	ld	r24, Z
    1200:	87 7f       	andi	r24, 0xF7	; 247
    1202:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1204:	81 e0       	ldi	r24, 0x01	; 1
    1206:	90 e0       	ldi	r25, 0x00	; 0
    1208:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    120c:	ab e3       	ldi	r26, 0x3B	; 59
    120e:	b0 e0       	ldi	r27, 0x00	; 0
    1210:	eb e3       	ldi	r30, 0x3B	; 59
    1212:	f0 e0       	ldi	r31, 0x00	; 0
    1214:	80 81       	ld	r24, Z
    1216:	88 60       	ori	r24, 0x08	; 8
    1218:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    121a:	81 e0       	ldi	r24, 0x01	; 1
    121c:	90 e0       	ldi	r25, 0x00	; 0
    121e:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>

	/* out the lowest 4 bits of the required command to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((command & 0x0F) << 4);
    1222:	ab e3       	ldi	r26, 0x3B	; 59
    1224:	b0 e0       	ldi	r27, 0x00	; 0
    1226:	eb e3       	ldi	r30, 0x3B	; 59
    1228:	f0 e0       	ldi	r31, 0x00	; 0
    122a:	80 81       	ld	r24, Z
    122c:	28 2f       	mov	r18, r24
    122e:	2f 70       	andi	r18, 0x0F	; 15
    1230:	89 81       	ldd	r24, Y+1	; 0x01
    1232:	88 2f       	mov	r24, r24
    1234:	90 e0       	ldi	r25, 0x00	; 0
    1236:	82 95       	swap	r24
    1238:	92 95       	swap	r25
    123a:	90 7f       	andi	r25, 0xF0	; 240
    123c:	98 27       	eor	r25, r24
    123e:	80 7f       	andi	r24, 0xF0	; 240
    1240:	98 27       	eor	r25, r24
    1242:	82 2b       	or	r24, r18
    1244:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (command & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1246:	81 e0       	ldi	r24, 0x01	; 1
    1248:	90 e0       	ldi	r25, 0x00	; 0
    124a:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    124e:	ab e3       	ldi	r26, 0x3B	; 59
    1250:	b0 e0       	ldi	r27, 0x00	; 0
    1252:	eb e3       	ldi	r30, 0x3B	; 59
    1254:	f0 e0       	ldi	r31, 0x00	; 0
    1256:	80 81       	ld	r24, Z
    1258:	87 7f       	andi	r24, 0xF7	; 247
    125a:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    125c:	81 e0       	ldi	r24, 0x01	; 1
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    1264:	0f 90       	pop	r0
    1266:	cf 91       	pop	r28
    1268:	df 91       	pop	r29
    126a:	08 95       	ret

0000126c <LCD_displayCharacter>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayCharacter(uint8 data)
{
    126c:	df 93       	push	r29
    126e:	cf 93       	push	r28
    1270:	0f 92       	push	r0
    1272:	cd b7       	in	r28, 0x3d	; 61
    1274:	de b7       	in	r29, 0x3e	; 62
    1276:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(LCD_CTRL_PORT,RS); /* Data Mode RS=1 */
    1278:	ab e3       	ldi	r26, 0x3B	; 59
    127a:	b0 e0       	ldi	r27, 0x00	; 0
    127c:	eb e3       	ldi	r30, 0x3B	; 59
    127e:	f0 e0       	ldi	r31, 0x00	; 0
    1280:	80 81       	ld	r24, Z
    1282:	82 60       	ori	r24, 0x02	; 2
    1284:	8c 93       	st	X, r24
	CLEAR_BIT(LCD_CTRL_PORT,RW); /* write data to LCD so RW=0 */
    1286:	ab e3       	ldi	r26, 0x3B	; 59
    1288:	b0 e0       	ldi	r27, 0x00	; 0
    128a:	eb e3       	ldi	r30, 0x3B	; 59
    128c:	f0 e0       	ldi	r31, 0x00	; 0
    128e:	80 81       	ld	r24, Z
    1290:	8b 7f       	andi	r24, 0xFB	; 251
    1292:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tas = 50ns */
    1294:	81 e0       	ldi	r24, 0x01	; 1
    1296:	90 e0       	ldi	r25, 0x00	; 0
    1298:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    129c:	ab e3       	ldi	r26, 0x3B	; 59
    129e:	b0 e0       	ldi	r27, 0x00	; 0
    12a0:	eb e3       	ldi	r30, 0x3B	; 59
    12a2:	f0 e0       	ldi	r31, 0x00	; 0
    12a4:	80 81       	ld	r24, Z
    12a6:	88 60       	ori	r24, 0x08	; 8
    12a8:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    12aa:	81 e0       	ldi	r24, 0x01	; 1
    12ac:	90 e0       	ldi	r25, 0x00	; 0
    12ae:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
#if (DATA_BITS_MODE == 4)
	/* out the highest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (data & 0xF0);
    12b2:	ab e3       	ldi	r26, 0x3B	; 59
    12b4:	b0 e0       	ldi	r27, 0x00	; 0
    12b6:	eb e3       	ldi	r30, 0x3B	; 59
    12b8:	f0 e0       	ldi	r31, 0x00	; 0
    12ba:	80 81       	ld	r24, Z
    12bc:	98 2f       	mov	r25, r24
    12be:	9f 70       	andi	r25, 0x0F	; 15
    12c0:	89 81       	ldd	r24, Y+1	; 0x01
    12c2:	80 7f       	andi	r24, 0xF0	; 240
    12c4:	89 2b       	or	r24, r25
    12c6:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | ((data & 0xF0) >> 4);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    12c8:	81 e0       	ldi	r24, 0x01	; 1
    12ca:	90 e0       	ldi	r25, 0x00	; 0
    12cc:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    12d0:	ab e3       	ldi	r26, 0x3B	; 59
    12d2:	b0 e0       	ldi	r27, 0x00	; 0
    12d4:	eb e3       	ldi	r30, 0x3B	; 59
    12d6:	f0 e0       	ldi	r31, 0x00	; 0
    12d8:	80 81       	ld	r24, Z
    12da:	87 7f       	andi	r24, 0xF7	; 247
    12dc:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    12de:	81 e0       	ldi	r24, 0x01	; 1
    12e0:	90 e0       	ldi	r25, 0x00	; 0
    12e2:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
	SET_BIT(LCD_CTRL_PORT,E); /* Enable LCD E=1 */
    12e6:	ab e3       	ldi	r26, 0x3B	; 59
    12e8:	b0 e0       	ldi	r27, 0x00	; 0
    12ea:	eb e3       	ldi	r30, 0x3B	; 59
    12ec:	f0 e0       	ldi	r31, 0x00	; 0
    12ee:	80 81       	ld	r24, Z
    12f0:	88 60       	ori	r24, 0x08	; 8
    12f2:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Tpw - Tdws = 190ns */
    12f4:	81 e0       	ldi	r24, 0x01	; 1
    12f6:	90 e0       	ldi	r25, 0x00	; 0
    12f8:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>

	/* out the lowest 4 bits of the required data to the data bus D4 --> D7 */
#ifdef UPPER_PORT_PINS
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | ((data & 0x0F) << 4);
    12fc:	ab e3       	ldi	r26, 0x3B	; 59
    12fe:	b0 e0       	ldi	r27, 0x00	; 0
    1300:	eb e3       	ldi	r30, 0x3B	; 59
    1302:	f0 e0       	ldi	r31, 0x00	; 0
    1304:	80 81       	ld	r24, Z
    1306:	28 2f       	mov	r18, r24
    1308:	2f 70       	andi	r18, 0x0F	; 15
    130a:	89 81       	ldd	r24, Y+1	; 0x01
    130c:	88 2f       	mov	r24, r24
    130e:	90 e0       	ldi	r25, 0x00	; 0
    1310:	82 95       	swap	r24
    1312:	92 95       	swap	r25
    1314:	90 7f       	andi	r25, 0xF0	; 240
    1316:	98 27       	eor	r25, r24
    1318:	80 7f       	andi	r24, 0xF0	; 240
    131a:	98 27       	eor	r25, r24
    131c:	82 2b       	or	r24, r18
    131e:	8c 93       	st	X, r24
#else
	LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (data & 0x0F);
#endif

	vTaskDelay(1); /* delay for processing Tdsw = 100ns */
    1320:	81 e0       	ldi	r24, 0x01	; 1
    1322:	90 e0       	ldi	r25, 0x00	; 0
    1324:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
    1328:	ab e3       	ldi	r26, 0x3B	; 59
    132a:	b0 e0       	ldi	r27, 0x00	; 0
    132c:	eb e3       	ldi	r30, 0x3B	; 59
    132e:	f0 e0       	ldi	r31, 0x00	; 0
    1330:	80 81       	ld	r24, Z
    1332:	87 7f       	andi	r24, 0xF7	; 247
    1334:	8c 93       	st	X, r24
	vTaskDelay(1); /* delay for processing Th = 13ns */
    1336:	81 e0       	ldi	r24, 0x01	; 1
    1338:	90 e0       	ldi	r25, 0x00	; 0
    133a:	0e 94 2c 1f 	call	0x3e58	; 0x3e58 <vTaskDelay>
	LCD_DATA_PORT = command; /* out the required command to the data bus D0 --> D7 */
	_delay_us(600); /* delay for processing Tdsw = 100ns */
	CLEAR_BIT(LCD_CTRL_PORT,E); /* disable LCD E=0 */
	_delay_us(600); /* delay for processing Th = 13ns */
#endif
}
    133e:	0f 90       	pop	r0
    1340:	cf 91       	pop	r28
    1342:	df 91       	pop	r29
    1344:	08 95       	ret

00001346 <LCD_displayString>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
    1346:	df 93       	push	r29
    1348:	cf 93       	push	r28
    134a:	00 d0       	rcall	.+0      	; 0x134c <LCD_displayString+0x6>
    134c:	0f 92       	push	r0
    134e:	cd b7       	in	r28, 0x3d	; 61
    1350:	de b7       	in	r29, 0x3e	; 62
    1352:	9b 83       	std	Y+3, r25	; 0x03
    1354:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    1356:	19 82       	std	Y+1, r1	; 0x01
    1358:	0e c0       	rjmp	.+28     	; 0x1376 <LCD_displayString+0x30>
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    135a:	89 81       	ldd	r24, Y+1	; 0x01
    135c:	28 2f       	mov	r18, r24
    135e:	30 e0       	ldi	r19, 0x00	; 0
    1360:	8a 81       	ldd	r24, Y+2	; 0x02
    1362:	9b 81       	ldd	r25, Y+3	; 0x03
    1364:	fc 01       	movw	r30, r24
    1366:	e2 0f       	add	r30, r18
    1368:	f3 1f       	adc	r31, r19
    136a:	80 81       	ld	r24, Z
    136c:	0e 94 36 09 	call	0x126c	; 0x126c <LCD_displayCharacter>
		i++;
    1370:	89 81       	ldd	r24, Y+1	; 0x01
    1372:	8f 5f       	subi	r24, 0xFF	; 255
    1374:	89 83       	std	Y+1, r24	; 0x01
 *******************************************************************************/
void LCD_displayString(const uint8 *Str)
{
	uint8 i = 0;
	/*use loop to send string byte by byte to display on LCD*/
	while(Str[i] != '\0')
    1376:	89 81       	ldd	r24, Y+1	; 0x01
    1378:	28 2f       	mov	r18, r24
    137a:	30 e0       	ldi	r19, 0x00	; 0
    137c:	8a 81       	ldd	r24, Y+2	; 0x02
    137e:	9b 81       	ldd	r25, Y+3	; 0x03
    1380:	fc 01       	movw	r30, r24
    1382:	e2 0f       	add	r30, r18
    1384:	f3 1f       	adc	r31, r19
    1386:	80 81       	ld	r24, Z
    1388:	88 23       	and	r24, r24
    138a:	39 f7       	brne	.-50     	; 0x135a <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	 *********************************************************/
}
    138c:	0f 90       	pop	r0
    138e:	0f 90       	pop	r0
    1390:	0f 90       	pop	r0
    1392:	cf 91       	pop	r28
    1394:	df 91       	pop	r29
    1396:	08 95       	ret

00001398 <LCD_goToRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_goToRowColumn(uint8 row,uint8 col)
{
    1398:	df 93       	push	r29
    139a:	cf 93       	push	r28
    139c:	00 d0       	rcall	.+0      	; 0x139e <LCD_goToRowColumn+0x6>
    139e:	00 d0       	rcall	.+0      	; 0x13a0 <LCD_goToRowColumn+0x8>
    13a0:	0f 92       	push	r0
    13a2:	cd b7       	in	r28, 0x3d	; 61
    13a4:	de b7       	in	r29, 0x3e	; 62
    13a6:	8a 83       	std	Y+2, r24	; 0x02
    13a8:	6b 83       	std	Y+3, r22	; 0x03
	uint8 Address;

	/* first of all calculate the required address */
	switch(row)
    13aa:	8a 81       	ldd	r24, Y+2	; 0x02
    13ac:	28 2f       	mov	r18, r24
    13ae:	30 e0       	ldi	r19, 0x00	; 0
    13b0:	3d 83       	std	Y+5, r19	; 0x05
    13b2:	2c 83       	std	Y+4, r18	; 0x04
    13b4:	8c 81       	ldd	r24, Y+4	; 0x04
    13b6:	9d 81       	ldd	r25, Y+5	; 0x05
    13b8:	81 30       	cpi	r24, 0x01	; 1
    13ba:	91 05       	cpc	r25, r1
    13bc:	c1 f0       	breq	.+48     	; 0x13ee <LCD_goToRowColumn+0x56>
    13be:	2c 81       	ldd	r18, Y+4	; 0x04
    13c0:	3d 81       	ldd	r19, Y+5	; 0x05
    13c2:	22 30       	cpi	r18, 0x02	; 2
    13c4:	31 05       	cpc	r19, r1
    13c6:	2c f4       	brge	.+10     	; 0x13d2 <LCD_goToRowColumn+0x3a>
    13c8:	8c 81       	ldd	r24, Y+4	; 0x04
    13ca:	9d 81       	ldd	r25, Y+5	; 0x05
    13cc:	00 97       	sbiw	r24, 0x00	; 0
    13ce:	61 f0       	breq	.+24     	; 0x13e8 <LCD_goToRowColumn+0x50>
    13d0:	19 c0       	rjmp	.+50     	; 0x1404 <LCD_goToRowColumn+0x6c>
    13d2:	2c 81       	ldd	r18, Y+4	; 0x04
    13d4:	3d 81       	ldd	r19, Y+5	; 0x05
    13d6:	22 30       	cpi	r18, 0x02	; 2
    13d8:	31 05       	cpc	r19, r1
    13da:	69 f0       	breq	.+26     	; 0x13f6 <LCD_goToRowColumn+0x5e>
    13dc:	8c 81       	ldd	r24, Y+4	; 0x04
    13de:	9d 81       	ldd	r25, Y+5	; 0x05
    13e0:	83 30       	cpi	r24, 0x03	; 3
    13e2:	91 05       	cpc	r25, r1
    13e4:	61 f0       	breq	.+24     	; 0x13fe <LCD_goToRowColumn+0x66>
    13e6:	0e c0       	rjmp	.+28     	; 0x1404 <LCD_goToRowColumn+0x6c>
	{
	case 0:
		Address=col;
    13e8:	8b 81       	ldd	r24, Y+3	; 0x03
    13ea:	89 83       	std	Y+1, r24	; 0x01
    13ec:	0b c0       	rjmp	.+22     	; 0x1404 <LCD_goToRowColumn+0x6c>
		break;
	case 1:
		Address=col+0x40;
    13ee:	8b 81       	ldd	r24, Y+3	; 0x03
    13f0:	80 5c       	subi	r24, 0xC0	; 192
    13f2:	89 83       	std	Y+1, r24	; 0x01
    13f4:	07 c0       	rjmp	.+14     	; 0x1404 <LCD_goToRowColumn+0x6c>
		break;
	case 2:
		Address=col+0x10;
    13f6:	8b 81       	ldd	r24, Y+3	; 0x03
    13f8:	80 5f       	subi	r24, 0xF0	; 240
    13fa:	89 83       	std	Y+1, r24	; 0x01
    13fc:	03 c0       	rjmp	.+6      	; 0x1404 <LCD_goToRowColumn+0x6c>
		break;
	case 3:
		Address=col+0x50;
    13fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1400:	80 5b       	subi	r24, 0xB0	; 176
    1402:	89 83       	std	Y+1, r24	; 0x01
		break;
	}					
	/* to write to a specific address in the LCD 
	 * we need to apply the corresponding command 0b10000000+Address */
	LCD_sendCommand(Address | SET_CURSOR_LOCATION); 
    1404:	89 81       	ldd	r24, Y+1	; 0x01
    1406:	80 68       	ori	r24, 0x80	; 128
    1408:	0e 94 c9 08 	call	0x1192	; 0x1192 <LCD_sendCommand>
}
    140c:	0f 90       	pop	r0
    140e:	0f 90       	pop	r0
    1410:	0f 90       	pop	r0
    1412:	0f 90       	pop	r0
    1414:	0f 90       	pop	r0
    1416:	cf 91       	pop	r28
    1418:	df 91       	pop	r29
    141a:	08 95       	ret

0000141c <LCD_displayStringRowColumn>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_displayStringRowColumn(uint8 row,uint8 col,const uint8 *Str)
{
    141c:	df 93       	push	r29
    141e:	cf 93       	push	r28
    1420:	00 d0       	rcall	.+0      	; 0x1422 <LCD_displayStringRowColumn+0x6>
    1422:	00 d0       	rcall	.+0      	; 0x1424 <LCD_displayStringRowColumn+0x8>
    1424:	cd b7       	in	r28, 0x3d	; 61
    1426:	de b7       	in	r29, 0x3e	; 62
    1428:	89 83       	std	Y+1, r24	; 0x01
    142a:	6a 83       	std	Y+2, r22	; 0x02
    142c:	5c 83       	std	Y+4, r21	; 0x04
    142e:	4b 83       	std	Y+3, r20	; 0x03
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
    1430:	89 81       	ldd	r24, Y+1	; 0x01
    1432:	6a 81       	ldd	r22, Y+2	; 0x02
    1434:	0e 94 cc 09 	call	0x1398	; 0x1398 <LCD_goToRowColumn>
	LCD_displayString(Str); /* display the string */
    1438:	8b 81       	ldd	r24, Y+3	; 0x03
    143a:	9c 81       	ldd	r25, Y+4	; 0x04
    143c:	0e 94 a3 09 	call	0x1346	; 0x1346 <LCD_displayString>
}
    1440:	0f 90       	pop	r0
    1442:	0f 90       	pop	r0
    1444:	0f 90       	pop	r0
    1446:	0f 90       	pop	r0
    1448:	cf 91       	pop	r28
    144a:	df 91       	pop	r29
    144c:	08 95       	ret

0000144e <LCD_clearScreen>:
 * Outputs:			NULL
 *
 * Return:			NULL
 *******************************************************************************/
void LCD_clearScreen(void)
{
    144e:	df 93       	push	r29
    1450:	cf 93       	push	r28
    1452:	cd b7       	in	r28, 0x3d	; 61
    1454:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(CLEAR_COMMAND); //clear display 
    1456:	81 e0       	ldi	r24, 0x01	; 1
    1458:	0e 94 c9 08 	call	0x1192	; 0x1192 <LCD_sendCommand>
}
    145c:	cf 91       	pop	r28
    145e:	df 91       	pop	r29
    1460:	08 95       	ret

00001462 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1462:	df 93       	push	r29
    1464:	cf 93       	push	r28
    1466:	00 d0       	rcall	.+0      	; 0x1468 <vListInitialise+0x6>
    1468:	cd b7       	in	r28, 0x3d	; 61
    146a:	de b7       	in	r29, 0x3e	; 62
    146c:	9a 83       	std	Y+2, r25	; 0x02
    146e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1470:	89 81       	ldd	r24, Y+1	; 0x01
    1472:	9a 81       	ldd	r25, Y+2	; 0x02
    1474:	03 96       	adiw	r24, 0x03	; 3
    1476:	e9 81       	ldd	r30, Y+1	; 0x01
    1478:	fa 81       	ldd	r31, Y+2	; 0x02
    147a:	92 83       	std	Z+2, r25	; 0x02
    147c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    147e:	e9 81       	ldd	r30, Y+1	; 0x01
    1480:	fa 81       	ldd	r31, Y+2	; 0x02
    1482:	8f ef       	ldi	r24, 0xFF	; 255
    1484:	9f ef       	ldi	r25, 0xFF	; 255
    1486:	94 83       	std	Z+4, r25	; 0x04
    1488:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    148a:	89 81       	ldd	r24, Y+1	; 0x01
    148c:	9a 81       	ldd	r25, Y+2	; 0x02
    148e:	03 96       	adiw	r24, 0x03	; 3
    1490:	e9 81       	ldd	r30, Y+1	; 0x01
    1492:	fa 81       	ldd	r31, Y+2	; 0x02
    1494:	96 83       	std	Z+6, r25	; 0x06
    1496:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1498:	89 81       	ldd	r24, Y+1	; 0x01
    149a:	9a 81       	ldd	r25, Y+2	; 0x02
    149c:	03 96       	adiw	r24, 0x03	; 3
    149e:	e9 81       	ldd	r30, Y+1	; 0x01
    14a0:	fa 81       	ldd	r31, Y+2	; 0x02
    14a2:	90 87       	std	Z+8, r25	; 0x08
    14a4:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    14a6:	e9 81       	ldd	r30, Y+1	; 0x01
    14a8:	fa 81       	ldd	r31, Y+2	; 0x02
    14aa:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    14ac:	0f 90       	pop	r0
    14ae:	0f 90       	pop	r0
    14b0:	cf 91       	pop	r28
    14b2:	df 91       	pop	r29
    14b4:	08 95       	ret

000014b6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    14b6:	df 93       	push	r29
    14b8:	cf 93       	push	r28
    14ba:	00 d0       	rcall	.+0      	; 0x14bc <vListInitialiseItem+0x6>
    14bc:	cd b7       	in	r28, 0x3d	; 61
    14be:	de b7       	in	r29, 0x3e	; 62
    14c0:	9a 83       	std	Y+2, r25	; 0x02
    14c2:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    14c4:	e9 81       	ldd	r30, Y+1	; 0x01
    14c6:	fa 81       	ldd	r31, Y+2	; 0x02
    14c8:	11 86       	std	Z+9, r1	; 0x09
    14ca:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    14cc:	0f 90       	pop	r0
    14ce:	0f 90       	pop	r0
    14d0:	cf 91       	pop	r28
    14d2:	df 91       	pop	r29
    14d4:	08 95       	ret

000014d6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    14d6:	df 93       	push	r29
    14d8:	cf 93       	push	r28
    14da:	00 d0       	rcall	.+0      	; 0x14dc <vListInsertEnd+0x6>
    14dc:	00 d0       	rcall	.+0      	; 0x14de <vListInsertEnd+0x8>
    14de:	00 d0       	rcall	.+0      	; 0x14e0 <vListInsertEnd+0xa>
    14e0:	cd b7       	in	r28, 0x3d	; 61
    14e2:	de b7       	in	r29, 0x3e	; 62
    14e4:	9c 83       	std	Y+4, r25	; 0x04
    14e6:	8b 83       	std	Y+3, r24	; 0x03
    14e8:	7e 83       	std	Y+6, r23	; 0x06
    14ea:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    14ec:	eb 81       	ldd	r30, Y+3	; 0x03
    14ee:	fc 81       	ldd	r31, Y+4	; 0x04
    14f0:	81 81       	ldd	r24, Z+1	; 0x01
    14f2:	92 81       	ldd	r25, Z+2	; 0x02
    14f4:	9a 83       	std	Y+2, r25	; 0x02
    14f6:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    14f8:	ed 81       	ldd	r30, Y+5	; 0x05
    14fa:	fe 81       	ldd	r31, Y+6	; 0x06
    14fc:	89 81       	ldd	r24, Y+1	; 0x01
    14fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1500:	93 83       	std	Z+3, r25	; 0x03
    1502:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1504:	e9 81       	ldd	r30, Y+1	; 0x01
    1506:	fa 81       	ldd	r31, Y+2	; 0x02
    1508:	84 81       	ldd	r24, Z+4	; 0x04
    150a:	95 81       	ldd	r25, Z+5	; 0x05
    150c:	ed 81       	ldd	r30, Y+5	; 0x05
    150e:	fe 81       	ldd	r31, Y+6	; 0x06
    1510:	95 83       	std	Z+5, r25	; 0x05
    1512:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1514:	e9 81       	ldd	r30, Y+1	; 0x01
    1516:	fa 81       	ldd	r31, Y+2	; 0x02
    1518:	04 80       	ldd	r0, Z+4	; 0x04
    151a:	f5 81       	ldd	r31, Z+5	; 0x05
    151c:	e0 2d       	mov	r30, r0
    151e:	8d 81       	ldd	r24, Y+5	; 0x05
    1520:	9e 81       	ldd	r25, Y+6	; 0x06
    1522:	93 83       	std	Z+3, r25	; 0x03
    1524:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1526:	e9 81       	ldd	r30, Y+1	; 0x01
    1528:	fa 81       	ldd	r31, Y+2	; 0x02
    152a:	8d 81       	ldd	r24, Y+5	; 0x05
    152c:	9e 81       	ldd	r25, Y+6	; 0x06
    152e:	95 83       	std	Z+5, r25	; 0x05
    1530:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1532:	ed 81       	ldd	r30, Y+5	; 0x05
    1534:	fe 81       	ldd	r31, Y+6	; 0x06
    1536:	8b 81       	ldd	r24, Y+3	; 0x03
    1538:	9c 81       	ldd	r25, Y+4	; 0x04
    153a:	91 87       	std	Z+9, r25	; 0x09
    153c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    153e:	eb 81       	ldd	r30, Y+3	; 0x03
    1540:	fc 81       	ldd	r31, Y+4	; 0x04
    1542:	80 81       	ld	r24, Z
    1544:	8f 5f       	subi	r24, 0xFF	; 255
    1546:	eb 81       	ldd	r30, Y+3	; 0x03
    1548:	fc 81       	ldd	r31, Y+4	; 0x04
    154a:	80 83       	st	Z, r24
}
    154c:	26 96       	adiw	r28, 0x06	; 6
    154e:	0f b6       	in	r0, 0x3f	; 63
    1550:	f8 94       	cli
    1552:	de bf       	out	0x3e, r29	; 62
    1554:	0f be       	out	0x3f, r0	; 63
    1556:	cd bf       	out	0x3d, r28	; 61
    1558:	cf 91       	pop	r28
    155a:	df 91       	pop	r29
    155c:	08 95       	ret

0000155e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    155e:	df 93       	push	r29
    1560:	cf 93       	push	r28
    1562:	cd b7       	in	r28, 0x3d	; 61
    1564:	de b7       	in	r29, 0x3e	; 62
    1566:	28 97       	sbiw	r28, 0x08	; 8
    1568:	0f b6       	in	r0, 0x3f	; 63
    156a:	f8 94       	cli
    156c:	de bf       	out	0x3e, r29	; 62
    156e:	0f be       	out	0x3f, r0	; 63
    1570:	cd bf       	out	0x3d, r28	; 61
    1572:	9e 83       	std	Y+6, r25	; 0x06
    1574:	8d 83       	std	Y+5, r24	; 0x05
    1576:	78 87       	std	Y+8, r23	; 0x08
    1578:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    157a:	ef 81       	ldd	r30, Y+7	; 0x07
    157c:	f8 85       	ldd	r31, Y+8	; 0x08
    157e:	80 81       	ld	r24, Z
    1580:	91 81       	ldd	r25, Z+1	; 0x01
    1582:	9a 83       	std	Y+2, r25	; 0x02
    1584:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1586:	89 81       	ldd	r24, Y+1	; 0x01
    1588:	9a 81       	ldd	r25, Y+2	; 0x02
    158a:	2f ef       	ldi	r18, 0xFF	; 255
    158c:	8f 3f       	cpi	r24, 0xFF	; 255
    158e:	92 07       	cpc	r25, r18
    1590:	39 f4       	brne	.+14     	; 0x15a0 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1592:	ed 81       	ldd	r30, Y+5	; 0x05
    1594:	fe 81       	ldd	r31, Y+6	; 0x06
    1596:	87 81       	ldd	r24, Z+7	; 0x07
    1598:	90 85       	ldd	r25, Z+8	; 0x08
    159a:	9c 83       	std	Y+4, r25	; 0x04
    159c:	8b 83       	std	Y+3, r24	; 0x03
    159e:	18 c0       	rjmp	.+48     	; 0x15d0 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    15a0:	8d 81       	ldd	r24, Y+5	; 0x05
    15a2:	9e 81       	ldd	r25, Y+6	; 0x06
    15a4:	03 96       	adiw	r24, 0x03	; 3
    15a6:	9c 83       	std	Y+4, r25	; 0x04
    15a8:	8b 83       	std	Y+3, r24	; 0x03
    15aa:	06 c0       	rjmp	.+12     	; 0x15b8 <vListInsert+0x5a>
    15ac:	eb 81       	ldd	r30, Y+3	; 0x03
    15ae:	fc 81       	ldd	r31, Y+4	; 0x04
    15b0:	82 81       	ldd	r24, Z+2	; 0x02
    15b2:	93 81       	ldd	r25, Z+3	; 0x03
    15b4:	9c 83       	std	Y+4, r25	; 0x04
    15b6:	8b 83       	std	Y+3, r24	; 0x03
    15b8:	eb 81       	ldd	r30, Y+3	; 0x03
    15ba:	fc 81       	ldd	r31, Y+4	; 0x04
    15bc:	02 80       	ldd	r0, Z+2	; 0x02
    15be:	f3 81       	ldd	r31, Z+3	; 0x03
    15c0:	e0 2d       	mov	r30, r0
    15c2:	20 81       	ld	r18, Z
    15c4:	31 81       	ldd	r19, Z+1	; 0x01
    15c6:	89 81       	ldd	r24, Y+1	; 0x01
    15c8:	9a 81       	ldd	r25, Y+2	; 0x02
    15ca:	82 17       	cp	r24, r18
    15cc:	93 07       	cpc	r25, r19
    15ce:	70 f7       	brcc	.-36     	; 0x15ac <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    15d0:	eb 81       	ldd	r30, Y+3	; 0x03
    15d2:	fc 81       	ldd	r31, Y+4	; 0x04
    15d4:	82 81       	ldd	r24, Z+2	; 0x02
    15d6:	93 81       	ldd	r25, Z+3	; 0x03
    15d8:	ef 81       	ldd	r30, Y+7	; 0x07
    15da:	f8 85       	ldd	r31, Y+8	; 0x08
    15dc:	93 83       	std	Z+3, r25	; 0x03
    15de:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    15e0:	ef 81       	ldd	r30, Y+7	; 0x07
    15e2:	f8 85       	ldd	r31, Y+8	; 0x08
    15e4:	02 80       	ldd	r0, Z+2	; 0x02
    15e6:	f3 81       	ldd	r31, Z+3	; 0x03
    15e8:	e0 2d       	mov	r30, r0
    15ea:	8f 81       	ldd	r24, Y+7	; 0x07
    15ec:	98 85       	ldd	r25, Y+8	; 0x08
    15ee:	95 83       	std	Z+5, r25	; 0x05
    15f0:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    15f2:	ef 81       	ldd	r30, Y+7	; 0x07
    15f4:	f8 85       	ldd	r31, Y+8	; 0x08
    15f6:	8b 81       	ldd	r24, Y+3	; 0x03
    15f8:	9c 81       	ldd	r25, Y+4	; 0x04
    15fa:	95 83       	std	Z+5, r25	; 0x05
    15fc:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    15fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1600:	fc 81       	ldd	r31, Y+4	; 0x04
    1602:	8f 81       	ldd	r24, Y+7	; 0x07
    1604:	98 85       	ldd	r25, Y+8	; 0x08
    1606:	93 83       	std	Z+3, r25	; 0x03
    1608:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    160a:	ef 81       	ldd	r30, Y+7	; 0x07
    160c:	f8 85       	ldd	r31, Y+8	; 0x08
    160e:	8d 81       	ldd	r24, Y+5	; 0x05
    1610:	9e 81       	ldd	r25, Y+6	; 0x06
    1612:	91 87       	std	Z+9, r25	; 0x09
    1614:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1616:	ed 81       	ldd	r30, Y+5	; 0x05
    1618:	fe 81       	ldd	r31, Y+6	; 0x06
    161a:	80 81       	ld	r24, Z
    161c:	8f 5f       	subi	r24, 0xFF	; 255
    161e:	ed 81       	ldd	r30, Y+5	; 0x05
    1620:	fe 81       	ldd	r31, Y+6	; 0x06
    1622:	80 83       	st	Z, r24
}
    1624:	28 96       	adiw	r28, 0x08	; 8
    1626:	0f b6       	in	r0, 0x3f	; 63
    1628:	f8 94       	cli
    162a:	de bf       	out	0x3e, r29	; 62
    162c:	0f be       	out	0x3f, r0	; 63
    162e:	cd bf       	out	0x3d, r28	; 61
    1630:	cf 91       	pop	r28
    1632:	df 91       	pop	r29
    1634:	08 95       	ret

00001636 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1636:	df 93       	push	r29
    1638:	cf 93       	push	r28
    163a:	00 d0       	rcall	.+0      	; 0x163c <uxListRemove+0x6>
    163c:	00 d0       	rcall	.+0      	; 0x163e <uxListRemove+0x8>
    163e:	cd b7       	in	r28, 0x3d	; 61
    1640:	de b7       	in	r29, 0x3e	; 62
    1642:	9c 83       	std	Y+4, r25	; 0x04
    1644:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1646:	eb 81       	ldd	r30, Y+3	; 0x03
    1648:	fc 81       	ldd	r31, Y+4	; 0x04
    164a:	80 85       	ldd	r24, Z+8	; 0x08
    164c:	91 85       	ldd	r25, Z+9	; 0x09
    164e:	9a 83       	std	Y+2, r25	; 0x02
    1650:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1652:	eb 81       	ldd	r30, Y+3	; 0x03
    1654:	fc 81       	ldd	r31, Y+4	; 0x04
    1656:	a2 81       	ldd	r26, Z+2	; 0x02
    1658:	b3 81       	ldd	r27, Z+3	; 0x03
    165a:	eb 81       	ldd	r30, Y+3	; 0x03
    165c:	fc 81       	ldd	r31, Y+4	; 0x04
    165e:	84 81       	ldd	r24, Z+4	; 0x04
    1660:	95 81       	ldd	r25, Z+5	; 0x05
    1662:	15 96       	adiw	r26, 0x05	; 5
    1664:	9c 93       	st	X, r25
    1666:	8e 93       	st	-X, r24
    1668:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    166a:	eb 81       	ldd	r30, Y+3	; 0x03
    166c:	fc 81       	ldd	r31, Y+4	; 0x04
    166e:	a4 81       	ldd	r26, Z+4	; 0x04
    1670:	b5 81       	ldd	r27, Z+5	; 0x05
    1672:	eb 81       	ldd	r30, Y+3	; 0x03
    1674:	fc 81       	ldd	r31, Y+4	; 0x04
    1676:	82 81       	ldd	r24, Z+2	; 0x02
    1678:	93 81       	ldd	r25, Z+3	; 0x03
    167a:	13 96       	adiw	r26, 0x03	; 3
    167c:	9c 93       	st	X, r25
    167e:	8e 93       	st	-X, r24
    1680:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1682:	e9 81       	ldd	r30, Y+1	; 0x01
    1684:	fa 81       	ldd	r31, Y+2	; 0x02
    1686:	21 81       	ldd	r18, Z+1	; 0x01
    1688:	32 81       	ldd	r19, Z+2	; 0x02
    168a:	8b 81       	ldd	r24, Y+3	; 0x03
    168c:	9c 81       	ldd	r25, Y+4	; 0x04
    168e:	28 17       	cp	r18, r24
    1690:	39 07       	cpc	r19, r25
    1692:	41 f4       	brne	.+16     	; 0x16a4 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1694:	eb 81       	ldd	r30, Y+3	; 0x03
    1696:	fc 81       	ldd	r31, Y+4	; 0x04
    1698:	84 81       	ldd	r24, Z+4	; 0x04
    169a:	95 81       	ldd	r25, Z+5	; 0x05
    169c:	e9 81       	ldd	r30, Y+1	; 0x01
    169e:	fa 81       	ldd	r31, Y+2	; 0x02
    16a0:	92 83       	std	Z+2, r25	; 0x02
    16a2:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    16a4:	eb 81       	ldd	r30, Y+3	; 0x03
    16a6:	fc 81       	ldd	r31, Y+4	; 0x04
    16a8:	11 86       	std	Z+9, r1	; 0x09
    16aa:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    16ac:	e9 81       	ldd	r30, Y+1	; 0x01
    16ae:	fa 81       	ldd	r31, Y+2	; 0x02
    16b0:	80 81       	ld	r24, Z
    16b2:	81 50       	subi	r24, 0x01	; 1
    16b4:	e9 81       	ldd	r30, Y+1	; 0x01
    16b6:	fa 81       	ldd	r31, Y+2	; 0x02
    16b8:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    16ba:	e9 81       	ldd	r30, Y+1	; 0x01
    16bc:	fa 81       	ldd	r31, Y+2	; 0x02
    16be:	80 81       	ld	r24, Z
}
    16c0:	0f 90       	pop	r0
    16c2:	0f 90       	pop	r0
    16c4:	0f 90       	pop	r0
    16c6:	0f 90       	pop	r0
    16c8:	cf 91       	pop	r28
    16ca:	df 91       	pop	r29
    16cc:	08 95       	ret

000016ce <main>:

#include "UserTasks.h"


void main(void)
{
    16ce:	ef 92       	push	r14
    16d0:	ff 92       	push	r15
    16d2:	0f 93       	push	r16
    16d4:	df 93       	push	r29
    16d6:	cf 93       	push	r28
    16d8:	cd b7       	in	r28, 0x3d	; 61
    16da:	de b7       	in	r29, 0x3e	; 62
	xTaskCreate(init_Task  , "Init_Task" , configMINIMAL_STACK_SIZE ,
    16dc:	89 e9       	ldi	r24, 0x99	; 153
    16de:	92 e0       	ldi	r25, 0x02	; 2
    16e0:	27 e9       	ldi	r18, 0x97	; 151
    16e2:	30 e0       	ldi	r19, 0x00	; 0
    16e4:	eb ea       	ldi	r30, 0xAB	; 171
    16e6:	f0 e0       	ldi	r31, 0x00	; 0
    16e8:	b9 01       	movw	r22, r18
    16ea:	45 e5       	ldi	r20, 0x55	; 85
    16ec:	50 e0       	ldi	r21, 0x00	; 0
    16ee:	20 e0       	ldi	r18, 0x00	; 0
    16f0:	30 e0       	ldi	r19, 0x00	; 0
    16f2:	03 e0       	ldi	r16, 0x03	; 3
    16f4:	7f 01       	movw	r14, r30
    16f6:	0e 94 0e 1d 	call	0x3a1c	; 0x3a1c <xTaskCreate>
			NULL , (3 | portPRIVILEGE_BIT) , &InitTask_Flag);


	/* Start Scheduler */
	DIO_SetPinDirection(DIO_PIN12,OUTPUT);
    16fa:	8c e0       	ldi	r24, 0x0C	; 12
    16fc:	61 e0       	ldi	r22, 0x01	; 1
    16fe:	0e 94 aa 01 	call	0x354	; 0x354 <DIO_SetPinDirection>

	vTaskStartScheduler();
    1702:	0e 94 bb 20 	call	0x4176	; 0x4176 <vTaskStartScheduler>
    1706:	ff cf       	rjmp	.-2      	; 0x1706 <main+0x38>

00001708 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1708:	df 93       	push	r29
    170a:	cf 93       	push	r28
    170c:	cd b7       	in	r28, 0x3d	; 61
    170e:	de b7       	in	r29, 0x3e	; 62
    1710:	28 97       	sbiw	r28, 0x08	; 8
    1712:	0f b6       	in	r0, 0x3f	; 63
    1714:	f8 94       	cli
    1716:	de bf       	out	0x3e, r29	; 62
    1718:	0f be       	out	0x3f, r0	; 63
    171a:	cd bf       	out	0x3d, r28	; 61
    171c:	9c 83       	std	Y+4, r25	; 0x04
    171e:	8b 83       	std	Y+3, r24	; 0x03
    1720:	7e 83       	std	Y+6, r23	; 0x06
    1722:	6d 83       	std	Y+5, r22	; 0x05
    1724:	58 87       	std	Y+8, r21	; 0x08
    1726:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1728:	eb 81       	ldd	r30, Y+3	; 0x03
    172a:	fc 81       	ldd	r31, Y+4	; 0x04
    172c:	81 e1       	ldi	r24, 0x11	; 17
    172e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1730:	8b 81       	ldd	r24, Y+3	; 0x03
    1732:	9c 81       	ldd	r25, Y+4	; 0x04
    1734:	01 97       	sbiw	r24, 0x01	; 1
    1736:	9c 83       	std	Y+4, r25	; 0x04
    1738:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    173a:	eb 81       	ldd	r30, Y+3	; 0x03
    173c:	fc 81       	ldd	r31, Y+4	; 0x04
    173e:	82 e2       	ldi	r24, 0x22	; 34
    1740:	80 83       	st	Z, r24
	pxTopOfStack--;
    1742:	8b 81       	ldd	r24, Y+3	; 0x03
    1744:	9c 81       	ldd	r25, Y+4	; 0x04
    1746:	01 97       	sbiw	r24, 0x01	; 1
    1748:	9c 83       	std	Y+4, r25	; 0x04
    174a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    174c:	eb 81       	ldd	r30, Y+3	; 0x03
    174e:	fc 81       	ldd	r31, Y+4	; 0x04
    1750:	83 e3       	ldi	r24, 0x33	; 51
    1752:	80 83       	st	Z, r24
	pxTopOfStack--;
    1754:	8b 81       	ldd	r24, Y+3	; 0x03
    1756:	9c 81       	ldd	r25, Y+4	; 0x04
    1758:	01 97       	sbiw	r24, 0x01	; 1
    175a:	9c 83       	std	Y+4, r25	; 0x04
    175c:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    175e:	8d 81       	ldd	r24, Y+5	; 0x05
    1760:	9e 81       	ldd	r25, Y+6	; 0x06
    1762:	9a 83       	std	Y+2, r25	; 0x02
    1764:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1766:	89 81       	ldd	r24, Y+1	; 0x01
    1768:	eb 81       	ldd	r30, Y+3	; 0x03
    176a:	fc 81       	ldd	r31, Y+4	; 0x04
    176c:	80 83       	st	Z, r24
	pxTopOfStack--;
    176e:	8b 81       	ldd	r24, Y+3	; 0x03
    1770:	9c 81       	ldd	r25, Y+4	; 0x04
    1772:	01 97       	sbiw	r24, 0x01	; 1
    1774:	9c 83       	std	Y+4, r25	; 0x04
    1776:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1778:	89 81       	ldd	r24, Y+1	; 0x01
    177a:	9a 81       	ldd	r25, Y+2	; 0x02
    177c:	89 2f       	mov	r24, r25
    177e:	99 27       	eor	r25, r25
    1780:	9a 83       	std	Y+2, r25	; 0x02
    1782:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1784:	89 81       	ldd	r24, Y+1	; 0x01
    1786:	eb 81       	ldd	r30, Y+3	; 0x03
    1788:	fc 81       	ldd	r31, Y+4	; 0x04
    178a:	80 83       	st	Z, r24
	pxTopOfStack--;
    178c:	8b 81       	ldd	r24, Y+3	; 0x03
    178e:	9c 81       	ldd	r25, Y+4	; 0x04
    1790:	01 97       	sbiw	r24, 0x01	; 1
    1792:	9c 83       	std	Y+4, r25	; 0x04
    1794:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1796:	eb 81       	ldd	r30, Y+3	; 0x03
    1798:	fc 81       	ldd	r31, Y+4	; 0x04
    179a:	10 82       	st	Z, r1
	pxTopOfStack--;
    179c:	8b 81       	ldd	r24, Y+3	; 0x03
    179e:	9c 81       	ldd	r25, Y+4	; 0x04
    17a0:	01 97       	sbiw	r24, 0x01	; 1
    17a2:	9c 83       	std	Y+4, r25	; 0x04
    17a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    17a6:	eb 81       	ldd	r30, Y+3	; 0x03
    17a8:	fc 81       	ldd	r31, Y+4	; 0x04
    17aa:	80 e8       	ldi	r24, 0x80	; 128
    17ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    17ae:	8b 81       	ldd	r24, Y+3	; 0x03
    17b0:	9c 81       	ldd	r25, Y+4	; 0x04
    17b2:	01 97       	sbiw	r24, 0x01	; 1
    17b4:	9c 83       	std	Y+4, r25	; 0x04
    17b6:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    17b8:	eb 81       	ldd	r30, Y+3	; 0x03
    17ba:	fc 81       	ldd	r31, Y+4	; 0x04
    17bc:	10 82       	st	Z, r1
	pxTopOfStack--;
    17be:	8b 81       	ldd	r24, Y+3	; 0x03
    17c0:	9c 81       	ldd	r25, Y+4	; 0x04
    17c2:	01 97       	sbiw	r24, 0x01	; 1
    17c4:	9c 83       	std	Y+4, r25	; 0x04
    17c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    17c8:	eb 81       	ldd	r30, Y+3	; 0x03
    17ca:	fc 81       	ldd	r31, Y+4	; 0x04
    17cc:	82 e0       	ldi	r24, 0x02	; 2
    17ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    17d0:	8b 81       	ldd	r24, Y+3	; 0x03
    17d2:	9c 81       	ldd	r25, Y+4	; 0x04
    17d4:	01 97       	sbiw	r24, 0x01	; 1
    17d6:	9c 83       	std	Y+4, r25	; 0x04
    17d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    17da:	eb 81       	ldd	r30, Y+3	; 0x03
    17dc:	fc 81       	ldd	r31, Y+4	; 0x04
    17de:	83 e0       	ldi	r24, 0x03	; 3
    17e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    17e2:	8b 81       	ldd	r24, Y+3	; 0x03
    17e4:	9c 81       	ldd	r25, Y+4	; 0x04
    17e6:	01 97       	sbiw	r24, 0x01	; 1
    17e8:	9c 83       	std	Y+4, r25	; 0x04
    17ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    17ec:	eb 81       	ldd	r30, Y+3	; 0x03
    17ee:	fc 81       	ldd	r31, Y+4	; 0x04
    17f0:	84 e0       	ldi	r24, 0x04	; 4
    17f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    17f4:	8b 81       	ldd	r24, Y+3	; 0x03
    17f6:	9c 81       	ldd	r25, Y+4	; 0x04
    17f8:	01 97       	sbiw	r24, 0x01	; 1
    17fa:	9c 83       	std	Y+4, r25	; 0x04
    17fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    17fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1800:	fc 81       	ldd	r31, Y+4	; 0x04
    1802:	85 e0       	ldi	r24, 0x05	; 5
    1804:	80 83       	st	Z, r24
	pxTopOfStack--;
    1806:	8b 81       	ldd	r24, Y+3	; 0x03
    1808:	9c 81       	ldd	r25, Y+4	; 0x04
    180a:	01 97       	sbiw	r24, 0x01	; 1
    180c:	9c 83       	std	Y+4, r25	; 0x04
    180e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1810:	eb 81       	ldd	r30, Y+3	; 0x03
    1812:	fc 81       	ldd	r31, Y+4	; 0x04
    1814:	86 e0       	ldi	r24, 0x06	; 6
    1816:	80 83       	st	Z, r24
	pxTopOfStack--;
    1818:	8b 81       	ldd	r24, Y+3	; 0x03
    181a:	9c 81       	ldd	r25, Y+4	; 0x04
    181c:	01 97       	sbiw	r24, 0x01	; 1
    181e:	9c 83       	std	Y+4, r25	; 0x04
    1820:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1822:	eb 81       	ldd	r30, Y+3	; 0x03
    1824:	fc 81       	ldd	r31, Y+4	; 0x04
    1826:	87 e0       	ldi	r24, 0x07	; 7
    1828:	80 83       	st	Z, r24
	pxTopOfStack--;
    182a:	8b 81       	ldd	r24, Y+3	; 0x03
    182c:	9c 81       	ldd	r25, Y+4	; 0x04
    182e:	01 97       	sbiw	r24, 0x01	; 1
    1830:	9c 83       	std	Y+4, r25	; 0x04
    1832:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1834:	eb 81       	ldd	r30, Y+3	; 0x03
    1836:	fc 81       	ldd	r31, Y+4	; 0x04
    1838:	88 e0       	ldi	r24, 0x08	; 8
    183a:	80 83       	st	Z, r24
	pxTopOfStack--;
    183c:	8b 81       	ldd	r24, Y+3	; 0x03
    183e:	9c 81       	ldd	r25, Y+4	; 0x04
    1840:	01 97       	sbiw	r24, 0x01	; 1
    1842:	9c 83       	std	Y+4, r25	; 0x04
    1844:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1846:	eb 81       	ldd	r30, Y+3	; 0x03
    1848:	fc 81       	ldd	r31, Y+4	; 0x04
    184a:	89 e0       	ldi	r24, 0x09	; 9
    184c:	80 83       	st	Z, r24
	pxTopOfStack--;
    184e:	8b 81       	ldd	r24, Y+3	; 0x03
    1850:	9c 81       	ldd	r25, Y+4	; 0x04
    1852:	01 97       	sbiw	r24, 0x01	; 1
    1854:	9c 83       	std	Y+4, r25	; 0x04
    1856:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1858:	eb 81       	ldd	r30, Y+3	; 0x03
    185a:	fc 81       	ldd	r31, Y+4	; 0x04
    185c:	80 e1       	ldi	r24, 0x10	; 16
    185e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1860:	8b 81       	ldd	r24, Y+3	; 0x03
    1862:	9c 81       	ldd	r25, Y+4	; 0x04
    1864:	01 97       	sbiw	r24, 0x01	; 1
    1866:	9c 83       	std	Y+4, r25	; 0x04
    1868:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    186a:	eb 81       	ldd	r30, Y+3	; 0x03
    186c:	fc 81       	ldd	r31, Y+4	; 0x04
    186e:	81 e1       	ldi	r24, 0x11	; 17
    1870:	80 83       	st	Z, r24
	pxTopOfStack--;
    1872:	8b 81       	ldd	r24, Y+3	; 0x03
    1874:	9c 81       	ldd	r25, Y+4	; 0x04
    1876:	01 97       	sbiw	r24, 0x01	; 1
    1878:	9c 83       	std	Y+4, r25	; 0x04
    187a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    187c:	eb 81       	ldd	r30, Y+3	; 0x03
    187e:	fc 81       	ldd	r31, Y+4	; 0x04
    1880:	82 e1       	ldi	r24, 0x12	; 18
    1882:	80 83       	st	Z, r24
	pxTopOfStack--;
    1884:	8b 81       	ldd	r24, Y+3	; 0x03
    1886:	9c 81       	ldd	r25, Y+4	; 0x04
    1888:	01 97       	sbiw	r24, 0x01	; 1
    188a:	9c 83       	std	Y+4, r25	; 0x04
    188c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    188e:	eb 81       	ldd	r30, Y+3	; 0x03
    1890:	fc 81       	ldd	r31, Y+4	; 0x04
    1892:	83 e1       	ldi	r24, 0x13	; 19
    1894:	80 83       	st	Z, r24
	pxTopOfStack--;
    1896:	8b 81       	ldd	r24, Y+3	; 0x03
    1898:	9c 81       	ldd	r25, Y+4	; 0x04
    189a:	01 97       	sbiw	r24, 0x01	; 1
    189c:	9c 83       	std	Y+4, r25	; 0x04
    189e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    18a0:	eb 81       	ldd	r30, Y+3	; 0x03
    18a2:	fc 81       	ldd	r31, Y+4	; 0x04
    18a4:	84 e1       	ldi	r24, 0x14	; 20
    18a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    18a8:	8b 81       	ldd	r24, Y+3	; 0x03
    18aa:	9c 81       	ldd	r25, Y+4	; 0x04
    18ac:	01 97       	sbiw	r24, 0x01	; 1
    18ae:	9c 83       	std	Y+4, r25	; 0x04
    18b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    18b2:	eb 81       	ldd	r30, Y+3	; 0x03
    18b4:	fc 81       	ldd	r31, Y+4	; 0x04
    18b6:	85 e1       	ldi	r24, 0x15	; 21
    18b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    18ba:	8b 81       	ldd	r24, Y+3	; 0x03
    18bc:	9c 81       	ldd	r25, Y+4	; 0x04
    18be:	01 97       	sbiw	r24, 0x01	; 1
    18c0:	9c 83       	std	Y+4, r25	; 0x04
    18c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    18c4:	eb 81       	ldd	r30, Y+3	; 0x03
    18c6:	fc 81       	ldd	r31, Y+4	; 0x04
    18c8:	86 e1       	ldi	r24, 0x16	; 22
    18ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    18cc:	8b 81       	ldd	r24, Y+3	; 0x03
    18ce:	9c 81       	ldd	r25, Y+4	; 0x04
    18d0:	01 97       	sbiw	r24, 0x01	; 1
    18d2:	9c 83       	std	Y+4, r25	; 0x04
    18d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    18d6:	eb 81       	ldd	r30, Y+3	; 0x03
    18d8:	fc 81       	ldd	r31, Y+4	; 0x04
    18da:	87 e1       	ldi	r24, 0x17	; 23
    18dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    18de:	8b 81       	ldd	r24, Y+3	; 0x03
    18e0:	9c 81       	ldd	r25, Y+4	; 0x04
    18e2:	01 97       	sbiw	r24, 0x01	; 1
    18e4:	9c 83       	std	Y+4, r25	; 0x04
    18e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    18e8:	eb 81       	ldd	r30, Y+3	; 0x03
    18ea:	fc 81       	ldd	r31, Y+4	; 0x04
    18ec:	88 e1       	ldi	r24, 0x18	; 24
    18ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    18f0:	8b 81       	ldd	r24, Y+3	; 0x03
    18f2:	9c 81       	ldd	r25, Y+4	; 0x04
    18f4:	01 97       	sbiw	r24, 0x01	; 1
    18f6:	9c 83       	std	Y+4, r25	; 0x04
    18f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    18fa:	eb 81       	ldd	r30, Y+3	; 0x03
    18fc:	fc 81       	ldd	r31, Y+4	; 0x04
    18fe:	89 e1       	ldi	r24, 0x19	; 25
    1900:	80 83       	st	Z, r24
	pxTopOfStack--;
    1902:	8b 81       	ldd	r24, Y+3	; 0x03
    1904:	9c 81       	ldd	r25, Y+4	; 0x04
    1906:	01 97       	sbiw	r24, 0x01	; 1
    1908:	9c 83       	std	Y+4, r25	; 0x04
    190a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    190c:	eb 81       	ldd	r30, Y+3	; 0x03
    190e:	fc 81       	ldd	r31, Y+4	; 0x04
    1910:	80 e2       	ldi	r24, 0x20	; 32
    1912:	80 83       	st	Z, r24
	pxTopOfStack--;
    1914:	8b 81       	ldd	r24, Y+3	; 0x03
    1916:	9c 81       	ldd	r25, Y+4	; 0x04
    1918:	01 97       	sbiw	r24, 0x01	; 1
    191a:	9c 83       	std	Y+4, r25	; 0x04
    191c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    191e:	eb 81       	ldd	r30, Y+3	; 0x03
    1920:	fc 81       	ldd	r31, Y+4	; 0x04
    1922:	81 e2       	ldi	r24, 0x21	; 33
    1924:	80 83       	st	Z, r24
	pxTopOfStack--;
    1926:	8b 81       	ldd	r24, Y+3	; 0x03
    1928:	9c 81       	ldd	r25, Y+4	; 0x04
    192a:	01 97       	sbiw	r24, 0x01	; 1
    192c:	9c 83       	std	Y+4, r25	; 0x04
    192e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1930:	eb 81       	ldd	r30, Y+3	; 0x03
    1932:	fc 81       	ldd	r31, Y+4	; 0x04
    1934:	82 e2       	ldi	r24, 0x22	; 34
    1936:	80 83       	st	Z, r24
	pxTopOfStack--;
    1938:	8b 81       	ldd	r24, Y+3	; 0x03
    193a:	9c 81       	ldd	r25, Y+4	; 0x04
    193c:	01 97       	sbiw	r24, 0x01	; 1
    193e:	9c 83       	std	Y+4, r25	; 0x04
    1940:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1942:	eb 81       	ldd	r30, Y+3	; 0x03
    1944:	fc 81       	ldd	r31, Y+4	; 0x04
    1946:	83 e2       	ldi	r24, 0x23	; 35
    1948:	80 83       	st	Z, r24
	pxTopOfStack--;
    194a:	8b 81       	ldd	r24, Y+3	; 0x03
    194c:	9c 81       	ldd	r25, Y+4	; 0x04
    194e:	01 97       	sbiw	r24, 0x01	; 1
    1950:	9c 83       	std	Y+4, r25	; 0x04
    1952:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1954:	8f 81       	ldd	r24, Y+7	; 0x07
    1956:	98 85       	ldd	r25, Y+8	; 0x08
    1958:	9a 83       	std	Y+2, r25	; 0x02
    195a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    195c:	89 81       	ldd	r24, Y+1	; 0x01
    195e:	eb 81       	ldd	r30, Y+3	; 0x03
    1960:	fc 81       	ldd	r31, Y+4	; 0x04
    1962:	80 83       	st	Z, r24
	pxTopOfStack--;
    1964:	8b 81       	ldd	r24, Y+3	; 0x03
    1966:	9c 81       	ldd	r25, Y+4	; 0x04
    1968:	01 97       	sbiw	r24, 0x01	; 1
    196a:	9c 83       	std	Y+4, r25	; 0x04
    196c:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    196e:	89 81       	ldd	r24, Y+1	; 0x01
    1970:	9a 81       	ldd	r25, Y+2	; 0x02
    1972:	89 2f       	mov	r24, r25
    1974:	99 27       	eor	r25, r25
    1976:	9a 83       	std	Y+2, r25	; 0x02
    1978:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    197a:	89 81       	ldd	r24, Y+1	; 0x01
    197c:	eb 81       	ldd	r30, Y+3	; 0x03
    197e:	fc 81       	ldd	r31, Y+4	; 0x04
    1980:	80 83       	st	Z, r24
	pxTopOfStack--;
    1982:	8b 81       	ldd	r24, Y+3	; 0x03
    1984:	9c 81       	ldd	r25, Y+4	; 0x04
    1986:	01 97       	sbiw	r24, 0x01	; 1
    1988:	9c 83       	std	Y+4, r25	; 0x04
    198a:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    198c:	eb 81       	ldd	r30, Y+3	; 0x03
    198e:	fc 81       	ldd	r31, Y+4	; 0x04
    1990:	86 e2       	ldi	r24, 0x26	; 38
    1992:	80 83       	st	Z, r24
	pxTopOfStack--;
    1994:	8b 81       	ldd	r24, Y+3	; 0x03
    1996:	9c 81       	ldd	r25, Y+4	; 0x04
    1998:	01 97       	sbiw	r24, 0x01	; 1
    199a:	9c 83       	std	Y+4, r25	; 0x04
    199c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    199e:	eb 81       	ldd	r30, Y+3	; 0x03
    19a0:	fc 81       	ldd	r31, Y+4	; 0x04
    19a2:	87 e2       	ldi	r24, 0x27	; 39
    19a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    19a6:	8b 81       	ldd	r24, Y+3	; 0x03
    19a8:	9c 81       	ldd	r25, Y+4	; 0x04
    19aa:	01 97       	sbiw	r24, 0x01	; 1
    19ac:	9c 83       	std	Y+4, r25	; 0x04
    19ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    19b0:	eb 81       	ldd	r30, Y+3	; 0x03
    19b2:	fc 81       	ldd	r31, Y+4	; 0x04
    19b4:	88 e2       	ldi	r24, 0x28	; 40
    19b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    19b8:	8b 81       	ldd	r24, Y+3	; 0x03
    19ba:	9c 81       	ldd	r25, Y+4	; 0x04
    19bc:	01 97       	sbiw	r24, 0x01	; 1
    19be:	9c 83       	std	Y+4, r25	; 0x04
    19c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    19c2:	eb 81       	ldd	r30, Y+3	; 0x03
    19c4:	fc 81       	ldd	r31, Y+4	; 0x04
    19c6:	89 e2       	ldi	r24, 0x29	; 41
    19c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    19ca:	8b 81       	ldd	r24, Y+3	; 0x03
    19cc:	9c 81       	ldd	r25, Y+4	; 0x04
    19ce:	01 97       	sbiw	r24, 0x01	; 1
    19d0:	9c 83       	std	Y+4, r25	; 0x04
    19d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    19d4:	eb 81       	ldd	r30, Y+3	; 0x03
    19d6:	fc 81       	ldd	r31, Y+4	; 0x04
    19d8:	80 e3       	ldi	r24, 0x30	; 48
    19da:	80 83       	st	Z, r24
	pxTopOfStack--;
    19dc:	8b 81       	ldd	r24, Y+3	; 0x03
    19de:	9c 81       	ldd	r25, Y+4	; 0x04
    19e0:	01 97       	sbiw	r24, 0x01	; 1
    19e2:	9c 83       	std	Y+4, r25	; 0x04
    19e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    19e6:	eb 81       	ldd	r30, Y+3	; 0x03
    19e8:	fc 81       	ldd	r31, Y+4	; 0x04
    19ea:	81 e3       	ldi	r24, 0x31	; 49
    19ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    19ee:	8b 81       	ldd	r24, Y+3	; 0x03
    19f0:	9c 81       	ldd	r25, Y+4	; 0x04
    19f2:	01 97       	sbiw	r24, 0x01	; 1
    19f4:	9c 83       	std	Y+4, r25	; 0x04
    19f6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    19f8:	8b 81       	ldd	r24, Y+3	; 0x03
    19fa:	9c 81       	ldd	r25, Y+4	; 0x04
}
    19fc:	28 96       	adiw	r28, 0x08	; 8
    19fe:	0f b6       	in	r0, 0x3f	; 63
    1a00:	f8 94       	cli
    1a02:	de bf       	out	0x3e, r29	; 62
    1a04:	0f be       	out	0x3f, r0	; 63
    1a06:	cd bf       	out	0x3d, r28	; 61
    1a08:	cf 91       	pop	r28
    1a0a:	df 91       	pop	r29
    1a0c:	08 95       	ret

00001a0e <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1a0e:	df 93       	push	r29
    1a10:	cf 93       	push	r28
    1a12:	cd b7       	in	r28, 0x3d	; 61
    1a14:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1a16:	0e 94 f9 0d 	call	0x1bf2	; 0x1bf2 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1a1a:	a0 91 8d 06 	lds	r26, 0x068D
    1a1e:	b0 91 8e 06 	lds	r27, 0x068E
    1a22:	cd 91       	ld	r28, X+
    1a24:	cd bf       	out	0x3d, r28	; 61
    1a26:	dd 91       	ld	r29, X+
    1a28:	de bf       	out	0x3e, r29	; 62
    1a2a:	ff 91       	pop	r31
    1a2c:	ef 91       	pop	r30
    1a2e:	df 91       	pop	r29
    1a30:	cf 91       	pop	r28
    1a32:	bf 91       	pop	r27
    1a34:	af 91       	pop	r26
    1a36:	9f 91       	pop	r25
    1a38:	8f 91       	pop	r24
    1a3a:	7f 91       	pop	r23
    1a3c:	6f 91       	pop	r22
    1a3e:	5f 91       	pop	r21
    1a40:	4f 91       	pop	r20
    1a42:	3f 91       	pop	r19
    1a44:	2f 91       	pop	r18
    1a46:	1f 91       	pop	r17
    1a48:	0f 91       	pop	r16
    1a4a:	ff 90       	pop	r15
    1a4c:	ef 90       	pop	r14
    1a4e:	df 90       	pop	r13
    1a50:	cf 90       	pop	r12
    1a52:	bf 90       	pop	r11
    1a54:	af 90       	pop	r10
    1a56:	9f 90       	pop	r9
    1a58:	8f 90       	pop	r8
    1a5a:	7f 90       	pop	r7
    1a5c:	6f 90       	pop	r6
    1a5e:	5f 90       	pop	r5
    1a60:	4f 90       	pop	r4
    1a62:	3f 90       	pop	r3
    1a64:	2f 90       	pop	r2
    1a66:	1f 90       	pop	r1
    1a68:	0f 90       	pop	r0
    1a6a:	0f be       	out	0x3f, r0	; 63
    1a6c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1a6e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1a70:	81 e0       	ldi	r24, 0x01	; 1
}
    1a72:	cf 91       	pop	r28
    1a74:	df 91       	pop	r29
    1a76:	08 95       	ret

00001a78 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1a78:	df 93       	push	r29
    1a7a:	cf 93       	push	r28
    1a7c:	cd b7       	in	r28, 0x3d	; 61
    1a7e:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1a80:	cf 91       	pop	r28
    1a82:	df 91       	pop	r29
    1a84:	08 95       	ret

00001a86 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1a86:	0f 92       	push	r0
    1a88:	0f b6       	in	r0, 0x3f	; 63
    1a8a:	f8 94       	cli
    1a8c:	0f 92       	push	r0
    1a8e:	1f 92       	push	r1
    1a90:	11 24       	eor	r1, r1
    1a92:	2f 92       	push	r2
    1a94:	3f 92       	push	r3
    1a96:	4f 92       	push	r4
    1a98:	5f 92       	push	r5
    1a9a:	6f 92       	push	r6
    1a9c:	7f 92       	push	r7
    1a9e:	8f 92       	push	r8
    1aa0:	9f 92       	push	r9
    1aa2:	af 92       	push	r10
    1aa4:	bf 92       	push	r11
    1aa6:	cf 92       	push	r12
    1aa8:	df 92       	push	r13
    1aaa:	ef 92       	push	r14
    1aac:	ff 92       	push	r15
    1aae:	0f 93       	push	r16
    1ab0:	1f 93       	push	r17
    1ab2:	2f 93       	push	r18
    1ab4:	3f 93       	push	r19
    1ab6:	4f 93       	push	r20
    1ab8:	5f 93       	push	r21
    1aba:	6f 93       	push	r22
    1abc:	7f 93       	push	r23
    1abe:	8f 93       	push	r24
    1ac0:	9f 93       	push	r25
    1ac2:	af 93       	push	r26
    1ac4:	bf 93       	push	r27
    1ac6:	cf 93       	push	r28
    1ac8:	df 93       	push	r29
    1aca:	ef 93       	push	r30
    1acc:	ff 93       	push	r31
    1ace:	a0 91 8d 06 	lds	r26, 0x068D
    1ad2:	b0 91 8e 06 	lds	r27, 0x068E
    1ad6:	0d b6       	in	r0, 0x3d	; 61
    1ad8:	0d 92       	st	X+, r0
    1ada:	0e b6       	in	r0, 0x3e	; 62
    1adc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1ade:	0e 94 da 22 	call	0x45b4	; 0x45b4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1ae2:	a0 91 8d 06 	lds	r26, 0x068D
    1ae6:	b0 91 8e 06 	lds	r27, 0x068E
    1aea:	cd 91       	ld	r28, X+
    1aec:	cd bf       	out	0x3d, r28	; 61
    1aee:	dd 91       	ld	r29, X+
    1af0:	de bf       	out	0x3e, r29	; 62
    1af2:	ff 91       	pop	r31
    1af4:	ef 91       	pop	r30
    1af6:	df 91       	pop	r29
    1af8:	cf 91       	pop	r28
    1afa:	bf 91       	pop	r27
    1afc:	af 91       	pop	r26
    1afe:	9f 91       	pop	r25
    1b00:	8f 91       	pop	r24
    1b02:	7f 91       	pop	r23
    1b04:	6f 91       	pop	r22
    1b06:	5f 91       	pop	r21
    1b08:	4f 91       	pop	r20
    1b0a:	3f 91       	pop	r19
    1b0c:	2f 91       	pop	r18
    1b0e:	1f 91       	pop	r17
    1b10:	0f 91       	pop	r16
    1b12:	ff 90       	pop	r15
    1b14:	ef 90       	pop	r14
    1b16:	df 90       	pop	r13
    1b18:	cf 90       	pop	r12
    1b1a:	bf 90       	pop	r11
    1b1c:	af 90       	pop	r10
    1b1e:	9f 90       	pop	r9
    1b20:	8f 90       	pop	r8
    1b22:	7f 90       	pop	r7
    1b24:	6f 90       	pop	r6
    1b26:	5f 90       	pop	r5
    1b28:	4f 90       	pop	r4
    1b2a:	3f 90       	pop	r3
    1b2c:	2f 90       	pop	r2
    1b2e:	1f 90       	pop	r1
    1b30:	0f 90       	pop	r0
    1b32:	0f be       	out	0x3f, r0	; 63
    1b34:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1b36:	08 95       	ret

00001b38 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1b38:	0f 92       	push	r0
    1b3a:	0f b6       	in	r0, 0x3f	; 63
    1b3c:	f8 94       	cli
    1b3e:	0f 92       	push	r0
    1b40:	1f 92       	push	r1
    1b42:	11 24       	eor	r1, r1
    1b44:	2f 92       	push	r2
    1b46:	3f 92       	push	r3
    1b48:	4f 92       	push	r4
    1b4a:	5f 92       	push	r5
    1b4c:	6f 92       	push	r6
    1b4e:	7f 92       	push	r7
    1b50:	8f 92       	push	r8
    1b52:	9f 92       	push	r9
    1b54:	af 92       	push	r10
    1b56:	bf 92       	push	r11
    1b58:	cf 92       	push	r12
    1b5a:	df 92       	push	r13
    1b5c:	ef 92       	push	r14
    1b5e:	ff 92       	push	r15
    1b60:	0f 93       	push	r16
    1b62:	1f 93       	push	r17
    1b64:	2f 93       	push	r18
    1b66:	3f 93       	push	r19
    1b68:	4f 93       	push	r20
    1b6a:	5f 93       	push	r21
    1b6c:	6f 93       	push	r22
    1b6e:	7f 93       	push	r23
    1b70:	8f 93       	push	r24
    1b72:	9f 93       	push	r25
    1b74:	af 93       	push	r26
    1b76:	bf 93       	push	r27
    1b78:	cf 93       	push	r28
    1b7a:	df 93       	push	r29
    1b7c:	ef 93       	push	r30
    1b7e:	ff 93       	push	r31
    1b80:	a0 91 8d 06 	lds	r26, 0x068D
    1b84:	b0 91 8e 06 	lds	r27, 0x068E
    1b88:	0d b6       	in	r0, 0x3d	; 61
    1b8a:	0d 92       	st	X+, r0
    1b8c:	0e b6       	in	r0, 0x3e	; 62
    1b8e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1b90:	0e 94 f5 21 	call	0x43ea	; 0x43ea <xTaskIncrementTick>
    1b94:	88 23       	and	r24, r24
    1b96:	11 f0       	breq	.+4      	; 0x1b9c <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1b98:	0e 94 da 22 	call	0x45b4	; 0x45b4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1b9c:	a0 91 8d 06 	lds	r26, 0x068D
    1ba0:	b0 91 8e 06 	lds	r27, 0x068E
    1ba4:	cd 91       	ld	r28, X+
    1ba6:	cd bf       	out	0x3d, r28	; 61
    1ba8:	dd 91       	ld	r29, X+
    1baa:	de bf       	out	0x3e, r29	; 62
    1bac:	ff 91       	pop	r31
    1bae:	ef 91       	pop	r30
    1bb0:	df 91       	pop	r29
    1bb2:	cf 91       	pop	r28
    1bb4:	bf 91       	pop	r27
    1bb6:	af 91       	pop	r26
    1bb8:	9f 91       	pop	r25
    1bba:	8f 91       	pop	r24
    1bbc:	7f 91       	pop	r23
    1bbe:	6f 91       	pop	r22
    1bc0:	5f 91       	pop	r21
    1bc2:	4f 91       	pop	r20
    1bc4:	3f 91       	pop	r19
    1bc6:	2f 91       	pop	r18
    1bc8:	1f 91       	pop	r17
    1bca:	0f 91       	pop	r16
    1bcc:	ff 90       	pop	r15
    1bce:	ef 90       	pop	r14
    1bd0:	df 90       	pop	r13
    1bd2:	cf 90       	pop	r12
    1bd4:	bf 90       	pop	r11
    1bd6:	af 90       	pop	r10
    1bd8:	9f 90       	pop	r9
    1bda:	8f 90       	pop	r8
    1bdc:	7f 90       	pop	r7
    1bde:	6f 90       	pop	r6
    1be0:	5f 90       	pop	r5
    1be2:	4f 90       	pop	r4
    1be4:	3f 90       	pop	r3
    1be6:	2f 90       	pop	r2
    1be8:	1f 90       	pop	r1
    1bea:	0f 90       	pop	r0
    1bec:	0f be       	out	0x3f, r0	; 63
    1bee:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1bf0:	08 95       	ret

00001bf2 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1bf2:	df 93       	push	r29
    1bf4:	cf 93       	push	r28
    1bf6:	00 d0       	rcall	.+0      	; 0x1bf8 <prvSetupTimerInterrupt+0x6>
    1bf8:	00 d0       	rcall	.+0      	; 0x1bfa <prvSetupTimerInterrupt+0x8>
    1bfa:	00 d0       	rcall	.+0      	; 0x1bfc <prvSetupTimerInterrupt+0xa>
    1bfc:	cd b7       	in	r28, 0x3d	; 61
    1bfe:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1c00:	80 e4       	ldi	r24, 0x40	; 64
    1c02:	9f e1       	ldi	r25, 0x1F	; 31
    1c04:	a0 e0       	ldi	r26, 0x00	; 0
    1c06:	b0 e0       	ldi	r27, 0x00	; 0
    1c08:	8b 83       	std	Y+3, r24	; 0x03
    1c0a:	9c 83       	std	Y+4, r25	; 0x04
    1c0c:	ad 83       	std	Y+5, r26	; 0x05
    1c0e:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1c10:	8b 81       	ldd	r24, Y+3	; 0x03
    1c12:	9c 81       	ldd	r25, Y+4	; 0x04
    1c14:	ad 81       	ldd	r26, Y+5	; 0x05
    1c16:	be 81       	ldd	r27, Y+6	; 0x06
    1c18:	68 94       	set
    1c1a:	15 f8       	bld	r1, 5
    1c1c:	b6 95       	lsr	r27
    1c1e:	a7 95       	ror	r26
    1c20:	97 95       	ror	r25
    1c22:	87 95       	ror	r24
    1c24:	16 94       	lsr	r1
    1c26:	d1 f7       	brne	.-12     	; 0x1c1c <prvSetupTimerInterrupt+0x2a>
    1c28:	8b 83       	std	Y+3, r24	; 0x03
    1c2a:	9c 83       	std	Y+4, r25	; 0x04
    1c2c:	ad 83       	std	Y+5, r26	; 0x05
    1c2e:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1c30:	8b 81       	ldd	r24, Y+3	; 0x03
    1c32:	9c 81       	ldd	r25, Y+4	; 0x04
    1c34:	ad 81       	ldd	r26, Y+5	; 0x05
    1c36:	be 81       	ldd	r27, Y+6	; 0x06
    1c38:	01 97       	sbiw	r24, 0x01	; 1
    1c3a:	a1 09       	sbc	r26, r1
    1c3c:	b1 09       	sbc	r27, r1
    1c3e:	8b 83       	std	Y+3, r24	; 0x03
    1c40:	9c 83       	std	Y+4, r25	; 0x04
    1c42:	ad 83       	std	Y+5, r26	; 0x05
    1c44:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1c46:	8b 81       	ldd	r24, Y+3	; 0x03
    1c48:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1c4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c4e:	ad 81       	ldd	r26, Y+5	; 0x05
    1c50:	be 81       	ldd	r27, Y+6	; 0x06
    1c52:	89 2f       	mov	r24, r25
    1c54:	9a 2f       	mov	r25, r26
    1c56:	ab 2f       	mov	r26, r27
    1c58:	bb 27       	eor	r27, r27
    1c5a:	8b 83       	std	Y+3, r24	; 0x03
    1c5c:	9c 83       	std	Y+4, r25	; 0x04
    1c5e:	ad 83       	std	Y+5, r26	; 0x05
    1c60:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1c62:	8b 81       	ldd	r24, Y+3	; 0x03
    1c64:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1c66:	eb e4       	ldi	r30, 0x4B	; 75
    1c68:	f0 e0       	ldi	r31, 0x00	; 0
    1c6a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c6c:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1c6e:	ea e4       	ldi	r30, 0x4A	; 74
    1c70:	f0 e0       	ldi	r31, 0x00	; 0
    1c72:	89 81       	ldd	r24, Y+1	; 0x01
    1c74:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1c76:	8b e0       	ldi	r24, 0x0B	; 11
    1c78:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1c7a:	ee e4       	ldi	r30, 0x4E	; 78
    1c7c:	f0 e0       	ldi	r31, 0x00	; 0
    1c7e:	89 81       	ldd	r24, Y+1	; 0x01
    1c80:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1c82:	e9 e5       	ldi	r30, 0x59	; 89
    1c84:	f0 e0       	ldi	r31, 0x00	; 0
    1c86:	80 81       	ld	r24, Z
    1c88:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1c8a:	89 81       	ldd	r24, Y+1	; 0x01
    1c8c:	80 61       	ori	r24, 0x10	; 16
    1c8e:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1c90:	e9 e5       	ldi	r30, 0x59	; 89
    1c92:	f0 e0       	ldi	r31, 0x00	; 0
    1c94:	89 81       	ldd	r24, Y+1	; 0x01
    1c96:	80 83       	st	Z, r24
}
    1c98:	26 96       	adiw	r28, 0x06	; 6
    1c9a:	0f b6       	in	r0, 0x3f	; 63
    1c9c:	f8 94       	cli
    1c9e:	de bf       	out	0x3e, r29	; 62
    1ca0:	0f be       	out	0x3f, r0	; 63
    1ca2:	cd bf       	out	0x3d, r28	; 61
    1ca4:	cf 91       	pop	r28
    1ca6:	df 91       	pop	r29
    1ca8:	08 95       	ret

00001caa <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1caa:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1cae:	18 95       	reti

00001cb0 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1cb0:	df 93       	push	r29
    1cb2:	cf 93       	push	r28
    1cb4:	00 d0       	rcall	.+0      	; 0x1cb6 <xQueueGenericReset+0x6>
    1cb6:	00 d0       	rcall	.+0      	; 0x1cb8 <xQueueGenericReset+0x8>
    1cb8:	0f 92       	push	r0
    1cba:	cd b7       	in	r28, 0x3d	; 61
    1cbc:	de b7       	in	r29, 0x3e	; 62
    1cbe:	9c 83       	std	Y+4, r25	; 0x04
    1cc0:	8b 83       	std	Y+3, r24	; 0x03
    1cc2:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1cc4:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc6:	9c 81       	ldd	r25, Y+4	; 0x04
    1cc8:	9a 83       	std	Y+2, r25	; 0x02
    1cca:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1ccc:	0f b6       	in	r0, 0x3f	; 63
    1cce:	f8 94       	cli
    1cd0:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1cd2:	e9 81       	ldd	r30, Y+1	; 0x01
    1cd4:	fa 81       	ldd	r31, Y+2	; 0x02
    1cd6:	40 81       	ld	r20, Z
    1cd8:	51 81       	ldd	r21, Z+1	; 0x01
    1cda:	e9 81       	ldd	r30, Y+1	; 0x01
    1cdc:	fa 81       	ldd	r31, Y+2	; 0x02
    1cde:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ce0:	28 2f       	mov	r18, r24
    1ce2:	30 e0       	ldi	r19, 0x00	; 0
    1ce4:	e9 81       	ldd	r30, Y+1	; 0x01
    1ce6:	fa 81       	ldd	r31, Y+2	; 0x02
    1ce8:	84 8d       	ldd	r24, Z+28	; 0x1c
    1cea:	88 2f       	mov	r24, r24
    1cec:	90 e0       	ldi	r25, 0x00	; 0
    1cee:	bc 01       	movw	r22, r24
    1cf0:	26 9f       	mul	r18, r22
    1cf2:	c0 01       	movw	r24, r0
    1cf4:	27 9f       	mul	r18, r23
    1cf6:	90 0d       	add	r25, r0
    1cf8:	36 9f       	mul	r19, r22
    1cfa:	90 0d       	add	r25, r0
    1cfc:	11 24       	eor	r1, r1
    1cfe:	84 0f       	add	r24, r20
    1d00:	95 1f       	adc	r25, r21
    1d02:	e9 81       	ldd	r30, Y+1	; 0x01
    1d04:	fa 81       	ldd	r31, Y+2	; 0x02
    1d06:	95 83       	std	Z+5, r25	; 0x05
    1d08:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1d0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d0e:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1d10:	e9 81       	ldd	r30, Y+1	; 0x01
    1d12:	fa 81       	ldd	r31, Y+2	; 0x02
    1d14:	80 81       	ld	r24, Z
    1d16:	91 81       	ldd	r25, Z+1	; 0x01
    1d18:	e9 81       	ldd	r30, Y+1	; 0x01
    1d1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d1c:	93 83       	std	Z+3, r25	; 0x03
    1d1e:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1d20:	e9 81       	ldd	r30, Y+1	; 0x01
    1d22:	fa 81       	ldd	r31, Y+2	; 0x02
    1d24:	40 81       	ld	r20, Z
    1d26:	51 81       	ldd	r21, Z+1	; 0x01
    1d28:	e9 81       	ldd	r30, Y+1	; 0x01
    1d2a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d2c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d2e:	88 2f       	mov	r24, r24
    1d30:	90 e0       	ldi	r25, 0x00	; 0
    1d32:	9c 01       	movw	r18, r24
    1d34:	21 50       	subi	r18, 0x01	; 1
    1d36:	30 40       	sbci	r19, 0x00	; 0
    1d38:	e9 81       	ldd	r30, Y+1	; 0x01
    1d3a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d3c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d3e:	88 2f       	mov	r24, r24
    1d40:	90 e0       	ldi	r25, 0x00	; 0
    1d42:	bc 01       	movw	r22, r24
    1d44:	26 9f       	mul	r18, r22
    1d46:	c0 01       	movw	r24, r0
    1d48:	27 9f       	mul	r18, r23
    1d4a:	90 0d       	add	r25, r0
    1d4c:	36 9f       	mul	r19, r22
    1d4e:	90 0d       	add	r25, r0
    1d50:	11 24       	eor	r1, r1
    1d52:	84 0f       	add	r24, r20
    1d54:	95 1f       	adc	r25, r21
    1d56:	e9 81       	ldd	r30, Y+1	; 0x01
    1d58:	fa 81       	ldd	r31, Y+2	; 0x02
    1d5a:	97 83       	std	Z+7, r25	; 0x07
    1d5c:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1d5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d60:	fa 81       	ldd	r31, Y+2	; 0x02
    1d62:	8f ef       	ldi	r24, 0xFF	; 255
    1d64:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1d66:	e9 81       	ldd	r30, Y+1	; 0x01
    1d68:	fa 81       	ldd	r31, Y+2	; 0x02
    1d6a:	8f ef       	ldi	r24, 0xFF	; 255
    1d6c:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1d6e:	8d 81       	ldd	r24, Y+5	; 0x05
    1d70:	88 23       	and	r24, r24
    1d72:	79 f4       	brne	.+30     	; 0x1d92 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d74:	e9 81       	ldd	r30, Y+1	; 0x01
    1d76:	fa 81       	ldd	r31, Y+2	; 0x02
    1d78:	80 85       	ldd	r24, Z+8	; 0x08
    1d7a:	88 23       	and	r24, r24
    1d7c:	a1 f0       	breq	.+40     	; 0x1da6 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d7e:	89 81       	ldd	r24, Y+1	; 0x01
    1d80:	9a 81       	ldd	r25, Y+2	; 0x02
    1d82:	08 96       	adiw	r24, 0x08	; 8
    1d84:	0e 94 99 23 	call	0x4732	; 0x4732 <xTaskRemoveFromEventList>
    1d88:	88 23       	and	r24, r24
    1d8a:	69 f0       	breq	.+26     	; 0x1da6 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1d8c:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
    1d90:	0a c0       	rjmp	.+20     	; 0x1da6 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1d92:	89 81       	ldd	r24, Y+1	; 0x01
    1d94:	9a 81       	ldd	r25, Y+2	; 0x02
    1d96:	08 96       	adiw	r24, 0x08	; 8
    1d98:	0e 94 31 0a 	call	0x1462	; 0x1462 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1d9c:	89 81       	ldd	r24, Y+1	; 0x01
    1d9e:	9a 81       	ldd	r25, Y+2	; 0x02
    1da0:	41 96       	adiw	r24, 0x11	; 17
    1da2:	0e 94 31 0a 	call	0x1462	; 0x1462 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1da6:	0f 90       	pop	r0
    1da8:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1daa:	81 e0       	ldi	r24, 0x01	; 1
}
    1dac:	0f 90       	pop	r0
    1dae:	0f 90       	pop	r0
    1db0:	0f 90       	pop	r0
    1db2:	0f 90       	pop	r0
    1db4:	0f 90       	pop	r0
    1db6:	cf 91       	pop	r28
    1db8:	df 91       	pop	r29
    1dba:	08 95       	ret

00001dbc <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1dbc:	0f 93       	push	r16
    1dbe:	1f 93       	push	r17
    1dc0:	df 93       	push	r29
    1dc2:	cf 93       	push	r28
    1dc4:	cd b7       	in	r28, 0x3d	; 61
    1dc6:	de b7       	in	r29, 0x3e	; 62
    1dc8:	29 97       	sbiw	r28, 0x09	; 9
    1dca:	0f b6       	in	r0, 0x3f	; 63
    1dcc:	f8 94       	cli
    1dce:	de bf       	out	0x3e, r29	; 62
    1dd0:	0f be       	out	0x3f, r0	; 63
    1dd2:	cd bf       	out	0x3d, r28	; 61
    1dd4:	8f 83       	std	Y+7, r24	; 0x07
    1dd6:	68 87       	std	Y+8, r22	; 0x08
    1dd8:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1dda:	88 85       	ldd	r24, Y+8	; 0x08
    1ddc:	88 23       	and	r24, r24
    1dde:	19 f4       	brne	.+6      	; 0x1de6 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1de0:	1c 82       	std	Y+4, r1	; 0x04
    1de2:	1b 82       	std	Y+3, r1	; 0x03
    1de4:	10 c0       	rjmp	.+32     	; 0x1e06 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1de6:	8f 81       	ldd	r24, Y+7	; 0x07
    1de8:	28 2f       	mov	r18, r24
    1dea:	30 e0       	ldi	r19, 0x00	; 0
    1dec:	88 85       	ldd	r24, Y+8	; 0x08
    1dee:	88 2f       	mov	r24, r24
    1df0:	90 e0       	ldi	r25, 0x00	; 0
    1df2:	ac 01       	movw	r20, r24
    1df4:	24 9f       	mul	r18, r20
    1df6:	c0 01       	movw	r24, r0
    1df8:	25 9f       	mul	r18, r21
    1dfa:	90 0d       	add	r25, r0
    1dfc:	34 9f       	mul	r19, r20
    1dfe:	90 0d       	add	r25, r0
    1e00:	11 24       	eor	r1, r1
    1e02:	9c 83       	std	Y+4, r25	; 0x04
    1e04:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1e06:	8b 81       	ldd	r24, Y+3	; 0x03
    1e08:	9c 81       	ldd	r25, Y+4	; 0x04
    1e0a:	4f 96       	adiw	r24, 0x1f	; 31
    1e0c:	0e 94 1b 07 	call	0xe36	; 0xe36 <pvPortMalloc>
    1e10:	9e 83       	std	Y+6, r25	; 0x06
    1e12:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    1e14:	8d 81       	ldd	r24, Y+5	; 0x05
    1e16:	9e 81       	ldd	r25, Y+6	; 0x06
    1e18:	00 97       	sbiw	r24, 0x00	; 0
    1e1a:	a1 f0       	breq	.+40     	; 0x1e44 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1e1c:	8d 81       	ldd	r24, Y+5	; 0x05
    1e1e:	9e 81       	ldd	r25, Y+6	; 0x06
    1e20:	9a 83       	std	Y+2, r25	; 0x02
    1e22:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e24:	89 81       	ldd	r24, Y+1	; 0x01
    1e26:	9a 81       	ldd	r25, Y+2	; 0x02
    1e28:	4f 96       	adiw	r24, 0x1f	; 31
    1e2a:	9a 83       	std	Y+2, r25	; 0x02
    1e2c:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1e2e:	29 81       	ldd	r18, Y+1	; 0x01
    1e30:	3a 81       	ldd	r19, Y+2	; 0x02
    1e32:	ed 81       	ldd	r30, Y+5	; 0x05
    1e34:	fe 81       	ldd	r31, Y+6	; 0x06
    1e36:	8f 81       	ldd	r24, Y+7	; 0x07
    1e38:	68 85       	ldd	r22, Y+8	; 0x08
    1e3a:	a9 01       	movw	r20, r18
    1e3c:	29 85       	ldd	r18, Y+9	; 0x09
    1e3e:	8f 01       	movw	r16, r30
    1e40:	0e 94 2f 0f 	call	0x1e5e	; 0x1e5e <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    1e44:	8d 81       	ldd	r24, Y+5	; 0x05
    1e46:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1e48:	29 96       	adiw	r28, 0x09	; 9
    1e4a:	0f b6       	in	r0, 0x3f	; 63
    1e4c:	f8 94       	cli
    1e4e:	de bf       	out	0x3e, r29	; 62
    1e50:	0f be       	out	0x3f, r0	; 63
    1e52:	cd bf       	out	0x3d, r28	; 61
    1e54:	cf 91       	pop	r28
    1e56:	df 91       	pop	r29
    1e58:	1f 91       	pop	r17
    1e5a:	0f 91       	pop	r16
    1e5c:	08 95       	ret

00001e5e <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    1e5e:	0f 93       	push	r16
    1e60:	1f 93       	push	r17
    1e62:	df 93       	push	r29
    1e64:	cf 93       	push	r28
    1e66:	cd b7       	in	r28, 0x3d	; 61
    1e68:	de b7       	in	r29, 0x3e	; 62
    1e6a:	27 97       	sbiw	r28, 0x07	; 7
    1e6c:	0f b6       	in	r0, 0x3f	; 63
    1e6e:	f8 94       	cli
    1e70:	de bf       	out	0x3e, r29	; 62
    1e72:	0f be       	out	0x3f, r0	; 63
    1e74:	cd bf       	out	0x3d, r28	; 61
    1e76:	89 83       	std	Y+1, r24	; 0x01
    1e78:	6a 83       	std	Y+2, r22	; 0x02
    1e7a:	5c 83       	std	Y+4, r21	; 0x04
    1e7c:	4b 83       	std	Y+3, r20	; 0x03
    1e7e:	2d 83       	std	Y+5, r18	; 0x05
    1e80:	1f 83       	std	Y+7, r17	; 0x07
    1e82:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1e84:	8a 81       	ldd	r24, Y+2	; 0x02
    1e86:	88 23       	and	r24, r24
    1e88:	39 f4       	brne	.+14     	; 0x1e98 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1e8a:	8e 81       	ldd	r24, Y+6	; 0x06
    1e8c:	9f 81       	ldd	r25, Y+7	; 0x07
    1e8e:	ee 81       	ldd	r30, Y+6	; 0x06
    1e90:	ff 81       	ldd	r31, Y+7	; 0x07
    1e92:	91 83       	std	Z+1, r25	; 0x01
    1e94:	80 83       	st	Z, r24
    1e96:	06 c0       	rjmp	.+12     	; 0x1ea4 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1e98:	8b 81       	ldd	r24, Y+3	; 0x03
    1e9a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e9c:	ee 81       	ldd	r30, Y+6	; 0x06
    1e9e:	ff 81       	ldd	r31, Y+7	; 0x07
    1ea0:	91 83       	std	Z+1, r25	; 0x01
    1ea2:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1ea4:	ee 81       	ldd	r30, Y+6	; 0x06
    1ea6:	ff 81       	ldd	r31, Y+7	; 0x07
    1ea8:	89 81       	ldd	r24, Y+1	; 0x01
    1eaa:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1eac:	ee 81       	ldd	r30, Y+6	; 0x06
    1eae:	ff 81       	ldd	r31, Y+7	; 0x07
    1eb0:	8a 81       	ldd	r24, Y+2	; 0x02
    1eb2:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1eb4:	8e 81       	ldd	r24, Y+6	; 0x06
    1eb6:	9f 81       	ldd	r25, Y+7	; 0x07
    1eb8:	61 e0       	ldi	r22, 0x01	; 1
    1eba:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1ebe:	27 96       	adiw	r28, 0x07	; 7
    1ec0:	0f b6       	in	r0, 0x3f	; 63
    1ec2:	f8 94       	cli
    1ec4:	de bf       	out	0x3e, r29	; 62
    1ec6:	0f be       	out	0x3f, r0	; 63
    1ec8:	cd bf       	out	0x3d, r28	; 61
    1eca:	cf 91       	pop	r28
    1ecc:	df 91       	pop	r29
    1ece:	1f 91       	pop	r17
    1ed0:	0f 91       	pop	r16
    1ed2:	08 95       	ret

00001ed4 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1ed4:	df 93       	push	r29
    1ed6:	cf 93       	push	r28
    1ed8:	cd b7       	in	r28, 0x3d	; 61
    1eda:	de b7       	in	r29, 0x3e	; 62
    1edc:	2f 97       	sbiw	r28, 0x0f	; 15
    1ede:	0f b6       	in	r0, 0x3f	; 63
    1ee0:	f8 94       	cli
    1ee2:	de bf       	out	0x3e, r29	; 62
    1ee4:	0f be       	out	0x3f, r0	; 63
    1ee6:	cd bf       	out	0x3d, r28	; 61
    1ee8:	99 87       	std	Y+9, r25	; 0x09
    1eea:	88 87       	std	Y+8, r24	; 0x08
    1eec:	7b 87       	std	Y+11, r23	; 0x0b
    1eee:	6a 87       	std	Y+10, r22	; 0x0a
    1ef0:	5d 87       	std	Y+13, r21	; 0x0d
    1ef2:	4c 87       	std	Y+12, r20	; 0x0c
    1ef4:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1ef6:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1ef8:	88 85       	ldd	r24, Y+8	; 0x08
    1efa:	99 85       	ldd	r25, Y+9	; 0x09
    1efc:	9a 83       	std	Y+2, r25	; 0x02
    1efe:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1f00:	0f b6       	in	r0, 0x3f	; 63
    1f02:	f8 94       	cli
    1f04:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1f06:	e9 81       	ldd	r30, Y+1	; 0x01
    1f08:	fa 81       	ldd	r31, Y+2	; 0x02
    1f0a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f0c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f0e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f10:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f12:	98 17       	cp	r25, r24
    1f14:	18 f0       	brcs	.+6      	; 0x1f1c <xQueueGenericSend+0x48>
    1f16:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f18:	82 30       	cpi	r24, 0x02	; 2
    1f1a:	11 f5       	brne	.+68     	; 0x1f60 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1f1c:	89 81       	ldd	r24, Y+1	; 0x01
    1f1e:	9a 81       	ldd	r25, Y+2	; 0x02
    1f20:	2a 85       	ldd	r18, Y+10	; 0x0a
    1f22:	3b 85       	ldd	r19, Y+11	; 0x0b
    1f24:	b9 01       	movw	r22, r18
    1f26:	4e 85       	ldd	r20, Y+14	; 0x0e
    1f28:	0e 94 bc 13 	call	0x2778	; 0x2778 <prvCopyDataToQueue>
    1f2c:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1f30:	fa 81       	ldd	r31, Y+2	; 0x02
    1f32:	81 89       	ldd	r24, Z+17	; 0x11
    1f34:	88 23       	and	r24, r24
    1f36:	51 f0       	breq	.+20     	; 0x1f4c <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f38:	89 81       	ldd	r24, Y+1	; 0x01
    1f3a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f3c:	41 96       	adiw	r24, 0x11	; 17
    1f3e:	0e 94 99 23 	call	0x4732	; 0x4732 <xTaskRemoveFromEventList>
    1f42:	88 23       	and	r24, r24
    1f44:	41 f0       	breq	.+16     	; 0x1f56 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1f46:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
    1f4a:	05 c0       	rjmp	.+10     	; 0x1f56 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1f4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f4e:	88 23       	and	r24, r24
    1f50:	11 f0       	breq	.+4      	; 0x1f56 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1f52:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1f56:	0f 90       	pop	r0
    1f58:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f5a:	81 e0       	ldi	r24, 0x01	; 1
    1f5c:	8f 87       	std	Y+15, r24	; 0x0f
    1f5e:	5c c0       	rjmp	.+184    	; 0x2018 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1f60:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f62:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f64:	00 97       	sbiw	r24, 0x00	; 0
    1f66:	21 f4       	brne	.+8      	; 0x1f70 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f68:	0f 90       	pop	r0
    1f6a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1f6c:	1f 86       	std	Y+15, r1	; 0x0f
    1f6e:	54 c0       	rjmp	.+168    	; 0x2018 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f70:	8c 81       	ldd	r24, Y+4	; 0x04
    1f72:	88 23       	and	r24, r24
    1f74:	31 f4       	brne	.+12     	; 0x1f82 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1f76:	ce 01       	movw	r24, r28
    1f78:	05 96       	adiw	r24, 0x05	; 5
    1f7a:	0e 94 7f 24 	call	0x48fe	; 0x48fe <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1f7e:	81 e0       	ldi	r24, 0x01	; 1
    1f80:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1f82:	0f 90       	pop	r0
    1f84:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f86:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f8a:	0f b6       	in	r0, 0x3f	; 63
    1f8c:	f8 94       	cli
    1f8e:	0f 92       	push	r0
    1f90:	e9 81       	ldd	r30, Y+1	; 0x01
    1f92:	fa 81       	ldd	r31, Y+2	; 0x02
    1f94:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f96:	8f 3f       	cpi	r24, 0xFF	; 255
    1f98:	19 f4       	brne	.+6      	; 0x1fa0 <xQueueGenericSend+0xcc>
    1f9a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f9c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f9e:	15 8e       	std	Z+29, r1	; 0x1d
    1fa0:	e9 81       	ldd	r30, Y+1	; 0x01
    1fa2:	fa 81       	ldd	r31, Y+2	; 0x02
    1fa4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fa6:	8f 3f       	cpi	r24, 0xFF	; 255
    1fa8:	19 f4       	brne	.+6      	; 0x1fb0 <xQueueGenericSend+0xdc>
    1faa:	e9 81       	ldd	r30, Y+1	; 0x01
    1fac:	fa 81       	ldd	r31, Y+2	; 0x02
    1fae:	16 8e       	std	Z+30, r1	; 0x1e
    1fb0:	0f 90       	pop	r0
    1fb2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1fb4:	ce 01       	movw	r24, r28
    1fb6:	05 96       	adiw	r24, 0x05	; 5
    1fb8:	9e 01       	movw	r18, r28
    1fba:	24 5f       	subi	r18, 0xF4	; 244
    1fbc:	3f 4f       	sbci	r19, 0xFF	; 255
    1fbe:	b9 01       	movw	r22, r18
    1fc0:	0e 94 98 24 	call	0x4930	; 0x4930 <xTaskCheckForTimeOut>
    1fc4:	88 23       	and	r24, r24
    1fc6:	09 f5       	brne	.+66     	; 0x200a <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1fc8:	89 81       	ldd	r24, Y+1	; 0x01
    1fca:	9a 81       	ldd	r25, Y+2	; 0x02
    1fcc:	0e 94 38 15 	call	0x2a70	; 0x2a70 <prvIsQueueFull>
    1fd0:	88 23       	and	r24, r24
    1fd2:	a1 f0       	breq	.+40     	; 0x1ffc <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1fd4:	89 81       	ldd	r24, Y+1	; 0x01
    1fd6:	9a 81       	ldd	r25, Y+2	; 0x02
    1fd8:	08 96       	adiw	r24, 0x08	; 8
    1fda:	2c 85       	ldd	r18, Y+12	; 0x0c
    1fdc:	3d 85       	ldd	r19, Y+13	; 0x0d
    1fde:	b9 01       	movw	r22, r18
    1fe0:	0e 94 47 23 	call	0x468e	; 0x468e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1fe4:	89 81       	ldd	r24, Y+1	; 0x01
    1fe6:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe8:	0e 94 a9 14 	call	0x2952	; 0x2952 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1fec:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
    1ff0:	88 23       	and	r24, r24
    1ff2:	09 f0       	breq	.+2      	; 0x1ff6 <xQueueGenericSend+0x122>
    1ff4:	85 cf       	rjmp	.-246    	; 0x1f00 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1ff6:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
    1ffa:	82 cf       	rjmp	.-252    	; 0x1f00 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1ffc:	89 81       	ldd	r24, Y+1	; 0x01
    1ffe:	9a 81       	ldd	r25, Y+2	; 0x02
    2000:	0e 94 a9 14 	call	0x2952	; 0x2952 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2004:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
    2008:	7b cf       	rjmp	.-266    	; 0x1f00 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    200a:	89 81       	ldd	r24, Y+1	; 0x01
    200c:	9a 81       	ldd	r25, Y+2	; 0x02
    200e:	0e 94 a9 14 	call	0x2952	; 0x2952 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2012:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2016:	1f 86       	std	Y+15, r1	; 0x0f
    2018:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    201a:	2f 96       	adiw	r28, 0x0f	; 15
    201c:	0f b6       	in	r0, 0x3f	; 63
    201e:	f8 94       	cli
    2020:	de bf       	out	0x3e, r29	; 62
    2022:	0f be       	out	0x3f, r0	; 63
    2024:	cd bf       	out	0x3d, r28	; 61
    2026:	cf 91       	pop	r28
    2028:	df 91       	pop	r29
    202a:	08 95       	ret

0000202c <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    202c:	df 93       	push	r29
    202e:	cf 93       	push	r28
    2030:	cd b7       	in	r28, 0x3d	; 61
    2032:	de b7       	in	r29, 0x3e	; 62
    2034:	2c 97       	sbiw	r28, 0x0c	; 12
    2036:	0f b6       	in	r0, 0x3f	; 63
    2038:	f8 94       	cli
    203a:	de bf       	out	0x3e, r29	; 62
    203c:	0f be       	out	0x3f, r0	; 63
    203e:	cd bf       	out	0x3d, r28	; 61
    2040:	9f 83       	std	Y+7, r25	; 0x07
    2042:	8e 83       	std	Y+6, r24	; 0x06
    2044:	79 87       	std	Y+9, r23	; 0x09
    2046:	68 87       	std	Y+8, r22	; 0x08
    2048:	5b 87       	std	Y+11, r21	; 0x0b
    204a:	4a 87       	std	Y+10, r20	; 0x0a
    204c:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    204e:	8e 81       	ldd	r24, Y+6	; 0x06
    2050:	9f 81       	ldd	r25, Y+7	; 0x07
    2052:	9b 83       	std	Y+3, r25	; 0x03
    2054:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2056:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2058:	ea 81       	ldd	r30, Y+2	; 0x02
    205a:	fb 81       	ldd	r31, Y+3	; 0x03
    205c:	92 8d       	ldd	r25, Z+26	; 0x1a
    205e:	ea 81       	ldd	r30, Y+2	; 0x02
    2060:	fb 81       	ldd	r31, Y+3	; 0x03
    2062:	83 8d       	ldd	r24, Z+27	; 0x1b
    2064:	98 17       	cp	r25, r24
    2066:	18 f0       	brcs	.+6      	; 0x206e <xQueueGenericSendFromISR+0x42>
    2068:	8c 85       	ldd	r24, Y+12	; 0x0c
    206a:	82 30       	cpi	r24, 0x02	; 2
    206c:	61 f5       	brne	.+88     	; 0x20c6 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    206e:	ea 81       	ldd	r30, Y+2	; 0x02
    2070:	fb 81       	ldd	r31, Y+3	; 0x03
    2072:	86 8d       	ldd	r24, Z+30	; 0x1e
    2074:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2076:	8a 81       	ldd	r24, Y+2	; 0x02
    2078:	9b 81       	ldd	r25, Y+3	; 0x03
    207a:	28 85       	ldd	r18, Y+8	; 0x08
    207c:	39 85       	ldd	r19, Y+9	; 0x09
    207e:	b9 01       	movw	r22, r18
    2080:	4c 85       	ldd	r20, Y+12	; 0x0c
    2082:	0e 94 bc 13 	call	0x2778	; 0x2778 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2086:	89 81       	ldd	r24, Y+1	; 0x01
    2088:	8f 3f       	cpi	r24, 0xFF	; 255
    208a:	a9 f4       	brne	.+42     	; 0x20b6 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    208c:	ea 81       	ldd	r30, Y+2	; 0x02
    208e:	fb 81       	ldd	r31, Y+3	; 0x03
    2090:	81 89       	ldd	r24, Z+17	; 0x11
    2092:	88 23       	and	r24, r24
    2094:	a9 f0       	breq	.+42     	; 0x20c0 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2096:	8a 81       	ldd	r24, Y+2	; 0x02
    2098:	9b 81       	ldd	r25, Y+3	; 0x03
    209a:	41 96       	adiw	r24, 0x11	; 17
    209c:	0e 94 99 23 	call	0x4732	; 0x4732 <xTaskRemoveFromEventList>
    20a0:	88 23       	and	r24, r24
    20a2:	71 f0       	breq	.+28     	; 0x20c0 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    20a4:	8a 85       	ldd	r24, Y+10	; 0x0a
    20a6:	9b 85       	ldd	r25, Y+11	; 0x0b
    20a8:	00 97       	sbiw	r24, 0x00	; 0
    20aa:	51 f0       	breq	.+20     	; 0x20c0 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    20ac:	ea 85       	ldd	r30, Y+10	; 0x0a
    20ae:	fb 85       	ldd	r31, Y+11	; 0x0b
    20b0:	81 e0       	ldi	r24, 0x01	; 1
    20b2:	80 83       	st	Z, r24
    20b4:	05 c0       	rjmp	.+10     	; 0x20c0 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    20b6:	89 81       	ldd	r24, Y+1	; 0x01
    20b8:	8f 5f       	subi	r24, 0xFF	; 255
    20ba:	ea 81       	ldd	r30, Y+2	; 0x02
    20bc:	fb 81       	ldd	r31, Y+3	; 0x03
    20be:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    20c0:	81 e0       	ldi	r24, 0x01	; 1
    20c2:	8d 83       	std	Y+5, r24	; 0x05
    20c4:	01 c0       	rjmp	.+2      	; 0x20c8 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    20c6:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    20c8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    20ca:	2c 96       	adiw	r28, 0x0c	; 12
    20cc:	0f b6       	in	r0, 0x3f	; 63
    20ce:	f8 94       	cli
    20d0:	de bf       	out	0x3e, r29	; 62
    20d2:	0f be       	out	0x3f, r0	; 63
    20d4:	cd bf       	out	0x3d, r28	; 61
    20d6:	cf 91       	pop	r28
    20d8:	df 91       	pop	r29
    20da:	08 95       	ret

000020dc <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    20dc:	df 93       	push	r29
    20de:	cf 93       	push	r28
    20e0:	cd b7       	in	r28, 0x3d	; 61
    20e2:	de b7       	in	r29, 0x3e	; 62
    20e4:	2a 97       	sbiw	r28, 0x0a	; 10
    20e6:	0f b6       	in	r0, 0x3f	; 63
    20e8:	f8 94       	cli
    20ea:	de bf       	out	0x3e, r29	; 62
    20ec:	0f be       	out	0x3f, r0	; 63
    20ee:	cd bf       	out	0x3d, r28	; 61
    20f0:	98 87       	std	Y+8, r25	; 0x08
    20f2:	8f 83       	std	Y+7, r24	; 0x07
    20f4:	7a 87       	std	Y+10, r23	; 0x0a
    20f6:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    20f8:	8f 81       	ldd	r24, Y+7	; 0x07
    20fa:	98 85       	ldd	r25, Y+8	; 0x08
    20fc:	9c 83       	std	Y+4, r25	; 0x04
    20fe:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2100:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2102:	eb 81       	ldd	r30, Y+3	; 0x03
    2104:	fc 81       	ldd	r31, Y+4	; 0x04
    2106:	82 8d       	ldd	r24, Z+26	; 0x1a
    2108:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    210a:	eb 81       	ldd	r30, Y+3	; 0x03
    210c:	fc 81       	ldd	r31, Y+4	; 0x04
    210e:	93 8d       	ldd	r25, Z+27	; 0x1b
    2110:	8a 81       	ldd	r24, Y+2	; 0x02
    2112:	89 17       	cp	r24, r25
    2114:	48 f5       	brcc	.+82     	; 0x2168 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2116:	eb 81       	ldd	r30, Y+3	; 0x03
    2118:	fc 81       	ldd	r31, Y+4	; 0x04
    211a:	86 8d       	ldd	r24, Z+30	; 0x1e
    211c:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    211e:	8a 81       	ldd	r24, Y+2	; 0x02
    2120:	8f 5f       	subi	r24, 0xFF	; 255
    2122:	eb 81       	ldd	r30, Y+3	; 0x03
    2124:	fc 81       	ldd	r31, Y+4	; 0x04
    2126:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2128:	89 81       	ldd	r24, Y+1	; 0x01
    212a:	8f 3f       	cpi	r24, 0xFF	; 255
    212c:	a9 f4       	brne	.+42     	; 0x2158 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    212e:	eb 81       	ldd	r30, Y+3	; 0x03
    2130:	fc 81       	ldd	r31, Y+4	; 0x04
    2132:	81 89       	ldd	r24, Z+17	; 0x11
    2134:	88 23       	and	r24, r24
    2136:	a9 f0       	breq	.+42     	; 0x2162 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2138:	8b 81       	ldd	r24, Y+3	; 0x03
    213a:	9c 81       	ldd	r25, Y+4	; 0x04
    213c:	41 96       	adiw	r24, 0x11	; 17
    213e:	0e 94 99 23 	call	0x4732	; 0x4732 <xTaskRemoveFromEventList>
    2142:	88 23       	and	r24, r24
    2144:	71 f0       	breq	.+28     	; 0x2162 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2146:	89 85       	ldd	r24, Y+9	; 0x09
    2148:	9a 85       	ldd	r25, Y+10	; 0x0a
    214a:	00 97       	sbiw	r24, 0x00	; 0
    214c:	51 f0       	breq	.+20     	; 0x2162 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    214e:	e9 85       	ldd	r30, Y+9	; 0x09
    2150:	fa 85       	ldd	r31, Y+10	; 0x0a
    2152:	81 e0       	ldi	r24, 0x01	; 1
    2154:	80 83       	st	Z, r24
    2156:	05 c0       	rjmp	.+10     	; 0x2162 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2158:	89 81       	ldd	r24, Y+1	; 0x01
    215a:	8f 5f       	subi	r24, 0xFF	; 255
    215c:	eb 81       	ldd	r30, Y+3	; 0x03
    215e:	fc 81       	ldd	r31, Y+4	; 0x04
    2160:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2162:	81 e0       	ldi	r24, 0x01	; 1
    2164:	8e 83       	std	Y+6, r24	; 0x06
    2166:	01 c0       	rjmp	.+2      	; 0x216a <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2168:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    216a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    216c:	2a 96       	adiw	r28, 0x0a	; 10
    216e:	0f b6       	in	r0, 0x3f	; 63
    2170:	f8 94       	cli
    2172:	de bf       	out	0x3e, r29	; 62
    2174:	0f be       	out	0x3f, r0	; 63
    2176:	cd bf       	out	0x3d, r28	; 61
    2178:	cf 91       	pop	r28
    217a:	df 91       	pop	r29
    217c:	08 95       	ret

0000217e <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    217e:	df 93       	push	r29
    2180:	cf 93       	push	r28
    2182:	cd b7       	in	r28, 0x3d	; 61
    2184:	de b7       	in	r29, 0x3e	; 62
    2186:	2e 97       	sbiw	r28, 0x0e	; 14
    2188:	0f b6       	in	r0, 0x3f	; 63
    218a:	f8 94       	cli
    218c:	de bf       	out	0x3e, r29	; 62
    218e:	0f be       	out	0x3f, r0	; 63
    2190:	cd bf       	out	0x3d, r28	; 61
    2192:	99 87       	std	Y+9, r25	; 0x09
    2194:	88 87       	std	Y+8, r24	; 0x08
    2196:	7b 87       	std	Y+11, r23	; 0x0b
    2198:	6a 87       	std	Y+10, r22	; 0x0a
    219a:	5d 87       	std	Y+13, r21	; 0x0d
    219c:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    219e:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    21a0:	88 85       	ldd	r24, Y+8	; 0x08
    21a2:	99 85       	ldd	r25, Y+9	; 0x09
    21a4:	9b 83       	std	Y+3, r25	; 0x03
    21a6:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    21a8:	0f b6       	in	r0, 0x3f	; 63
    21aa:	f8 94       	cli
    21ac:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    21ae:	ea 81       	ldd	r30, Y+2	; 0x02
    21b0:	fb 81       	ldd	r31, Y+3	; 0x03
    21b2:	82 8d       	ldd	r24, Z+26	; 0x1a
    21b4:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    21b6:	89 81       	ldd	r24, Y+1	; 0x01
    21b8:	88 23       	and	r24, r24
    21ba:	f9 f0       	breq	.+62     	; 0x21fa <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    21bc:	8a 81       	ldd	r24, Y+2	; 0x02
    21be:	9b 81       	ldd	r25, Y+3	; 0x03
    21c0:	2a 85       	ldd	r18, Y+10	; 0x0a
    21c2:	3b 85       	ldd	r19, Y+11	; 0x0b
    21c4:	b9 01       	movw	r22, r18
    21c6:	0e 94 62 14 	call	0x28c4	; 0x28c4 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    21ca:	89 81       	ldd	r24, Y+1	; 0x01
    21cc:	81 50       	subi	r24, 0x01	; 1
    21ce:	ea 81       	ldd	r30, Y+2	; 0x02
    21d0:	fb 81       	ldd	r31, Y+3	; 0x03
    21d2:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    21d4:	ea 81       	ldd	r30, Y+2	; 0x02
    21d6:	fb 81       	ldd	r31, Y+3	; 0x03
    21d8:	80 85       	ldd	r24, Z+8	; 0x08
    21da:	88 23       	and	r24, r24
    21dc:	49 f0       	breq	.+18     	; 0x21f0 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    21de:	8a 81       	ldd	r24, Y+2	; 0x02
    21e0:	9b 81       	ldd	r25, Y+3	; 0x03
    21e2:	08 96       	adiw	r24, 0x08	; 8
    21e4:	0e 94 99 23 	call	0x4732	; 0x4732 <xTaskRemoveFromEventList>
    21e8:	88 23       	and	r24, r24
    21ea:	11 f0       	breq	.+4      	; 0x21f0 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    21ec:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    21f0:	0f 90       	pop	r0
    21f2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    21f4:	81 e0       	ldi	r24, 0x01	; 1
    21f6:	8e 87       	std	Y+14, r24	; 0x0e
    21f8:	63 c0       	rjmp	.+198    	; 0x22c0 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    21fa:	8c 85       	ldd	r24, Y+12	; 0x0c
    21fc:	9d 85       	ldd	r25, Y+13	; 0x0d
    21fe:	00 97       	sbiw	r24, 0x00	; 0
    2200:	21 f4       	brne	.+8      	; 0x220a <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2202:	0f 90       	pop	r0
    2204:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2206:	1e 86       	std	Y+14, r1	; 0x0e
    2208:	5b c0       	rjmp	.+182    	; 0x22c0 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    220a:	8c 81       	ldd	r24, Y+4	; 0x04
    220c:	88 23       	and	r24, r24
    220e:	31 f4       	brne	.+12     	; 0x221c <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2210:	ce 01       	movw	r24, r28
    2212:	05 96       	adiw	r24, 0x05	; 5
    2214:	0e 94 7f 24 	call	0x48fe	; 0x48fe <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2218:	81 e0       	ldi	r24, 0x01	; 1
    221a:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    221c:	0f 90       	pop	r0
    221e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2220:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2224:	0f b6       	in	r0, 0x3f	; 63
    2226:	f8 94       	cli
    2228:	0f 92       	push	r0
    222a:	ea 81       	ldd	r30, Y+2	; 0x02
    222c:	fb 81       	ldd	r31, Y+3	; 0x03
    222e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2230:	8f 3f       	cpi	r24, 0xFF	; 255
    2232:	19 f4       	brne	.+6      	; 0x223a <xQueueReceive+0xbc>
    2234:	ea 81       	ldd	r30, Y+2	; 0x02
    2236:	fb 81       	ldd	r31, Y+3	; 0x03
    2238:	15 8e       	std	Z+29, r1	; 0x1d
    223a:	ea 81       	ldd	r30, Y+2	; 0x02
    223c:	fb 81       	ldd	r31, Y+3	; 0x03
    223e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2240:	8f 3f       	cpi	r24, 0xFF	; 255
    2242:	19 f4       	brne	.+6      	; 0x224a <xQueueReceive+0xcc>
    2244:	ea 81       	ldd	r30, Y+2	; 0x02
    2246:	fb 81       	ldd	r31, Y+3	; 0x03
    2248:	16 8e       	std	Z+30, r1	; 0x1e
    224a:	0f 90       	pop	r0
    224c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    224e:	ce 01       	movw	r24, r28
    2250:	05 96       	adiw	r24, 0x05	; 5
    2252:	9e 01       	movw	r18, r28
    2254:	24 5f       	subi	r18, 0xF4	; 244
    2256:	3f 4f       	sbci	r19, 0xFF	; 255
    2258:	b9 01       	movw	r22, r18
    225a:	0e 94 98 24 	call	0x4930	; 0x4930 <xTaskCheckForTimeOut>
    225e:	88 23       	and	r24, r24
    2260:	09 f5       	brne	.+66     	; 0x22a4 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2262:	8a 81       	ldd	r24, Y+2	; 0x02
    2264:	9b 81       	ldd	r25, Y+3	; 0x03
    2266:	0e 94 fc 14 	call	0x29f8	; 0x29f8 <prvIsQueueEmpty>
    226a:	88 23       	and	r24, r24
    226c:	a1 f0       	breq	.+40     	; 0x2296 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    226e:	8a 81       	ldd	r24, Y+2	; 0x02
    2270:	9b 81       	ldd	r25, Y+3	; 0x03
    2272:	41 96       	adiw	r24, 0x11	; 17
    2274:	2c 85       	ldd	r18, Y+12	; 0x0c
    2276:	3d 85       	ldd	r19, Y+13	; 0x0d
    2278:	b9 01       	movw	r22, r18
    227a:	0e 94 47 23 	call	0x468e	; 0x468e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    227e:	8a 81       	ldd	r24, Y+2	; 0x02
    2280:	9b 81       	ldd	r25, Y+3	; 0x03
    2282:	0e 94 a9 14 	call	0x2952	; 0x2952 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2286:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
    228a:	88 23       	and	r24, r24
    228c:	09 f0       	breq	.+2      	; 0x2290 <xQueueReceive+0x112>
    228e:	8c cf       	rjmp	.-232    	; 0x21a8 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    2290:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
    2294:	89 cf       	rjmp	.-238    	; 0x21a8 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    2296:	8a 81       	ldd	r24, Y+2	; 0x02
    2298:	9b 81       	ldd	r25, Y+3	; 0x03
    229a:	0e 94 a9 14 	call	0x2952	; 0x2952 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    229e:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
    22a2:	82 cf       	rjmp	.-252    	; 0x21a8 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    22a4:	8a 81       	ldd	r24, Y+2	; 0x02
    22a6:	9b 81       	ldd	r25, Y+3	; 0x03
    22a8:	0e 94 a9 14 	call	0x2952	; 0x2952 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    22ac:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    22b0:	8a 81       	ldd	r24, Y+2	; 0x02
    22b2:	9b 81       	ldd	r25, Y+3	; 0x03
    22b4:	0e 94 fc 14 	call	0x29f8	; 0x29f8 <prvIsQueueEmpty>
    22b8:	88 23       	and	r24, r24
    22ba:	09 f4       	brne	.+2      	; 0x22be <xQueueReceive+0x140>
    22bc:	75 cf       	rjmp	.-278    	; 0x21a8 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    22be:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    22c0:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    22c2:	2e 96       	adiw	r28, 0x0e	; 14
    22c4:	0f b6       	in	r0, 0x3f	; 63
    22c6:	f8 94       	cli
    22c8:	de bf       	out	0x3e, r29	; 62
    22ca:	0f be       	out	0x3f, r0	; 63
    22cc:	cd bf       	out	0x3d, r28	; 61
    22ce:	cf 91       	pop	r28
    22d0:	df 91       	pop	r29
    22d2:	08 95       	ret

000022d4 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    22d4:	df 93       	push	r29
    22d6:	cf 93       	push	r28
    22d8:	cd b7       	in	r28, 0x3d	; 61
    22da:	de b7       	in	r29, 0x3e	; 62
    22dc:	2c 97       	sbiw	r28, 0x0c	; 12
    22de:	0f b6       	in	r0, 0x3f	; 63
    22e0:	f8 94       	cli
    22e2:	de bf       	out	0x3e, r29	; 62
    22e4:	0f be       	out	0x3f, r0	; 63
    22e6:	cd bf       	out	0x3d, r28	; 61
    22e8:	99 87       	std	Y+9, r25	; 0x09
    22ea:	88 87       	std	Y+8, r24	; 0x08
    22ec:	7b 87       	std	Y+11, r23	; 0x0b
    22ee:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    22f0:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    22f2:	88 85       	ldd	r24, Y+8	; 0x08
    22f4:	99 85       	ldd	r25, Y+9	; 0x09
    22f6:	9b 83       	std	Y+3, r25	; 0x03
    22f8:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    22fa:	0f b6       	in	r0, 0x3f	; 63
    22fc:	f8 94       	cli
    22fe:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2300:	ea 81       	ldd	r30, Y+2	; 0x02
    2302:	fb 81       	ldd	r31, Y+3	; 0x03
    2304:	82 8d       	ldd	r24, Z+26	; 0x1a
    2306:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2308:	89 81       	ldd	r24, Y+1	; 0x01
    230a:	88 23       	and	r24, r24
    230c:	c1 f0       	breq	.+48     	; 0x233e <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    230e:	89 81       	ldd	r24, Y+1	; 0x01
    2310:	81 50       	subi	r24, 0x01	; 1
    2312:	ea 81       	ldd	r30, Y+2	; 0x02
    2314:	fb 81       	ldd	r31, Y+3	; 0x03
    2316:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2318:	ea 81       	ldd	r30, Y+2	; 0x02
    231a:	fb 81       	ldd	r31, Y+3	; 0x03
    231c:	80 85       	ldd	r24, Z+8	; 0x08
    231e:	88 23       	and	r24, r24
    2320:	49 f0       	breq	.+18     	; 0x2334 <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2322:	8a 81       	ldd	r24, Y+2	; 0x02
    2324:	9b 81       	ldd	r25, Y+3	; 0x03
    2326:	08 96       	adiw	r24, 0x08	; 8
    2328:	0e 94 99 23 	call	0x4732	; 0x4732 <xTaskRemoveFromEventList>
    232c:	88 23       	and	r24, r24
    232e:	11 f0       	breq	.+4      	; 0x2334 <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    2330:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2334:	0f 90       	pop	r0
    2336:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2338:	81 e0       	ldi	r24, 0x01	; 1
    233a:	8c 87       	std	Y+12, r24	; 0x0c
    233c:	63 c0       	rjmp	.+198    	; 0x2404 <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    233e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2340:	9b 85       	ldd	r25, Y+11	; 0x0b
    2342:	00 97       	sbiw	r24, 0x00	; 0
    2344:	21 f4       	brne	.+8      	; 0x234e <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    2346:	0f 90       	pop	r0
    2348:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    234a:	1c 86       	std	Y+12, r1	; 0x0c
    234c:	5b c0       	rjmp	.+182    	; 0x2404 <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    234e:	8c 81       	ldd	r24, Y+4	; 0x04
    2350:	88 23       	and	r24, r24
    2352:	31 f4       	brne	.+12     	; 0x2360 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2354:	ce 01       	movw	r24, r28
    2356:	05 96       	adiw	r24, 0x05	; 5
    2358:	0e 94 7f 24 	call	0x48fe	; 0x48fe <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    235c:	81 e0       	ldi	r24, 0x01	; 1
    235e:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2360:	0f 90       	pop	r0
    2362:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    2364:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2368:	0f b6       	in	r0, 0x3f	; 63
    236a:	f8 94       	cli
    236c:	0f 92       	push	r0
    236e:	ea 81       	ldd	r30, Y+2	; 0x02
    2370:	fb 81       	ldd	r31, Y+3	; 0x03
    2372:	85 8d       	ldd	r24, Z+29	; 0x1d
    2374:	8f 3f       	cpi	r24, 0xFF	; 255
    2376:	19 f4       	brne	.+6      	; 0x237e <xQueueSemaphoreTake+0xaa>
    2378:	ea 81       	ldd	r30, Y+2	; 0x02
    237a:	fb 81       	ldd	r31, Y+3	; 0x03
    237c:	15 8e       	std	Z+29, r1	; 0x1d
    237e:	ea 81       	ldd	r30, Y+2	; 0x02
    2380:	fb 81       	ldd	r31, Y+3	; 0x03
    2382:	86 8d       	ldd	r24, Z+30	; 0x1e
    2384:	8f 3f       	cpi	r24, 0xFF	; 255
    2386:	19 f4       	brne	.+6      	; 0x238e <xQueueSemaphoreTake+0xba>
    2388:	ea 81       	ldd	r30, Y+2	; 0x02
    238a:	fb 81       	ldd	r31, Y+3	; 0x03
    238c:	16 8e       	std	Z+30, r1	; 0x1e
    238e:	0f 90       	pop	r0
    2390:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2392:	ce 01       	movw	r24, r28
    2394:	05 96       	adiw	r24, 0x05	; 5
    2396:	9e 01       	movw	r18, r28
    2398:	26 5f       	subi	r18, 0xF6	; 246
    239a:	3f 4f       	sbci	r19, 0xFF	; 255
    239c:	b9 01       	movw	r22, r18
    239e:	0e 94 98 24 	call	0x4930	; 0x4930 <xTaskCheckForTimeOut>
    23a2:	88 23       	and	r24, r24
    23a4:	09 f5       	brne	.+66     	; 0x23e8 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    23a6:	8a 81       	ldd	r24, Y+2	; 0x02
    23a8:	9b 81       	ldd	r25, Y+3	; 0x03
    23aa:	0e 94 fc 14 	call	0x29f8	; 0x29f8 <prvIsQueueEmpty>
    23ae:	88 23       	and	r24, r24
    23b0:	a1 f0       	breq	.+40     	; 0x23da <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    23b2:	8a 81       	ldd	r24, Y+2	; 0x02
    23b4:	9b 81       	ldd	r25, Y+3	; 0x03
    23b6:	41 96       	adiw	r24, 0x11	; 17
    23b8:	2a 85       	ldd	r18, Y+10	; 0x0a
    23ba:	3b 85       	ldd	r19, Y+11	; 0x0b
    23bc:	b9 01       	movw	r22, r18
    23be:	0e 94 47 23 	call	0x468e	; 0x468e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    23c2:	8a 81       	ldd	r24, Y+2	; 0x02
    23c4:	9b 81       	ldd	r25, Y+3	; 0x03
    23c6:	0e 94 a9 14 	call	0x2952	; 0x2952 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    23ca:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
    23ce:	88 23       	and	r24, r24
    23d0:	09 f0       	breq	.+2      	; 0x23d4 <xQueueSemaphoreTake+0x100>
    23d2:	93 cf       	rjmp	.-218    	; 0x22fa <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    23d4:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
    23d8:	90 cf       	rjmp	.-224    	; 0x22fa <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    23da:	8a 81       	ldd	r24, Y+2	; 0x02
    23dc:	9b 81       	ldd	r25, Y+3	; 0x03
    23de:	0e 94 a9 14 	call	0x2952	; 0x2952 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    23e2:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
    23e6:	89 cf       	rjmp	.-238    	; 0x22fa <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    23e8:	8a 81       	ldd	r24, Y+2	; 0x02
    23ea:	9b 81       	ldd	r25, Y+3	; 0x03
    23ec:	0e 94 a9 14 	call	0x2952	; 0x2952 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    23f0:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    23f4:	8a 81       	ldd	r24, Y+2	; 0x02
    23f6:	9b 81       	ldd	r25, Y+3	; 0x03
    23f8:	0e 94 fc 14 	call	0x29f8	; 0x29f8 <prvIsQueueEmpty>
    23fc:	88 23       	and	r24, r24
    23fe:	09 f4       	brne	.+2      	; 0x2402 <xQueueSemaphoreTake+0x12e>
    2400:	7c cf       	rjmp	.-264    	; 0x22fa <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2402:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2404:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2406:	2c 96       	adiw	r28, 0x0c	; 12
    2408:	0f b6       	in	r0, 0x3f	; 63
    240a:	f8 94       	cli
    240c:	de bf       	out	0x3e, r29	; 62
    240e:	0f be       	out	0x3f, r0	; 63
    2410:	cd bf       	out	0x3d, r28	; 61
    2412:	cf 91       	pop	r28
    2414:	df 91       	pop	r29
    2416:	08 95       	ret

00002418 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2418:	df 93       	push	r29
    241a:	cf 93       	push	r28
    241c:	cd b7       	in	r28, 0x3d	; 61
    241e:	de b7       	in	r29, 0x3e	; 62
    2420:	60 97       	sbiw	r28, 0x10	; 16
    2422:	0f b6       	in	r0, 0x3f	; 63
    2424:	f8 94       	cli
    2426:	de bf       	out	0x3e, r29	; 62
    2428:	0f be       	out	0x3f, r0	; 63
    242a:	cd bf       	out	0x3d, r28	; 61
    242c:	9b 87       	std	Y+11, r25	; 0x0b
    242e:	8a 87       	std	Y+10, r24	; 0x0a
    2430:	7d 87       	std	Y+13, r23	; 0x0d
    2432:	6c 87       	std	Y+12, r22	; 0x0c
    2434:	5f 87       	std	Y+15, r21	; 0x0f
    2436:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    2438:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    243a:	8a 85       	ldd	r24, Y+10	; 0x0a
    243c:	9b 85       	ldd	r25, Y+11	; 0x0b
    243e:	9b 83       	std	Y+3, r25	; 0x03
    2440:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2442:	0f b6       	in	r0, 0x3f	; 63
    2444:	f8 94       	cli
    2446:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2448:	ea 81       	ldd	r30, Y+2	; 0x02
    244a:	fb 81       	ldd	r31, Y+3	; 0x03
    244c:	82 8d       	ldd	r24, Z+26	; 0x1a
    244e:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2450:	89 81       	ldd	r24, Y+1	; 0x01
    2452:	88 23       	and	r24, r24
    2454:	31 f1       	breq	.+76     	; 0x24a2 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2456:	ea 81       	ldd	r30, Y+2	; 0x02
    2458:	fb 81       	ldd	r31, Y+3	; 0x03
    245a:	86 81       	ldd	r24, Z+6	; 0x06
    245c:	97 81       	ldd	r25, Z+7	; 0x07
    245e:	9d 83       	std	Y+5, r25	; 0x05
    2460:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2462:	8a 81       	ldd	r24, Y+2	; 0x02
    2464:	9b 81       	ldd	r25, Y+3	; 0x03
    2466:	2c 85       	ldd	r18, Y+12	; 0x0c
    2468:	3d 85       	ldd	r19, Y+13	; 0x0d
    246a:	b9 01       	movw	r22, r18
    246c:	0e 94 62 14 	call	0x28c4	; 0x28c4 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2470:	ea 81       	ldd	r30, Y+2	; 0x02
    2472:	fb 81       	ldd	r31, Y+3	; 0x03
    2474:	8c 81       	ldd	r24, Y+4	; 0x04
    2476:	9d 81       	ldd	r25, Y+5	; 0x05
    2478:	97 83       	std	Z+7, r25	; 0x07
    247a:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    247c:	ea 81       	ldd	r30, Y+2	; 0x02
    247e:	fb 81       	ldd	r31, Y+3	; 0x03
    2480:	81 89       	ldd	r24, Z+17	; 0x11
    2482:	88 23       	and	r24, r24
    2484:	49 f0       	breq	.+18     	; 0x2498 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2486:	8a 81       	ldd	r24, Y+2	; 0x02
    2488:	9b 81       	ldd	r25, Y+3	; 0x03
    248a:	41 96       	adiw	r24, 0x11	; 17
    248c:	0e 94 99 23 	call	0x4732	; 0x4732 <xTaskRemoveFromEventList>
    2490:	88 23       	and	r24, r24
    2492:	11 f0       	breq	.+4      	; 0x2498 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    2494:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2498:	0f 90       	pop	r0
    249a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    249c:	81 e0       	ldi	r24, 0x01	; 1
    249e:	88 8b       	std	Y+16, r24	; 0x10
    24a0:	63 c0       	rjmp	.+198    	; 0x2568 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    24a2:	8e 85       	ldd	r24, Y+14	; 0x0e
    24a4:	9f 85       	ldd	r25, Y+15	; 0x0f
    24a6:	00 97       	sbiw	r24, 0x00	; 0
    24a8:	21 f4       	brne	.+8      	; 0x24b2 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    24aa:	0f 90       	pop	r0
    24ac:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    24ae:	18 8a       	std	Y+16, r1	; 0x10
    24b0:	5b c0       	rjmp	.+182    	; 0x2568 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    24b2:	8e 81       	ldd	r24, Y+6	; 0x06
    24b4:	88 23       	and	r24, r24
    24b6:	31 f4       	brne	.+12     	; 0x24c4 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    24b8:	ce 01       	movw	r24, r28
    24ba:	07 96       	adiw	r24, 0x07	; 7
    24bc:	0e 94 7f 24 	call	0x48fe	; 0x48fe <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    24c0:	81 e0       	ldi	r24, 0x01	; 1
    24c2:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    24c4:	0f 90       	pop	r0
    24c6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    24c8:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    24cc:	0f b6       	in	r0, 0x3f	; 63
    24ce:	f8 94       	cli
    24d0:	0f 92       	push	r0
    24d2:	ea 81       	ldd	r30, Y+2	; 0x02
    24d4:	fb 81       	ldd	r31, Y+3	; 0x03
    24d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    24d8:	8f 3f       	cpi	r24, 0xFF	; 255
    24da:	19 f4       	brne	.+6      	; 0x24e2 <xQueuePeek+0xca>
    24dc:	ea 81       	ldd	r30, Y+2	; 0x02
    24de:	fb 81       	ldd	r31, Y+3	; 0x03
    24e0:	15 8e       	std	Z+29, r1	; 0x1d
    24e2:	ea 81       	ldd	r30, Y+2	; 0x02
    24e4:	fb 81       	ldd	r31, Y+3	; 0x03
    24e6:	86 8d       	ldd	r24, Z+30	; 0x1e
    24e8:	8f 3f       	cpi	r24, 0xFF	; 255
    24ea:	19 f4       	brne	.+6      	; 0x24f2 <xQueuePeek+0xda>
    24ec:	ea 81       	ldd	r30, Y+2	; 0x02
    24ee:	fb 81       	ldd	r31, Y+3	; 0x03
    24f0:	16 8e       	std	Z+30, r1	; 0x1e
    24f2:	0f 90       	pop	r0
    24f4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    24f6:	ce 01       	movw	r24, r28
    24f8:	07 96       	adiw	r24, 0x07	; 7
    24fa:	9e 01       	movw	r18, r28
    24fc:	22 5f       	subi	r18, 0xF2	; 242
    24fe:	3f 4f       	sbci	r19, 0xFF	; 255
    2500:	b9 01       	movw	r22, r18
    2502:	0e 94 98 24 	call	0x4930	; 0x4930 <xTaskCheckForTimeOut>
    2506:	88 23       	and	r24, r24
    2508:	09 f5       	brne	.+66     	; 0x254c <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    250a:	8a 81       	ldd	r24, Y+2	; 0x02
    250c:	9b 81       	ldd	r25, Y+3	; 0x03
    250e:	0e 94 fc 14 	call	0x29f8	; 0x29f8 <prvIsQueueEmpty>
    2512:	88 23       	and	r24, r24
    2514:	a1 f0       	breq	.+40     	; 0x253e <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2516:	8a 81       	ldd	r24, Y+2	; 0x02
    2518:	9b 81       	ldd	r25, Y+3	; 0x03
    251a:	41 96       	adiw	r24, 0x11	; 17
    251c:	2e 85       	ldd	r18, Y+14	; 0x0e
    251e:	3f 85       	ldd	r19, Y+15	; 0x0f
    2520:	b9 01       	movw	r22, r18
    2522:	0e 94 47 23 	call	0x468e	; 0x468e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2526:	8a 81       	ldd	r24, Y+2	; 0x02
    2528:	9b 81       	ldd	r25, Y+3	; 0x03
    252a:	0e 94 a9 14 	call	0x2952	; 0x2952 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    252e:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
    2532:	88 23       	and	r24, r24
    2534:	09 f0       	breq	.+2      	; 0x2538 <xQueuePeek+0x120>
    2536:	85 cf       	rjmp	.-246    	; 0x2442 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    2538:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
    253c:	82 cf       	rjmp	.-252    	; 0x2442 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    253e:	8a 81       	ldd	r24, Y+2	; 0x02
    2540:	9b 81       	ldd	r25, Y+3	; 0x03
    2542:	0e 94 a9 14 	call	0x2952	; 0x2952 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2546:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
    254a:	7b cf       	rjmp	.-266    	; 0x2442 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    254c:	8a 81       	ldd	r24, Y+2	; 0x02
    254e:	9b 81       	ldd	r25, Y+3	; 0x03
    2550:	0e 94 a9 14 	call	0x2952	; 0x2952 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2554:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2558:	8a 81       	ldd	r24, Y+2	; 0x02
    255a:	9b 81       	ldd	r25, Y+3	; 0x03
    255c:	0e 94 fc 14 	call	0x29f8	; 0x29f8 <prvIsQueueEmpty>
    2560:	88 23       	and	r24, r24
    2562:	09 f4       	brne	.+2      	; 0x2566 <xQueuePeek+0x14e>
    2564:	6e cf       	rjmp	.-292    	; 0x2442 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2566:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2568:	88 89       	ldd	r24, Y+16	; 0x10
}
    256a:	60 96       	adiw	r28, 0x10	; 16
    256c:	0f b6       	in	r0, 0x3f	; 63
    256e:	f8 94       	cli
    2570:	de bf       	out	0x3e, r29	; 62
    2572:	0f be       	out	0x3f, r0	; 63
    2574:	cd bf       	out	0x3d, r28	; 61
    2576:	cf 91       	pop	r28
    2578:	df 91       	pop	r29
    257a:	08 95       	ret

0000257c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    257c:	df 93       	push	r29
    257e:	cf 93       	push	r28
    2580:	cd b7       	in	r28, 0x3d	; 61
    2582:	de b7       	in	r29, 0x3e	; 62
    2584:	2c 97       	sbiw	r28, 0x0c	; 12
    2586:	0f b6       	in	r0, 0x3f	; 63
    2588:	f8 94       	cli
    258a:	de bf       	out	0x3e, r29	; 62
    258c:	0f be       	out	0x3f, r0	; 63
    258e:	cd bf       	out	0x3d, r28	; 61
    2590:	98 87       	std	Y+8, r25	; 0x08
    2592:	8f 83       	std	Y+7, r24	; 0x07
    2594:	7a 87       	std	Y+10, r23	; 0x0a
    2596:	69 87       	std	Y+9, r22	; 0x09
    2598:	5c 87       	std	Y+12, r21	; 0x0c
    259a:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    259c:	8f 81       	ldd	r24, Y+7	; 0x07
    259e:	98 85       	ldd	r25, Y+8	; 0x08
    25a0:	9c 83       	std	Y+4, r25	; 0x04
    25a2:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    25a4:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    25a6:	eb 81       	ldd	r30, Y+3	; 0x03
    25a8:	fc 81       	ldd	r31, Y+4	; 0x04
    25aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    25ac:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    25ae:	8a 81       	ldd	r24, Y+2	; 0x02
    25b0:	88 23       	and	r24, r24
    25b2:	81 f1       	breq	.+96     	; 0x2614 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    25b4:	eb 81       	ldd	r30, Y+3	; 0x03
    25b6:	fc 81       	ldd	r31, Y+4	; 0x04
    25b8:	85 8d       	ldd	r24, Z+29	; 0x1d
    25ba:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    25bc:	8b 81       	ldd	r24, Y+3	; 0x03
    25be:	9c 81       	ldd	r25, Y+4	; 0x04
    25c0:	29 85       	ldd	r18, Y+9	; 0x09
    25c2:	3a 85       	ldd	r19, Y+10	; 0x0a
    25c4:	b9 01       	movw	r22, r18
    25c6:	0e 94 62 14 	call	0x28c4	; 0x28c4 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    25ca:	8a 81       	ldd	r24, Y+2	; 0x02
    25cc:	81 50       	subi	r24, 0x01	; 1
    25ce:	eb 81       	ldd	r30, Y+3	; 0x03
    25d0:	fc 81       	ldd	r31, Y+4	; 0x04
    25d2:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    25d4:	89 81       	ldd	r24, Y+1	; 0x01
    25d6:	8f 3f       	cpi	r24, 0xFF	; 255
    25d8:	a9 f4       	brne	.+42     	; 0x2604 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    25da:	eb 81       	ldd	r30, Y+3	; 0x03
    25dc:	fc 81       	ldd	r31, Y+4	; 0x04
    25de:	80 85       	ldd	r24, Z+8	; 0x08
    25e0:	88 23       	and	r24, r24
    25e2:	a9 f0       	breq	.+42     	; 0x260e <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    25e4:	8b 81       	ldd	r24, Y+3	; 0x03
    25e6:	9c 81       	ldd	r25, Y+4	; 0x04
    25e8:	08 96       	adiw	r24, 0x08	; 8
    25ea:	0e 94 99 23 	call	0x4732	; 0x4732 <xTaskRemoveFromEventList>
    25ee:	88 23       	and	r24, r24
    25f0:	71 f0       	breq	.+28     	; 0x260e <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    25f2:	8b 85       	ldd	r24, Y+11	; 0x0b
    25f4:	9c 85       	ldd	r25, Y+12	; 0x0c
    25f6:	00 97       	sbiw	r24, 0x00	; 0
    25f8:	51 f0       	breq	.+20     	; 0x260e <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    25fa:	eb 85       	ldd	r30, Y+11	; 0x0b
    25fc:	fc 85       	ldd	r31, Y+12	; 0x0c
    25fe:	81 e0       	ldi	r24, 0x01	; 1
    2600:	80 83       	st	Z, r24
    2602:	05 c0       	rjmp	.+10     	; 0x260e <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2604:	89 81       	ldd	r24, Y+1	; 0x01
    2606:	8f 5f       	subi	r24, 0xFF	; 255
    2608:	eb 81       	ldd	r30, Y+3	; 0x03
    260a:	fc 81       	ldd	r31, Y+4	; 0x04
    260c:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    260e:	81 e0       	ldi	r24, 0x01	; 1
    2610:	8e 83       	std	Y+6, r24	; 0x06
    2612:	01 c0       	rjmp	.+2      	; 0x2616 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2614:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2616:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2618:	2c 96       	adiw	r28, 0x0c	; 12
    261a:	0f b6       	in	r0, 0x3f	; 63
    261c:	f8 94       	cli
    261e:	de bf       	out	0x3e, r29	; 62
    2620:	0f be       	out	0x3f, r0	; 63
    2622:	cd bf       	out	0x3d, r28	; 61
    2624:	cf 91       	pop	r28
    2626:	df 91       	pop	r29
    2628:	08 95       	ret

0000262a <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    262a:	df 93       	push	r29
    262c:	cf 93       	push	r28
    262e:	cd b7       	in	r28, 0x3d	; 61
    2630:	de b7       	in	r29, 0x3e	; 62
    2632:	2a 97       	sbiw	r28, 0x0a	; 10
    2634:	0f b6       	in	r0, 0x3f	; 63
    2636:	f8 94       	cli
    2638:	de bf       	out	0x3e, r29	; 62
    263a:	0f be       	out	0x3f, r0	; 63
    263c:	cd bf       	out	0x3d, r28	; 61
    263e:	98 87       	std	Y+8, r25	; 0x08
    2640:	8f 83       	std	Y+7, r24	; 0x07
    2642:	7a 87       	std	Y+10, r23	; 0x0a
    2644:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    2646:	8f 81       	ldd	r24, Y+7	; 0x07
    2648:	98 85       	ldd	r25, Y+8	; 0x08
    264a:	9a 83       	std	Y+2, r25	; 0x02
    264c:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    264e:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2650:	e9 81       	ldd	r30, Y+1	; 0x01
    2652:	fa 81       	ldd	r31, Y+2	; 0x02
    2654:	82 8d       	ldd	r24, Z+26	; 0x1a
    2656:	88 23       	and	r24, r24
    2658:	b1 f0       	breq	.+44     	; 0x2686 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    265a:	e9 81       	ldd	r30, Y+1	; 0x01
    265c:	fa 81       	ldd	r31, Y+2	; 0x02
    265e:	86 81       	ldd	r24, Z+6	; 0x06
    2660:	97 81       	ldd	r25, Z+7	; 0x07
    2662:	9c 83       	std	Y+4, r25	; 0x04
    2664:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2666:	89 81       	ldd	r24, Y+1	; 0x01
    2668:	9a 81       	ldd	r25, Y+2	; 0x02
    266a:	29 85       	ldd	r18, Y+9	; 0x09
    266c:	3a 85       	ldd	r19, Y+10	; 0x0a
    266e:	b9 01       	movw	r22, r18
    2670:	0e 94 62 14 	call	0x28c4	; 0x28c4 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2674:	e9 81       	ldd	r30, Y+1	; 0x01
    2676:	fa 81       	ldd	r31, Y+2	; 0x02
    2678:	8b 81       	ldd	r24, Y+3	; 0x03
    267a:	9c 81       	ldd	r25, Y+4	; 0x04
    267c:	97 83       	std	Z+7, r25	; 0x07
    267e:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2680:	81 e0       	ldi	r24, 0x01	; 1
    2682:	8e 83       	std	Y+6, r24	; 0x06
    2684:	01 c0       	rjmp	.+2      	; 0x2688 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    2686:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2688:	8e 81       	ldd	r24, Y+6	; 0x06
}
    268a:	2a 96       	adiw	r28, 0x0a	; 10
    268c:	0f b6       	in	r0, 0x3f	; 63
    268e:	f8 94       	cli
    2690:	de bf       	out	0x3e, r29	; 62
    2692:	0f be       	out	0x3f, r0	; 63
    2694:	cd bf       	out	0x3d, r28	; 61
    2696:	cf 91       	pop	r28
    2698:	df 91       	pop	r29
    269a:	08 95       	ret

0000269c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    269c:	df 93       	push	r29
    269e:	cf 93       	push	r28
    26a0:	00 d0       	rcall	.+0      	; 0x26a2 <uxQueueMessagesWaiting+0x6>
    26a2:	0f 92       	push	r0
    26a4:	cd b7       	in	r28, 0x3d	; 61
    26a6:	de b7       	in	r29, 0x3e	; 62
    26a8:	9b 83       	std	Y+3, r25	; 0x03
    26aa:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    26ac:	0f b6       	in	r0, 0x3f	; 63
    26ae:	f8 94       	cli
    26b0:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    26b2:	ea 81       	ldd	r30, Y+2	; 0x02
    26b4:	fb 81       	ldd	r31, Y+3	; 0x03
    26b6:	82 8d       	ldd	r24, Z+26	; 0x1a
    26b8:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    26ba:	0f 90       	pop	r0
    26bc:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    26be:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    26c0:	0f 90       	pop	r0
    26c2:	0f 90       	pop	r0
    26c4:	0f 90       	pop	r0
    26c6:	cf 91       	pop	r28
    26c8:	df 91       	pop	r29
    26ca:	08 95       	ret

000026cc <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    26cc:	df 93       	push	r29
    26ce:	cf 93       	push	r28
    26d0:	00 d0       	rcall	.+0      	; 0x26d2 <uxQueueSpacesAvailable+0x6>
    26d2:	00 d0       	rcall	.+0      	; 0x26d4 <uxQueueSpacesAvailable+0x8>
    26d4:	0f 92       	push	r0
    26d6:	cd b7       	in	r28, 0x3d	; 61
    26d8:	de b7       	in	r29, 0x3e	; 62
    26da:	9d 83       	std	Y+5, r25	; 0x05
    26dc:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    26de:	8c 81       	ldd	r24, Y+4	; 0x04
    26e0:	9d 81       	ldd	r25, Y+5	; 0x05
    26e2:	9a 83       	std	Y+2, r25	; 0x02
    26e4:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    26e6:	0f b6       	in	r0, 0x3f	; 63
    26e8:	f8 94       	cli
    26ea:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    26ec:	e9 81       	ldd	r30, Y+1	; 0x01
    26ee:	fa 81       	ldd	r31, Y+2	; 0x02
    26f0:	93 8d       	ldd	r25, Z+27	; 0x1b
    26f2:	e9 81       	ldd	r30, Y+1	; 0x01
    26f4:	fa 81       	ldd	r31, Y+2	; 0x02
    26f6:	82 8d       	ldd	r24, Z+26	; 0x1a
    26f8:	29 2f       	mov	r18, r25
    26fa:	28 1b       	sub	r18, r24
    26fc:	82 2f       	mov	r24, r18
    26fe:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2700:	0f 90       	pop	r0
    2702:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2704:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2706:	0f 90       	pop	r0
    2708:	0f 90       	pop	r0
    270a:	0f 90       	pop	r0
    270c:	0f 90       	pop	r0
    270e:	0f 90       	pop	r0
    2710:	cf 91       	pop	r28
    2712:	df 91       	pop	r29
    2714:	08 95       	ret

00002716 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2716:	df 93       	push	r29
    2718:	cf 93       	push	r28
    271a:	00 d0       	rcall	.+0      	; 0x271c <uxQueueMessagesWaitingFromISR+0x6>
    271c:	00 d0       	rcall	.+0      	; 0x271e <uxQueueMessagesWaitingFromISR+0x8>
    271e:	0f 92       	push	r0
    2720:	cd b7       	in	r28, 0x3d	; 61
    2722:	de b7       	in	r29, 0x3e	; 62
    2724:	9d 83       	std	Y+5, r25	; 0x05
    2726:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2728:	8c 81       	ldd	r24, Y+4	; 0x04
    272a:	9d 81       	ldd	r25, Y+5	; 0x05
    272c:	9a 83       	std	Y+2, r25	; 0x02
    272e:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2730:	e9 81       	ldd	r30, Y+1	; 0x01
    2732:	fa 81       	ldd	r31, Y+2	; 0x02
    2734:	82 8d       	ldd	r24, Z+26	; 0x1a
    2736:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    2738:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    273a:	0f 90       	pop	r0
    273c:	0f 90       	pop	r0
    273e:	0f 90       	pop	r0
    2740:	0f 90       	pop	r0
    2742:	0f 90       	pop	r0
    2744:	cf 91       	pop	r28
    2746:	df 91       	pop	r29
    2748:	08 95       	ret

0000274a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    274a:	df 93       	push	r29
    274c:	cf 93       	push	r28
    274e:	00 d0       	rcall	.+0      	; 0x2750 <vQueueDelete+0x6>
    2750:	00 d0       	rcall	.+0      	; 0x2752 <vQueueDelete+0x8>
    2752:	cd b7       	in	r28, 0x3d	; 61
    2754:	de b7       	in	r29, 0x3e	; 62
    2756:	9c 83       	std	Y+4, r25	; 0x04
    2758:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    275a:	8b 81       	ldd	r24, Y+3	; 0x03
    275c:	9c 81       	ldd	r25, Y+4	; 0x04
    275e:	9a 83       	std	Y+2, r25	; 0x02
    2760:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2762:	89 81       	ldd	r24, Y+1	; 0x01
    2764:	9a 81       	ldd	r25, Y+2	; 0x02
    2766:	0e 94 71 07 	call	0xee2	; 0xee2 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    276a:	0f 90       	pop	r0
    276c:	0f 90       	pop	r0
    276e:	0f 90       	pop	r0
    2770:	0f 90       	pop	r0
    2772:	cf 91       	pop	r28
    2774:	df 91       	pop	r29
    2776:	08 95       	ret

00002778 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2778:	df 93       	push	r29
    277a:	cf 93       	push	r28
    277c:	cd b7       	in	r28, 0x3d	; 61
    277e:	de b7       	in	r29, 0x3e	; 62
    2780:	27 97       	sbiw	r28, 0x07	; 7
    2782:	0f b6       	in	r0, 0x3f	; 63
    2784:	f8 94       	cli
    2786:	de bf       	out	0x3e, r29	; 62
    2788:	0f be       	out	0x3f, r0	; 63
    278a:	cd bf       	out	0x3d, r28	; 61
    278c:	9c 83       	std	Y+4, r25	; 0x04
    278e:	8b 83       	std	Y+3, r24	; 0x03
    2790:	7e 83       	std	Y+6, r23	; 0x06
    2792:	6d 83       	std	Y+5, r22	; 0x05
    2794:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    2796:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2798:	eb 81       	ldd	r30, Y+3	; 0x03
    279a:	fc 81       	ldd	r31, Y+4	; 0x04
    279c:	82 8d       	ldd	r24, Z+26	; 0x1a
    279e:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    27a0:	eb 81       	ldd	r30, Y+3	; 0x03
    27a2:	fc 81       	ldd	r31, Y+4	; 0x04
    27a4:	84 8d       	ldd	r24, Z+28	; 0x1c
    27a6:	88 23       	and	r24, r24
    27a8:	09 f4       	brne	.+2      	; 0x27ac <prvCopyDataToQueue+0x34>
    27aa:	7d c0       	rjmp	.+250    	; 0x28a6 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    27ac:	8f 81       	ldd	r24, Y+7	; 0x07
    27ae:	88 23       	and	r24, r24
    27b0:	99 f5       	brne	.+102    	; 0x2818 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    27b2:	eb 81       	ldd	r30, Y+3	; 0x03
    27b4:	fc 81       	ldd	r31, Y+4	; 0x04
    27b6:	62 81       	ldd	r22, Z+2	; 0x02
    27b8:	73 81       	ldd	r23, Z+3	; 0x03
    27ba:	eb 81       	ldd	r30, Y+3	; 0x03
    27bc:	fc 81       	ldd	r31, Y+4	; 0x04
    27be:	84 8d       	ldd	r24, Z+28	; 0x1c
    27c0:	48 2f       	mov	r20, r24
    27c2:	50 e0       	ldi	r21, 0x00	; 0
    27c4:	2d 81       	ldd	r18, Y+5	; 0x05
    27c6:	3e 81       	ldd	r19, Y+6	; 0x06
    27c8:	cb 01       	movw	r24, r22
    27ca:	b9 01       	movw	r22, r18
    27cc:	0e 94 27 2a 	call	0x544e	; 0x544e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    27d0:	eb 81       	ldd	r30, Y+3	; 0x03
    27d2:	fc 81       	ldd	r31, Y+4	; 0x04
    27d4:	22 81       	ldd	r18, Z+2	; 0x02
    27d6:	33 81       	ldd	r19, Z+3	; 0x03
    27d8:	eb 81       	ldd	r30, Y+3	; 0x03
    27da:	fc 81       	ldd	r31, Y+4	; 0x04
    27dc:	84 8d       	ldd	r24, Z+28	; 0x1c
    27de:	88 2f       	mov	r24, r24
    27e0:	90 e0       	ldi	r25, 0x00	; 0
    27e2:	82 0f       	add	r24, r18
    27e4:	93 1f       	adc	r25, r19
    27e6:	eb 81       	ldd	r30, Y+3	; 0x03
    27e8:	fc 81       	ldd	r31, Y+4	; 0x04
    27ea:	93 83       	std	Z+3, r25	; 0x03
    27ec:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    27ee:	eb 81       	ldd	r30, Y+3	; 0x03
    27f0:	fc 81       	ldd	r31, Y+4	; 0x04
    27f2:	22 81       	ldd	r18, Z+2	; 0x02
    27f4:	33 81       	ldd	r19, Z+3	; 0x03
    27f6:	eb 81       	ldd	r30, Y+3	; 0x03
    27f8:	fc 81       	ldd	r31, Y+4	; 0x04
    27fa:	84 81       	ldd	r24, Z+4	; 0x04
    27fc:	95 81       	ldd	r25, Z+5	; 0x05
    27fe:	28 17       	cp	r18, r24
    2800:	39 07       	cpc	r19, r25
    2802:	08 f4       	brcc	.+2      	; 0x2806 <prvCopyDataToQueue+0x8e>
    2804:	50 c0       	rjmp	.+160    	; 0x28a6 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2806:	eb 81       	ldd	r30, Y+3	; 0x03
    2808:	fc 81       	ldd	r31, Y+4	; 0x04
    280a:	80 81       	ld	r24, Z
    280c:	91 81       	ldd	r25, Z+1	; 0x01
    280e:	eb 81       	ldd	r30, Y+3	; 0x03
    2810:	fc 81       	ldd	r31, Y+4	; 0x04
    2812:	93 83       	std	Z+3, r25	; 0x03
    2814:	82 83       	std	Z+2, r24	; 0x02
    2816:	47 c0       	rjmp	.+142    	; 0x28a6 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2818:	eb 81       	ldd	r30, Y+3	; 0x03
    281a:	fc 81       	ldd	r31, Y+4	; 0x04
    281c:	66 81       	ldd	r22, Z+6	; 0x06
    281e:	77 81       	ldd	r23, Z+7	; 0x07
    2820:	eb 81       	ldd	r30, Y+3	; 0x03
    2822:	fc 81       	ldd	r31, Y+4	; 0x04
    2824:	84 8d       	ldd	r24, Z+28	; 0x1c
    2826:	48 2f       	mov	r20, r24
    2828:	50 e0       	ldi	r21, 0x00	; 0
    282a:	2d 81       	ldd	r18, Y+5	; 0x05
    282c:	3e 81       	ldd	r19, Y+6	; 0x06
    282e:	cb 01       	movw	r24, r22
    2830:	b9 01       	movw	r22, r18
    2832:	0e 94 27 2a 	call	0x544e	; 0x544e <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2836:	eb 81       	ldd	r30, Y+3	; 0x03
    2838:	fc 81       	ldd	r31, Y+4	; 0x04
    283a:	26 81       	ldd	r18, Z+6	; 0x06
    283c:	37 81       	ldd	r19, Z+7	; 0x07
    283e:	eb 81       	ldd	r30, Y+3	; 0x03
    2840:	fc 81       	ldd	r31, Y+4	; 0x04
    2842:	84 8d       	ldd	r24, Z+28	; 0x1c
    2844:	88 2f       	mov	r24, r24
    2846:	90 e0       	ldi	r25, 0x00	; 0
    2848:	90 95       	com	r25
    284a:	81 95       	neg	r24
    284c:	9f 4f       	sbci	r25, 0xFF	; 255
    284e:	82 0f       	add	r24, r18
    2850:	93 1f       	adc	r25, r19
    2852:	eb 81       	ldd	r30, Y+3	; 0x03
    2854:	fc 81       	ldd	r31, Y+4	; 0x04
    2856:	97 83       	std	Z+7, r25	; 0x07
    2858:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    285a:	eb 81       	ldd	r30, Y+3	; 0x03
    285c:	fc 81       	ldd	r31, Y+4	; 0x04
    285e:	26 81       	ldd	r18, Z+6	; 0x06
    2860:	37 81       	ldd	r19, Z+7	; 0x07
    2862:	eb 81       	ldd	r30, Y+3	; 0x03
    2864:	fc 81       	ldd	r31, Y+4	; 0x04
    2866:	80 81       	ld	r24, Z
    2868:	91 81       	ldd	r25, Z+1	; 0x01
    286a:	28 17       	cp	r18, r24
    286c:	39 07       	cpc	r19, r25
    286e:	90 f4       	brcc	.+36     	; 0x2894 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2870:	eb 81       	ldd	r30, Y+3	; 0x03
    2872:	fc 81       	ldd	r31, Y+4	; 0x04
    2874:	24 81       	ldd	r18, Z+4	; 0x04
    2876:	35 81       	ldd	r19, Z+5	; 0x05
    2878:	eb 81       	ldd	r30, Y+3	; 0x03
    287a:	fc 81       	ldd	r31, Y+4	; 0x04
    287c:	84 8d       	ldd	r24, Z+28	; 0x1c
    287e:	88 2f       	mov	r24, r24
    2880:	90 e0       	ldi	r25, 0x00	; 0
    2882:	90 95       	com	r25
    2884:	81 95       	neg	r24
    2886:	9f 4f       	sbci	r25, 0xFF	; 255
    2888:	82 0f       	add	r24, r18
    288a:	93 1f       	adc	r25, r19
    288c:	eb 81       	ldd	r30, Y+3	; 0x03
    288e:	fc 81       	ldd	r31, Y+4	; 0x04
    2890:	97 83       	std	Z+7, r25	; 0x07
    2892:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2894:	8f 81       	ldd	r24, Y+7	; 0x07
    2896:	82 30       	cpi	r24, 0x02	; 2
    2898:	31 f4       	brne	.+12     	; 0x28a6 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    289a:	89 81       	ldd	r24, Y+1	; 0x01
    289c:	88 23       	and	r24, r24
    289e:	19 f0       	breq	.+6      	; 0x28a6 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    28a0:	89 81       	ldd	r24, Y+1	; 0x01
    28a2:	81 50       	subi	r24, 0x01	; 1
    28a4:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    28a6:	89 81       	ldd	r24, Y+1	; 0x01
    28a8:	8f 5f       	subi	r24, 0xFF	; 255
    28aa:	eb 81       	ldd	r30, Y+3	; 0x03
    28ac:	fc 81       	ldd	r31, Y+4	; 0x04
    28ae:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    28b0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    28b2:	27 96       	adiw	r28, 0x07	; 7
    28b4:	0f b6       	in	r0, 0x3f	; 63
    28b6:	f8 94       	cli
    28b8:	de bf       	out	0x3e, r29	; 62
    28ba:	0f be       	out	0x3f, r0	; 63
    28bc:	cd bf       	out	0x3d, r28	; 61
    28be:	cf 91       	pop	r28
    28c0:	df 91       	pop	r29
    28c2:	08 95       	ret

000028c4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    28c4:	df 93       	push	r29
    28c6:	cf 93       	push	r28
    28c8:	00 d0       	rcall	.+0      	; 0x28ca <prvCopyDataFromQueue+0x6>
    28ca:	00 d0       	rcall	.+0      	; 0x28cc <prvCopyDataFromQueue+0x8>
    28cc:	cd b7       	in	r28, 0x3d	; 61
    28ce:	de b7       	in	r29, 0x3e	; 62
    28d0:	9a 83       	std	Y+2, r25	; 0x02
    28d2:	89 83       	std	Y+1, r24	; 0x01
    28d4:	7c 83       	std	Y+4, r23	; 0x04
    28d6:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    28d8:	e9 81       	ldd	r30, Y+1	; 0x01
    28da:	fa 81       	ldd	r31, Y+2	; 0x02
    28dc:	84 8d       	ldd	r24, Z+28	; 0x1c
    28de:	88 23       	and	r24, r24
    28e0:	89 f1       	breq	.+98     	; 0x2944 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    28e2:	e9 81       	ldd	r30, Y+1	; 0x01
    28e4:	fa 81       	ldd	r31, Y+2	; 0x02
    28e6:	26 81       	ldd	r18, Z+6	; 0x06
    28e8:	37 81       	ldd	r19, Z+7	; 0x07
    28ea:	e9 81       	ldd	r30, Y+1	; 0x01
    28ec:	fa 81       	ldd	r31, Y+2	; 0x02
    28ee:	84 8d       	ldd	r24, Z+28	; 0x1c
    28f0:	88 2f       	mov	r24, r24
    28f2:	90 e0       	ldi	r25, 0x00	; 0
    28f4:	82 0f       	add	r24, r18
    28f6:	93 1f       	adc	r25, r19
    28f8:	e9 81       	ldd	r30, Y+1	; 0x01
    28fa:	fa 81       	ldd	r31, Y+2	; 0x02
    28fc:	97 83       	std	Z+7, r25	; 0x07
    28fe:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2900:	e9 81       	ldd	r30, Y+1	; 0x01
    2902:	fa 81       	ldd	r31, Y+2	; 0x02
    2904:	26 81       	ldd	r18, Z+6	; 0x06
    2906:	37 81       	ldd	r19, Z+7	; 0x07
    2908:	e9 81       	ldd	r30, Y+1	; 0x01
    290a:	fa 81       	ldd	r31, Y+2	; 0x02
    290c:	84 81       	ldd	r24, Z+4	; 0x04
    290e:	95 81       	ldd	r25, Z+5	; 0x05
    2910:	28 17       	cp	r18, r24
    2912:	39 07       	cpc	r19, r25
    2914:	40 f0       	brcs	.+16     	; 0x2926 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2916:	e9 81       	ldd	r30, Y+1	; 0x01
    2918:	fa 81       	ldd	r31, Y+2	; 0x02
    291a:	80 81       	ld	r24, Z
    291c:	91 81       	ldd	r25, Z+1	; 0x01
    291e:	e9 81       	ldd	r30, Y+1	; 0x01
    2920:	fa 81       	ldd	r31, Y+2	; 0x02
    2922:	97 83       	std	Z+7, r25	; 0x07
    2924:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2926:	e9 81       	ldd	r30, Y+1	; 0x01
    2928:	fa 81       	ldd	r31, Y+2	; 0x02
    292a:	46 81       	ldd	r20, Z+6	; 0x06
    292c:	57 81       	ldd	r21, Z+7	; 0x07
    292e:	e9 81       	ldd	r30, Y+1	; 0x01
    2930:	fa 81       	ldd	r31, Y+2	; 0x02
    2932:	84 8d       	ldd	r24, Z+28	; 0x1c
    2934:	28 2f       	mov	r18, r24
    2936:	30 e0       	ldi	r19, 0x00	; 0
    2938:	8b 81       	ldd	r24, Y+3	; 0x03
    293a:	9c 81       	ldd	r25, Y+4	; 0x04
    293c:	ba 01       	movw	r22, r20
    293e:	a9 01       	movw	r20, r18
    2940:	0e 94 27 2a 	call	0x544e	; 0x544e <memcpy>
	}
}
    2944:	0f 90       	pop	r0
    2946:	0f 90       	pop	r0
    2948:	0f 90       	pop	r0
    294a:	0f 90       	pop	r0
    294c:	cf 91       	pop	r28
    294e:	df 91       	pop	r29
    2950:	08 95       	ret

00002952 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2952:	df 93       	push	r29
    2954:	cf 93       	push	r28
    2956:	00 d0       	rcall	.+0      	; 0x2958 <prvUnlockQueue+0x6>
    2958:	00 d0       	rcall	.+0      	; 0x295a <prvUnlockQueue+0x8>
    295a:	cd b7       	in	r28, 0x3d	; 61
    295c:	de b7       	in	r29, 0x3e	; 62
    295e:	9c 83       	std	Y+4, r25	; 0x04
    2960:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2962:	0f b6       	in	r0, 0x3f	; 63
    2964:	f8 94       	cli
    2966:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2968:	eb 81       	ldd	r30, Y+3	; 0x03
    296a:	fc 81       	ldd	r31, Y+4	; 0x04
    296c:	86 8d       	ldd	r24, Z+30	; 0x1e
    296e:	8a 83       	std	Y+2, r24	; 0x02
    2970:	11 c0       	rjmp	.+34     	; 0x2994 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2972:	eb 81       	ldd	r30, Y+3	; 0x03
    2974:	fc 81       	ldd	r31, Y+4	; 0x04
    2976:	81 89       	ldd	r24, Z+17	; 0x11
    2978:	88 23       	and	r24, r24
    297a:	79 f0       	breq	.+30     	; 0x299a <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    297c:	8b 81       	ldd	r24, Y+3	; 0x03
    297e:	9c 81       	ldd	r25, Y+4	; 0x04
    2980:	41 96       	adiw	r24, 0x11	; 17
    2982:	0e 94 99 23 	call	0x4732	; 0x4732 <xTaskRemoveFromEventList>
    2986:	88 23       	and	r24, r24
    2988:	11 f0       	breq	.+4      	; 0x298e <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    298a:	0e 94 05 25 	call	0x4a0a	; 0x4a0a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    298e:	8a 81       	ldd	r24, Y+2	; 0x02
    2990:	81 50       	subi	r24, 0x01	; 1
    2992:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2994:	8a 81       	ldd	r24, Y+2	; 0x02
    2996:	18 16       	cp	r1, r24
    2998:	64 f3       	brlt	.-40     	; 0x2972 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    299a:	eb 81       	ldd	r30, Y+3	; 0x03
    299c:	fc 81       	ldd	r31, Y+4	; 0x04
    299e:	8f ef       	ldi	r24, 0xFF	; 255
    29a0:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    29a2:	0f 90       	pop	r0
    29a4:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    29a6:	0f b6       	in	r0, 0x3f	; 63
    29a8:	f8 94       	cli
    29aa:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    29ac:	eb 81       	ldd	r30, Y+3	; 0x03
    29ae:	fc 81       	ldd	r31, Y+4	; 0x04
    29b0:	85 8d       	ldd	r24, Z+29	; 0x1d
    29b2:	89 83       	std	Y+1, r24	; 0x01
    29b4:	11 c0       	rjmp	.+34     	; 0x29d8 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    29b6:	eb 81       	ldd	r30, Y+3	; 0x03
    29b8:	fc 81       	ldd	r31, Y+4	; 0x04
    29ba:	80 85       	ldd	r24, Z+8	; 0x08
    29bc:	88 23       	and	r24, r24
    29be:	79 f0       	breq	.+30     	; 0x29de <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    29c0:	8b 81       	ldd	r24, Y+3	; 0x03
    29c2:	9c 81       	ldd	r25, Y+4	; 0x04
    29c4:	08 96       	adiw	r24, 0x08	; 8
    29c6:	0e 94 99 23 	call	0x4732	; 0x4732 <xTaskRemoveFromEventList>
    29ca:	88 23       	and	r24, r24
    29cc:	11 f0       	breq	.+4      	; 0x29d2 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    29ce:	0e 94 05 25 	call	0x4a0a	; 0x4a0a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    29d2:	89 81       	ldd	r24, Y+1	; 0x01
    29d4:	81 50       	subi	r24, 0x01	; 1
    29d6:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    29d8:	89 81       	ldd	r24, Y+1	; 0x01
    29da:	18 16       	cp	r1, r24
    29dc:	64 f3       	brlt	.-40     	; 0x29b6 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    29de:	eb 81       	ldd	r30, Y+3	; 0x03
    29e0:	fc 81       	ldd	r31, Y+4	; 0x04
    29e2:	8f ef       	ldi	r24, 0xFF	; 255
    29e4:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    29e6:	0f 90       	pop	r0
    29e8:	0f be       	out	0x3f, r0	; 63
}
    29ea:	0f 90       	pop	r0
    29ec:	0f 90       	pop	r0
    29ee:	0f 90       	pop	r0
    29f0:	0f 90       	pop	r0
    29f2:	cf 91       	pop	r28
    29f4:	df 91       	pop	r29
    29f6:	08 95       	ret

000029f8 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    29f8:	df 93       	push	r29
    29fa:	cf 93       	push	r28
    29fc:	00 d0       	rcall	.+0      	; 0x29fe <prvIsQueueEmpty+0x6>
    29fe:	0f 92       	push	r0
    2a00:	cd b7       	in	r28, 0x3d	; 61
    2a02:	de b7       	in	r29, 0x3e	; 62
    2a04:	9b 83       	std	Y+3, r25	; 0x03
    2a06:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2a08:	0f b6       	in	r0, 0x3f	; 63
    2a0a:	f8 94       	cli
    2a0c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2a0e:	ea 81       	ldd	r30, Y+2	; 0x02
    2a10:	fb 81       	ldd	r31, Y+3	; 0x03
    2a12:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a14:	88 23       	and	r24, r24
    2a16:	19 f4       	brne	.+6      	; 0x2a1e <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2a18:	81 e0       	ldi	r24, 0x01	; 1
    2a1a:	89 83       	std	Y+1, r24	; 0x01
    2a1c:	01 c0       	rjmp	.+2      	; 0x2a20 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2a1e:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2a20:	0f 90       	pop	r0
    2a22:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2a24:	89 81       	ldd	r24, Y+1	; 0x01
}
    2a26:	0f 90       	pop	r0
    2a28:	0f 90       	pop	r0
    2a2a:	0f 90       	pop	r0
    2a2c:	cf 91       	pop	r28
    2a2e:	df 91       	pop	r29
    2a30:	08 95       	ret

00002a32 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2a32:	df 93       	push	r29
    2a34:	cf 93       	push	r28
    2a36:	00 d0       	rcall	.+0      	; 0x2a38 <xQueueIsQueueEmptyFromISR+0x6>
    2a38:	00 d0       	rcall	.+0      	; 0x2a3a <xQueueIsQueueEmptyFromISR+0x8>
    2a3a:	0f 92       	push	r0
    2a3c:	cd b7       	in	r28, 0x3d	; 61
    2a3e:	de b7       	in	r29, 0x3e	; 62
    2a40:	9d 83       	std	Y+5, r25	; 0x05
    2a42:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2a44:	8c 81       	ldd	r24, Y+4	; 0x04
    2a46:	9d 81       	ldd	r25, Y+5	; 0x05
    2a48:	9a 83       	std	Y+2, r25	; 0x02
    2a4a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2a4c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a4e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a50:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a52:	88 23       	and	r24, r24
    2a54:	19 f4       	brne	.+6      	; 0x2a5c <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    2a56:	81 e0       	ldi	r24, 0x01	; 1
    2a58:	8b 83       	std	Y+3, r24	; 0x03
    2a5a:	01 c0       	rjmp	.+2      	; 0x2a5e <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    2a5c:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2a5e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2a60:	0f 90       	pop	r0
    2a62:	0f 90       	pop	r0
    2a64:	0f 90       	pop	r0
    2a66:	0f 90       	pop	r0
    2a68:	0f 90       	pop	r0
    2a6a:	cf 91       	pop	r28
    2a6c:	df 91       	pop	r29
    2a6e:	08 95       	ret

00002a70 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2a70:	df 93       	push	r29
    2a72:	cf 93       	push	r28
    2a74:	00 d0       	rcall	.+0      	; 0x2a76 <prvIsQueueFull+0x6>
    2a76:	0f 92       	push	r0
    2a78:	cd b7       	in	r28, 0x3d	; 61
    2a7a:	de b7       	in	r29, 0x3e	; 62
    2a7c:	9b 83       	std	Y+3, r25	; 0x03
    2a7e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2a80:	0f b6       	in	r0, 0x3f	; 63
    2a82:	f8 94       	cli
    2a84:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2a86:	ea 81       	ldd	r30, Y+2	; 0x02
    2a88:	fb 81       	ldd	r31, Y+3	; 0x03
    2a8a:	92 8d       	ldd	r25, Z+26	; 0x1a
    2a8c:	ea 81       	ldd	r30, Y+2	; 0x02
    2a8e:	fb 81       	ldd	r31, Y+3	; 0x03
    2a90:	83 8d       	ldd	r24, Z+27	; 0x1b
    2a92:	98 17       	cp	r25, r24
    2a94:	19 f4       	brne	.+6      	; 0x2a9c <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2a96:	81 e0       	ldi	r24, 0x01	; 1
    2a98:	89 83       	std	Y+1, r24	; 0x01
    2a9a:	01 c0       	rjmp	.+2      	; 0x2a9e <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2a9c:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2a9e:	0f 90       	pop	r0
    2aa0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2aa2:	89 81       	ldd	r24, Y+1	; 0x01
}
    2aa4:	0f 90       	pop	r0
    2aa6:	0f 90       	pop	r0
    2aa8:	0f 90       	pop	r0
    2aaa:	cf 91       	pop	r28
    2aac:	df 91       	pop	r29
    2aae:	08 95       	ret

00002ab0 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2ab0:	df 93       	push	r29
    2ab2:	cf 93       	push	r28
    2ab4:	00 d0       	rcall	.+0      	; 0x2ab6 <xQueueIsQueueFullFromISR+0x6>
    2ab6:	00 d0       	rcall	.+0      	; 0x2ab8 <xQueueIsQueueFullFromISR+0x8>
    2ab8:	0f 92       	push	r0
    2aba:	cd b7       	in	r28, 0x3d	; 61
    2abc:	de b7       	in	r29, 0x3e	; 62
    2abe:	9d 83       	std	Y+5, r25	; 0x05
    2ac0:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2ac2:	8c 81       	ldd	r24, Y+4	; 0x04
    2ac4:	9d 81       	ldd	r25, Y+5	; 0x05
    2ac6:	9a 83       	std	Y+2, r25	; 0x02
    2ac8:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2aca:	e9 81       	ldd	r30, Y+1	; 0x01
    2acc:	fa 81       	ldd	r31, Y+2	; 0x02
    2ace:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ad0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ad2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ad4:	83 8d       	ldd	r24, Z+27	; 0x1b
    2ad6:	98 17       	cp	r25, r24
    2ad8:	19 f4       	brne	.+6      	; 0x2ae0 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2ada:	81 e0       	ldi	r24, 0x01	; 1
    2adc:	8b 83       	std	Y+3, r24	; 0x03
    2ade:	01 c0       	rjmp	.+2      	; 0x2ae2 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    2ae0:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2ae2:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2ae4:	0f 90       	pop	r0
    2ae6:	0f 90       	pop	r0
    2ae8:	0f 90       	pop	r0
    2aea:	0f 90       	pop	r0
    2aec:	0f 90       	pop	r0
    2aee:	cf 91       	pop	r28
    2af0:	df 91       	pop	r29
    2af2:	08 95       	ret

00002af4 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    2af4:	0f 93       	push	r16
    2af6:	df 93       	push	r29
    2af8:	cf 93       	push	r28
    2afa:	cd b7       	in	r28, 0x3d	; 61
    2afc:	de b7       	in	r29, 0x3e	; 62
    2afe:	28 97       	sbiw	r28, 0x08	; 8
    2b00:	0f b6       	in	r0, 0x3f	; 63
    2b02:	f8 94       	cli
    2b04:	de bf       	out	0x3e, r29	; 62
    2b06:	0f be       	out	0x3f, r0	; 63
    2b08:	cd bf       	out	0x3d, r28	; 61
    2b0a:	9d 83       	std	Y+5, r25	; 0x05
    2b0c:	8c 83       	std	Y+4, r24	; 0x04
    2b0e:	7f 83       	std	Y+7, r23	; 0x07
    2b10:	6e 83       	std	Y+6, r22	; 0x06
    2b12:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    2b14:	88 85       	ldd	r24, Y+8	; 0x08
    2b16:	81 30       	cpi	r24, 0x01	; 1
    2b18:	19 f4       	brne	.+6      	; 0x2b20 <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    2b1a:	81 e0       	ldi	r24, 0x01	; 1
    2b1c:	89 83       	std	Y+1, r24	; 0x01
    2b1e:	01 c0       	rjmp	.+2      	; 0x2b22 <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    2b20:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    2b22:	8e 81       	ldd	r24, Y+6	; 0x06
    2b24:	9f 81       	ldd	r25, Y+7	; 0x07
    2b26:	00 97       	sbiw	r24, 0x00	; 0
    2b28:	21 f4       	brne	.+8      	; 0x2b32 <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    2b2a:	81 e0       	ldi	r24, 0x01	; 1
    2b2c:	90 e0       	ldi	r25, 0x00	; 0
    2b2e:	9f 83       	std	Y+7, r25	; 0x07
    2b30:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    2b32:	8c 81       	ldd	r24, Y+4	; 0x04
    2b34:	9d 81       	ldd	r25, Y+5	; 0x05
    2b36:	01 96       	adiw	r24, 0x01	; 1
    2b38:	9d 83       	std	Y+5, r25	; 0x05
    2b3a:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    2b3c:	8c 81       	ldd	r24, Y+4	; 0x04
    2b3e:	9d 81       	ldd	r25, Y+5	; 0x05
    2b40:	0f 96       	adiw	r24, 0x0f	; 15
    2b42:	0e 94 1b 07 	call	0xe36	; 0xe36 <pvPortMalloc>
    2b46:	9b 83       	std	Y+3, r25	; 0x03
    2b48:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    2b4a:	8a 81       	ldd	r24, Y+2	; 0x02
    2b4c:	9b 81       	ldd	r25, Y+3	; 0x03
    2b4e:	00 97       	sbiw	r24, 0x00	; 0
    2b50:	89 f0       	breq	.+34     	; 0x2b74 <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    2b52:	6a 81       	ldd	r22, Y+2	; 0x02
    2b54:	7b 81       	ldd	r23, Y+3	; 0x03
    2b56:	8a 81       	ldd	r24, Y+2	; 0x02
    2b58:	9b 81       	ldd	r25, Y+3	; 0x03
    2b5a:	9c 01       	movw	r18, r24
    2b5c:	21 5f       	subi	r18, 0xF1	; 241
    2b5e:	3f 4f       	sbci	r19, 0xFF	; 255
    2b60:	4c 81       	ldd	r20, Y+4	; 0x04
    2b62:	5d 81       	ldd	r21, Y+5	; 0x05
    2b64:	ee 81       	ldd	r30, Y+6	; 0x06
    2b66:	ff 81       	ldd	r31, Y+7	; 0x07
    2b68:	cb 01       	movw	r24, r22
    2b6a:	b9 01       	movw	r22, r18
    2b6c:	9f 01       	movw	r18, r30
    2b6e:	09 81       	ldd	r16, Y+1	; 0x01
    2b70:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    2b74:	8a 81       	ldd	r24, Y+2	; 0x02
    2b76:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    2b78:	28 96       	adiw	r28, 0x08	; 8
    2b7a:	0f b6       	in	r0, 0x3f	; 63
    2b7c:	f8 94       	cli
    2b7e:	de bf       	out	0x3e, r29	; 62
    2b80:	0f be       	out	0x3f, r0	; 63
    2b82:	cd bf       	out	0x3d, r28	; 61
    2b84:	cf 91       	pop	r28
    2b86:	df 91       	pop	r29
    2b88:	0f 91       	pop	r16
    2b8a:	08 95       	ret

00002b8c <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    2b8c:	df 93       	push	r29
    2b8e:	cf 93       	push	r28
    2b90:	00 d0       	rcall	.+0      	; 0x2b92 <vStreamBufferDelete+0x6>
    2b92:	00 d0       	rcall	.+0      	; 0x2b94 <vStreamBufferDelete+0x8>
    2b94:	cd b7       	in	r28, 0x3d	; 61
    2b96:	de b7       	in	r29, 0x3e	; 62
    2b98:	9c 83       	std	Y+4, r25	; 0x04
    2b9a:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    2b9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b9e:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba0:	9a 83       	std	Y+2, r25	; 0x02
    2ba2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    2ba4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ba6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ba8:	86 85       	ldd	r24, Z+14	; 0x0e
    2baa:	88 2f       	mov	r24, r24
    2bac:	90 e0       	ldi	r25, 0x00	; 0
    2bae:	82 70       	andi	r24, 0x02	; 2
    2bb0:	90 70       	andi	r25, 0x00	; 0
    2bb2:	00 97       	sbiw	r24, 0x00	; 0
    2bb4:	29 f4       	brne	.+10     	; 0x2bc0 <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    2bb6:	89 81       	ldd	r24, Y+1	; 0x01
    2bb8:	9a 81       	ldd	r25, Y+2	; 0x02
    2bba:	0e 94 71 07 	call	0xee2	; 0xee2 <vPortFree>
    2bbe:	08 c0       	rjmp	.+16     	; 0x2bd0 <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    2bc0:	89 81       	ldd	r24, Y+1	; 0x01
    2bc2:	9a 81       	ldd	r25, Y+2	; 0x02
    2bc4:	60 e0       	ldi	r22, 0x00	; 0
    2bc6:	70 e0       	ldi	r23, 0x00	; 0
    2bc8:	4f e0       	ldi	r20, 0x0F	; 15
    2bca:	50 e0       	ldi	r21, 0x00	; 0
    2bcc:	0e 94 30 2a 	call	0x5460	; 0x5460 <memset>
	}
}
    2bd0:	0f 90       	pop	r0
    2bd2:	0f 90       	pop	r0
    2bd4:	0f 90       	pop	r0
    2bd6:	0f 90       	pop	r0
    2bd8:	cf 91       	pop	r28
    2bda:	df 91       	pop	r29
    2bdc:	08 95       	ret

00002bde <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    2bde:	0f 93       	push	r16
    2be0:	df 93       	push	r29
    2be2:	cf 93       	push	r28
    2be4:	00 d0       	rcall	.+0      	; 0x2be6 <xStreamBufferReset+0x8>
    2be6:	00 d0       	rcall	.+0      	; 0x2be8 <xStreamBufferReset+0xa>
    2be8:	0f 92       	push	r0
    2bea:	cd b7       	in	r28, 0x3d	; 61
    2bec:	de b7       	in	r29, 0x3e	; 62
    2bee:	9d 83       	std	Y+5, r25	; 0x05
    2bf0:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2bf2:	8c 81       	ldd	r24, Y+4	; 0x04
    2bf4:	9d 81       	ldd	r25, Y+5	; 0x05
    2bf6:	9b 83       	std	Y+3, r25	; 0x03
    2bf8:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    2bfa:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    2bfc:	0f b6       	in	r0, 0x3f	; 63
    2bfe:	f8 94       	cli
    2c00:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    2c02:	ea 81       	ldd	r30, Y+2	; 0x02
    2c04:	fb 81       	ldd	r31, Y+3	; 0x03
    2c06:	80 85       	ldd	r24, Z+8	; 0x08
    2c08:	91 85       	ldd	r25, Z+9	; 0x09
    2c0a:	00 97       	sbiw	r24, 0x00	; 0
    2c0c:	f1 f4       	brne	.+60     	; 0x2c4a <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    2c0e:	ea 81       	ldd	r30, Y+2	; 0x02
    2c10:	fb 81       	ldd	r31, Y+3	; 0x03
    2c12:	82 85       	ldd	r24, Z+10	; 0x0a
    2c14:	93 85       	ldd	r25, Z+11	; 0x0b
    2c16:	00 97       	sbiw	r24, 0x00	; 0
    2c18:	c1 f4       	brne	.+48     	; 0x2c4a <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    2c1a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c1c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c1e:	24 85       	ldd	r18, Z+12	; 0x0c
    2c20:	35 85       	ldd	r19, Z+13	; 0x0d
    2c22:	ea 81       	ldd	r30, Y+2	; 0x02
    2c24:	fb 81       	ldd	r31, Y+3	; 0x03
    2c26:	44 81       	ldd	r20, Z+4	; 0x04
    2c28:	55 81       	ldd	r21, Z+5	; 0x05
    2c2a:	ea 81       	ldd	r30, Y+2	; 0x02
    2c2c:	fb 81       	ldd	r31, Y+3	; 0x03
    2c2e:	a6 81       	ldd	r26, Z+6	; 0x06
    2c30:	b7 81       	ldd	r27, Z+7	; 0x07
    2c32:	ea 81       	ldd	r30, Y+2	; 0x02
    2c34:	fb 81       	ldd	r31, Y+3	; 0x03
    2c36:	e6 85       	ldd	r30, Z+14	; 0x0e
    2c38:	8a 81       	ldd	r24, Y+2	; 0x02
    2c3a:	9b 81       	ldd	r25, Y+3	; 0x03
    2c3c:	b9 01       	movw	r22, r18
    2c3e:	9d 01       	movw	r18, r26
    2c40:	0e 2f       	mov	r16, r30
    2c42:	0e 94 d2 1c 	call	0x39a4	; 0x39a4 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    2c46:	81 e0       	ldi	r24, 0x01	; 1
    2c48:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    2c4a:	0f 90       	pop	r0
    2c4c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2c4e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2c50:	0f 90       	pop	r0
    2c52:	0f 90       	pop	r0
    2c54:	0f 90       	pop	r0
    2c56:	0f 90       	pop	r0
    2c58:	0f 90       	pop	r0
    2c5a:	cf 91       	pop	r28
    2c5c:	df 91       	pop	r29
    2c5e:	0f 91       	pop	r16
    2c60:	08 95       	ret

00002c62 <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    2c62:	df 93       	push	r29
    2c64:	cf 93       	push	r28
    2c66:	cd b7       	in	r28, 0x3d	; 61
    2c68:	de b7       	in	r29, 0x3e	; 62
    2c6a:	27 97       	sbiw	r28, 0x07	; 7
    2c6c:	0f b6       	in	r0, 0x3f	; 63
    2c6e:	f8 94       	cli
    2c70:	de bf       	out	0x3e, r29	; 62
    2c72:	0f be       	out	0x3f, r0	; 63
    2c74:	cd bf       	out	0x3d, r28	; 61
    2c76:	9d 83       	std	Y+5, r25	; 0x05
    2c78:	8c 83       	std	Y+4, r24	; 0x04
    2c7a:	7f 83       	std	Y+7, r23	; 0x07
    2c7c:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2c7e:	8c 81       	ldd	r24, Y+4	; 0x04
    2c80:	9d 81       	ldd	r25, Y+5	; 0x05
    2c82:	9b 83       	std	Y+3, r25	; 0x03
    2c84:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    2c86:	8e 81       	ldd	r24, Y+6	; 0x06
    2c88:	9f 81       	ldd	r25, Y+7	; 0x07
    2c8a:	00 97       	sbiw	r24, 0x00	; 0
    2c8c:	21 f4       	brne	.+8      	; 0x2c96 <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    2c8e:	81 e0       	ldi	r24, 0x01	; 1
    2c90:	90 e0       	ldi	r25, 0x00	; 0
    2c92:	9f 83       	std	Y+7, r25	; 0x07
    2c94:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    2c96:	ea 81       	ldd	r30, Y+2	; 0x02
    2c98:	fb 81       	ldd	r31, Y+3	; 0x03
    2c9a:	24 81       	ldd	r18, Z+4	; 0x04
    2c9c:	35 81       	ldd	r19, Z+5	; 0x05
    2c9e:	8e 81       	ldd	r24, Y+6	; 0x06
    2ca0:	9f 81       	ldd	r25, Y+7	; 0x07
    2ca2:	28 17       	cp	r18, r24
    2ca4:	39 07       	cpc	r19, r25
    2ca6:	48 f0       	brcs	.+18     	; 0x2cba <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    2ca8:	ea 81       	ldd	r30, Y+2	; 0x02
    2caa:	fb 81       	ldd	r31, Y+3	; 0x03
    2cac:	8e 81       	ldd	r24, Y+6	; 0x06
    2cae:	9f 81       	ldd	r25, Y+7	; 0x07
    2cb0:	97 83       	std	Z+7, r25	; 0x07
    2cb2:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    2cb4:	81 e0       	ldi	r24, 0x01	; 1
    2cb6:	89 83       	std	Y+1, r24	; 0x01
    2cb8:	01 c0       	rjmp	.+2      	; 0x2cbc <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    2cba:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2cbc:	89 81       	ldd	r24, Y+1	; 0x01
}
    2cbe:	27 96       	adiw	r28, 0x07	; 7
    2cc0:	0f b6       	in	r0, 0x3f	; 63
    2cc2:	f8 94       	cli
    2cc4:	de bf       	out	0x3e, r29	; 62
    2cc6:	0f be       	out	0x3f, r0	; 63
    2cc8:	cd bf       	out	0x3d, r28	; 61
    2cca:	cf 91       	pop	r28
    2ccc:	df 91       	pop	r29
    2cce:	08 95       	ret

00002cd0 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2cd0:	df 93       	push	r29
    2cd2:	cf 93       	push	r28
    2cd4:	00 d0       	rcall	.+0      	; 0x2cd6 <xStreamBufferSpacesAvailable+0x6>
    2cd6:	00 d0       	rcall	.+0      	; 0x2cd8 <xStreamBufferSpacesAvailable+0x8>
    2cd8:	00 d0       	rcall	.+0      	; 0x2cda <xStreamBufferSpacesAvailable+0xa>
    2cda:	cd b7       	in	r28, 0x3d	; 61
    2cdc:	de b7       	in	r29, 0x3e	; 62
    2cde:	9e 83       	std	Y+6, r25	; 0x06
    2ce0:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2ce2:	8d 81       	ldd	r24, Y+5	; 0x05
    2ce4:	9e 81       	ldd	r25, Y+6	; 0x06
    2ce6:	9c 83       	std	Y+4, r25	; 0x04
    2ce8:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2cea:	eb 81       	ldd	r30, Y+3	; 0x03
    2cec:	fc 81       	ldd	r31, Y+4	; 0x04
    2cee:	24 81       	ldd	r18, Z+4	; 0x04
    2cf0:	35 81       	ldd	r19, Z+5	; 0x05
    2cf2:	eb 81       	ldd	r30, Y+3	; 0x03
    2cf4:	fc 81       	ldd	r31, Y+4	; 0x04
    2cf6:	80 81       	ld	r24, Z
    2cf8:	91 81       	ldd	r25, Z+1	; 0x01
    2cfa:	82 0f       	add	r24, r18
    2cfc:	93 1f       	adc	r25, r19
    2cfe:	9a 83       	std	Y+2, r25	; 0x02
    2d00:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    2d02:	eb 81       	ldd	r30, Y+3	; 0x03
    2d04:	fc 81       	ldd	r31, Y+4	; 0x04
    2d06:	22 81       	ldd	r18, Z+2	; 0x02
    2d08:	33 81       	ldd	r19, Z+3	; 0x03
    2d0a:	89 81       	ldd	r24, Y+1	; 0x01
    2d0c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d0e:	82 1b       	sub	r24, r18
    2d10:	93 0b       	sbc	r25, r19
    2d12:	9a 83       	std	Y+2, r25	; 0x02
    2d14:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    2d16:	89 81       	ldd	r24, Y+1	; 0x01
    2d18:	9a 81       	ldd	r25, Y+2	; 0x02
    2d1a:	01 97       	sbiw	r24, 0x01	; 1
    2d1c:	9a 83       	std	Y+2, r25	; 0x02
    2d1e:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    2d20:	eb 81       	ldd	r30, Y+3	; 0x03
    2d22:	fc 81       	ldd	r31, Y+4	; 0x04
    2d24:	24 81       	ldd	r18, Z+4	; 0x04
    2d26:	35 81       	ldd	r19, Z+5	; 0x05
    2d28:	89 81       	ldd	r24, Y+1	; 0x01
    2d2a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d2c:	82 17       	cp	r24, r18
    2d2e:	93 07       	cpc	r25, r19
    2d30:	50 f0       	brcs	.+20     	; 0x2d46 <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    2d32:	eb 81       	ldd	r30, Y+3	; 0x03
    2d34:	fc 81       	ldd	r31, Y+4	; 0x04
    2d36:	24 81       	ldd	r18, Z+4	; 0x04
    2d38:	35 81       	ldd	r19, Z+5	; 0x05
    2d3a:	89 81       	ldd	r24, Y+1	; 0x01
    2d3c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d3e:	82 1b       	sub	r24, r18
    2d40:	93 0b       	sbc	r25, r19
    2d42:	9a 83       	std	Y+2, r25	; 0x02
    2d44:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    2d46:	89 81       	ldd	r24, Y+1	; 0x01
    2d48:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d4a:	26 96       	adiw	r28, 0x06	; 6
    2d4c:	0f b6       	in	r0, 0x3f	; 63
    2d4e:	f8 94       	cli
    2d50:	de bf       	out	0x3e, r29	; 62
    2d52:	0f be       	out	0x3f, r0	; 63
    2d54:	cd bf       	out	0x3d, r28	; 61
    2d56:	cf 91       	pop	r28
    2d58:	df 91       	pop	r29
    2d5a:	08 95       	ret

00002d5c <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2d5c:	df 93       	push	r29
    2d5e:	cf 93       	push	r28
    2d60:	00 d0       	rcall	.+0      	; 0x2d62 <xStreamBufferBytesAvailable+0x6>
    2d62:	00 d0       	rcall	.+0      	; 0x2d64 <xStreamBufferBytesAvailable+0x8>
    2d64:	00 d0       	rcall	.+0      	; 0x2d66 <xStreamBufferBytesAvailable+0xa>
    2d66:	cd b7       	in	r28, 0x3d	; 61
    2d68:	de b7       	in	r29, 0x3e	; 62
    2d6a:	9e 83       	std	Y+6, r25	; 0x06
    2d6c:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2d6e:	8d 81       	ldd	r24, Y+5	; 0x05
    2d70:	9e 81       	ldd	r25, Y+6	; 0x06
    2d72:	9c 83       	std	Y+4, r25	; 0x04
    2d74:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    2d76:	8b 81       	ldd	r24, Y+3	; 0x03
    2d78:	9c 81       	ldd	r25, Y+4	; 0x04
    2d7a:	0e 94 98 1c 	call	0x3930	; 0x3930 <prvBytesInBuffer>
    2d7e:	9a 83       	std	Y+2, r25	; 0x02
    2d80:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    2d82:	89 81       	ldd	r24, Y+1	; 0x01
    2d84:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2d86:	26 96       	adiw	r28, 0x06	; 6
    2d88:	0f b6       	in	r0, 0x3f	; 63
    2d8a:	f8 94       	cli
    2d8c:	de bf       	out	0x3e, r29	; 62
    2d8e:	0f be       	out	0x3f, r0	; 63
    2d90:	cd bf       	out	0x3d, r28	; 61
    2d92:	cf 91       	pop	r28
    2d94:	df 91       	pop	r29
    2d96:	08 95       	ret

00002d98 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    2d98:	ef 92       	push	r14
    2d9a:	ff 92       	push	r15
    2d9c:	0f 93       	push	r16
    2d9e:	1f 93       	push	r17
    2da0:	df 93       	push	r29
    2da2:	cf 93       	push	r28
    2da4:	cd b7       	in	r28, 0x3d	; 61
    2da6:	de b7       	in	r29, 0x3e	; 62
    2da8:	63 97       	sbiw	r28, 0x13	; 19
    2daa:	0f b6       	in	r0, 0x3f	; 63
    2dac:	f8 94       	cli
    2dae:	de bf       	out	0x3e, r29	; 62
    2db0:	0f be       	out	0x3f, r0	; 63
    2db2:	cd bf       	out	0x3d, r28	; 61
    2db4:	9d 87       	std	Y+13, r25	; 0x0d
    2db6:	8c 87       	std	Y+12, r24	; 0x0c
    2db8:	7f 87       	std	Y+15, r23	; 0x0f
    2dba:	6e 87       	std	Y+14, r22	; 0x0e
    2dbc:	59 8b       	std	Y+17, r21	; 0x11
    2dbe:	48 8b       	std	Y+16, r20	; 0x10
    2dc0:	3b 8b       	std	Y+19, r19	; 0x13
    2dc2:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2dc4:	8c 85       	ldd	r24, Y+12	; 0x0c
    2dc6:	9d 85       	ldd	r25, Y+13	; 0x0d
    2dc8:	98 87       	std	Y+8, r25	; 0x08
    2dca:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    2dcc:	1c 82       	std	Y+4, r1	; 0x04
    2dce:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    2dd0:	88 89       	ldd	r24, Y+16	; 0x10
    2dd2:	99 89       	ldd	r25, Y+17	; 0x11
    2dd4:	9a 83       	std	Y+2, r25	; 0x02
    2dd6:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2dd8:	ef 81       	ldd	r30, Y+7	; 0x07
    2dda:	f8 85       	ldd	r31, Y+8	; 0x08
    2ddc:	86 85       	ldd	r24, Z+14	; 0x0e
    2dde:	88 2f       	mov	r24, r24
    2de0:	90 e0       	ldi	r25, 0x00	; 0
    2de2:	81 70       	andi	r24, 0x01	; 1
    2de4:	90 70       	andi	r25, 0x00	; 0
    2de6:	88 23       	and	r24, r24
    2de8:	29 f0       	breq	.+10     	; 0x2df4 <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2dea:	89 81       	ldd	r24, Y+1	; 0x01
    2dec:	9a 81       	ldd	r25, Y+2	; 0x02
    2dee:	02 96       	adiw	r24, 0x02	; 2
    2df0:	9a 83       	std	Y+2, r25	; 0x02
    2df2:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    2df4:	8a 89       	ldd	r24, Y+18	; 0x12
    2df6:	9b 89       	ldd	r25, Y+19	; 0x13
    2df8:	00 97       	sbiw	r24, 0x00	; 0
    2dfa:	09 f4       	brne	.+2      	; 0x2dfe <xStreamBufferSend+0x66>
    2dfc:	40 c0       	rjmp	.+128    	; 0x2e7e <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    2dfe:	ce 01       	movw	r24, r28
    2e00:	09 96       	adiw	r24, 0x09	; 9
    2e02:	0e 94 61 24 	call	0x48c2	; 0x48c2 <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    2e06:	0f b6       	in	r0, 0x3f	; 63
    2e08:	f8 94       	cli
    2e0a:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2e0c:	8f 81       	ldd	r24, Y+7	; 0x07
    2e0e:	98 85       	ldd	r25, Y+8	; 0x08
    2e10:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xStreamBufferSpacesAvailable>
    2e14:	9c 83       	std	Y+4, r25	; 0x04
    2e16:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    2e18:	2b 81       	ldd	r18, Y+3	; 0x03
    2e1a:	3c 81       	ldd	r19, Y+4	; 0x04
    2e1c:	89 81       	ldd	r24, Y+1	; 0x01
    2e1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e20:	28 17       	cp	r18, r24
    2e22:	39 07       	cpc	r19, r25
    2e24:	50 f5       	brcc	.+84     	; 0x2e7a <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    2e26:	80 e0       	ldi	r24, 0x00	; 0
    2e28:	90 e0       	ldi	r25, 0x00	; 0
    2e2a:	0e 94 71 29 	call	0x52e2	; 0x52e2 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    2e2e:	0e 94 ca 25 	call	0x4b94	; 0x4b94 <xTaskGetCurrentTaskHandle>
    2e32:	ef 81       	ldd	r30, Y+7	; 0x07
    2e34:	f8 85       	ldd	r31, Y+8	; 0x08
    2e36:	93 87       	std	Z+11, r25	; 0x0b
    2e38:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    2e3a:	0f 90       	pop	r0
    2e3c:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2e3e:	ea 89       	ldd	r30, Y+18	; 0x12
    2e40:	fb 89       	ldd	r31, Y+19	; 0x13
    2e42:	60 e0       	ldi	r22, 0x00	; 0
    2e44:	70 e0       	ldi	r23, 0x00	; 0
    2e46:	80 e0       	ldi	r24, 0x00	; 0
    2e48:	90 e0       	ldi	r25, 0x00	; 0
    2e4a:	20 e0       	ldi	r18, 0x00	; 0
    2e4c:	30 e0       	ldi	r19, 0x00	; 0
    2e4e:	40 e0       	ldi	r20, 0x00	; 0
    2e50:	50 e0       	ldi	r21, 0x00	; 0
    2e52:	00 e0       	ldi	r16, 0x00	; 0
    2e54:	10 e0       	ldi	r17, 0x00	; 0
    2e56:	7f 01       	movw	r14, r30
    2e58:	0e 94 7a 26 	call	0x4cf4	; 0x4cf4 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    2e5c:	ef 81       	ldd	r30, Y+7	; 0x07
    2e5e:	f8 85       	ldd	r31, Y+8	; 0x08
    2e60:	13 86       	std	Z+11, r1	; 0x0b
    2e62:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    2e64:	ce 01       	movw	r24, r28
    2e66:	09 96       	adiw	r24, 0x09	; 9
    2e68:	9e 01       	movw	r18, r28
    2e6a:	2e 5e       	subi	r18, 0xEE	; 238
    2e6c:	3f 4f       	sbci	r19, 0xFF	; 255
    2e6e:	b9 01       	movw	r22, r18
    2e70:	0e 94 98 24 	call	0x4930	; 0x4930 <xTaskCheckForTimeOut>
    2e74:	88 23       	and	r24, r24
    2e76:	39 f2       	breq	.-114    	; 0x2e06 <xStreamBufferSend+0x6e>
    2e78:	02 c0       	rjmp	.+4      	; 0x2e7e <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    2e7a:	0f 90       	pop	r0
    2e7c:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    2e7e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e80:	9c 81       	ldd	r25, Y+4	; 0x04
    2e82:	00 97       	sbiw	r24, 0x00	; 0
    2e84:	31 f4       	brne	.+12     	; 0x2e92 <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2e86:	8f 81       	ldd	r24, Y+7	; 0x07
    2e88:	98 85       	ldd	r25, Y+8	; 0x08
    2e8a:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xStreamBufferSpacesAvailable>
    2e8e:	9c 83       	std	Y+4, r25	; 0x04
    2e90:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2e92:	8f 81       	ldd	r24, Y+7	; 0x07
    2e94:	98 85       	ldd	r25, Y+8	; 0x08
    2e96:	2e 85       	ldd	r18, Y+14	; 0x0e
    2e98:	3f 85       	ldd	r19, Y+15	; 0x0f
    2e9a:	48 89       	ldd	r20, Y+16	; 0x10
    2e9c:	59 89       	ldd	r21, Y+17	; 0x11
    2e9e:	eb 81       	ldd	r30, Y+3	; 0x03
    2ea0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ea2:	a9 81       	ldd	r26, Y+1	; 0x01
    2ea4:	ba 81       	ldd	r27, Y+2	; 0x02
    2ea6:	b9 01       	movw	r22, r18
    2ea8:	9f 01       	movw	r18, r30
    2eaa:	8d 01       	movw	r16, r26
    2eac:	0e 94 11 18 	call	0x3022	; 0x3022 <prvWriteMessageToBuffer>
    2eb0:	9e 83       	std	Y+6, r25	; 0x06
    2eb2:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    2eb4:	8d 81       	ldd	r24, Y+5	; 0x05
    2eb6:	9e 81       	ldd	r25, Y+6	; 0x06
    2eb8:	00 97       	sbiw	r24, 0x00	; 0
    2eba:	39 f1       	breq	.+78     	; 0x2f0a <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2ebc:	8f 81       	ldd	r24, Y+7	; 0x07
    2ebe:	98 85       	ldd	r25, Y+8	; 0x08
    2ec0:	0e 94 98 1c 	call	0x3930	; 0x3930 <prvBytesInBuffer>
    2ec4:	9c 01       	movw	r18, r24
    2ec6:	ef 81       	ldd	r30, Y+7	; 0x07
    2ec8:	f8 85       	ldd	r31, Y+8	; 0x08
    2eca:	86 81       	ldd	r24, Z+6	; 0x06
    2ecc:	97 81       	ldd	r25, Z+7	; 0x07
    2ece:	28 17       	cp	r18, r24
    2ed0:	39 07       	cpc	r19, r25
    2ed2:	d8 f0       	brcs	.+54     	; 0x2f0a <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    2ed4:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <vTaskSuspendAll>
    2ed8:	ef 81       	ldd	r30, Y+7	; 0x07
    2eda:	f8 85       	ldd	r31, Y+8	; 0x08
    2edc:	80 85       	ldd	r24, Z+8	; 0x08
    2ede:	91 85       	ldd	r25, Z+9	; 0x09
    2ee0:	00 97       	sbiw	r24, 0x00	; 0
    2ee2:	89 f0       	breq	.+34     	; 0x2f06 <xStreamBufferSend+0x16e>
    2ee4:	ef 81       	ldd	r30, Y+7	; 0x07
    2ee6:	f8 85       	ldd	r31, Y+8	; 0x08
    2ee8:	80 85       	ldd	r24, Z+8	; 0x08
    2eea:	91 85       	ldd	r25, Z+9	; 0x09
    2eec:	40 e0       	ldi	r20, 0x00	; 0
    2eee:	50 e0       	ldi	r21, 0x00	; 0
    2ef0:	60 e0       	ldi	r22, 0x00	; 0
    2ef2:	70 e0       	ldi	r23, 0x00	; 0
    2ef4:	20 e0       	ldi	r18, 0x00	; 0
    2ef6:	00 e0       	ldi	r16, 0x00	; 0
    2ef8:	10 e0       	ldi	r17, 0x00	; 0
    2efa:	0e 94 16 27 	call	0x4e2c	; 0x4e2c <xTaskGenericNotify>
    2efe:	ef 81       	ldd	r30, Y+7	; 0x07
    2f00:	f8 85       	ldd	r31, Y+8	; 0x08
    2f02:	11 86       	std	Z+9, r1	; 0x09
    2f04:	10 86       	std	Z+8, r1	; 0x08
    2f06:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    2f0a:	8d 81       	ldd	r24, Y+5	; 0x05
    2f0c:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2f0e:	63 96       	adiw	r28, 0x13	; 19
    2f10:	0f b6       	in	r0, 0x3f	; 63
    2f12:	f8 94       	cli
    2f14:	de bf       	out	0x3e, r29	; 62
    2f16:	0f be       	out	0x3f, r0	; 63
    2f18:	cd bf       	out	0x3d, r28	; 61
    2f1a:	cf 91       	pop	r28
    2f1c:	df 91       	pop	r29
    2f1e:	1f 91       	pop	r17
    2f20:	0f 91       	pop	r16
    2f22:	ff 90       	pop	r15
    2f24:	ef 90       	pop	r14
    2f26:	08 95       	ret

00002f28 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2f28:	ef 92       	push	r14
    2f2a:	ff 92       	push	r15
    2f2c:	0f 93       	push	r16
    2f2e:	1f 93       	push	r17
    2f30:	df 93       	push	r29
    2f32:	cf 93       	push	r28
    2f34:	cd b7       	in	r28, 0x3d	; 61
    2f36:	de b7       	in	r29, 0x3e	; 62
    2f38:	61 97       	sbiw	r28, 0x11	; 17
    2f3a:	0f b6       	in	r0, 0x3f	; 63
    2f3c:	f8 94       	cli
    2f3e:	de bf       	out	0x3e, r29	; 62
    2f40:	0f be       	out	0x3f, r0	; 63
    2f42:	cd bf       	out	0x3d, r28	; 61
    2f44:	9b 87       	std	Y+11, r25	; 0x0b
    2f46:	8a 87       	std	Y+10, r24	; 0x0a
    2f48:	7d 87       	std	Y+13, r23	; 0x0d
    2f4a:	6c 87       	std	Y+12, r22	; 0x0c
    2f4c:	5f 87       	std	Y+15, r21	; 0x0f
    2f4e:	4e 87       	std	Y+14, r20	; 0x0e
    2f50:	39 8b       	std	Y+17, r19	; 0x11
    2f52:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2f54:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f56:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f58:	99 87       	std	Y+9, r25	; 0x09
    2f5a:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    2f5c:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f5e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2f60:	9b 83       	std	Y+3, r25	; 0x03
    2f62:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2f64:	e8 85       	ldd	r30, Y+8	; 0x08
    2f66:	f9 85       	ldd	r31, Y+9	; 0x09
    2f68:	86 85       	ldd	r24, Z+14	; 0x0e
    2f6a:	88 2f       	mov	r24, r24
    2f6c:	90 e0       	ldi	r25, 0x00	; 0
    2f6e:	81 70       	andi	r24, 0x01	; 1
    2f70:	90 70       	andi	r25, 0x00	; 0
    2f72:	88 23       	and	r24, r24
    2f74:	29 f0       	breq	.+10     	; 0x2f80 <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2f76:	8a 81       	ldd	r24, Y+2	; 0x02
    2f78:	9b 81       	ldd	r25, Y+3	; 0x03
    2f7a:	02 96       	adiw	r24, 0x02	; 2
    2f7c:	9b 83       	std	Y+3, r25	; 0x03
    2f7e:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2f80:	88 85       	ldd	r24, Y+8	; 0x08
    2f82:	99 85       	ldd	r25, Y+9	; 0x09
    2f84:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xStreamBufferSpacesAvailable>
    2f88:	9d 83       	std	Y+5, r25	; 0x05
    2f8a:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2f8c:	88 85       	ldd	r24, Y+8	; 0x08
    2f8e:	99 85       	ldd	r25, Y+9	; 0x09
    2f90:	2c 85       	ldd	r18, Y+12	; 0x0c
    2f92:	3d 85       	ldd	r19, Y+13	; 0x0d
    2f94:	4e 85       	ldd	r20, Y+14	; 0x0e
    2f96:	5f 85       	ldd	r21, Y+15	; 0x0f
    2f98:	ec 81       	ldd	r30, Y+4	; 0x04
    2f9a:	fd 81       	ldd	r31, Y+5	; 0x05
    2f9c:	aa 81       	ldd	r26, Y+2	; 0x02
    2f9e:	bb 81       	ldd	r27, Y+3	; 0x03
    2fa0:	b9 01       	movw	r22, r18
    2fa2:	9f 01       	movw	r18, r30
    2fa4:	8d 01       	movw	r16, r26
    2fa6:	0e 94 11 18 	call	0x3022	; 0x3022 <prvWriteMessageToBuffer>
    2faa:	9f 83       	std	Y+7, r25	; 0x07
    2fac:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    2fae:	8e 81       	ldd	r24, Y+6	; 0x06
    2fb0:	9f 81       	ldd	r25, Y+7	; 0x07
    2fb2:	00 97       	sbiw	r24, 0x00	; 0
    2fb4:	39 f1       	breq	.+78     	; 0x3004 <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2fb6:	88 85       	ldd	r24, Y+8	; 0x08
    2fb8:	99 85       	ldd	r25, Y+9	; 0x09
    2fba:	0e 94 98 1c 	call	0x3930	; 0x3930 <prvBytesInBuffer>
    2fbe:	9c 01       	movw	r18, r24
    2fc0:	e8 85       	ldd	r30, Y+8	; 0x08
    2fc2:	f9 85       	ldd	r31, Y+9	; 0x09
    2fc4:	86 81       	ldd	r24, Z+6	; 0x06
    2fc6:	97 81       	ldd	r25, Z+7	; 0x07
    2fc8:	28 17       	cp	r18, r24
    2fca:	39 07       	cpc	r19, r25
    2fcc:	d8 f0       	brcs	.+54     	; 0x3004 <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    2fce:	19 82       	std	Y+1, r1	; 0x01
    2fd0:	e8 85       	ldd	r30, Y+8	; 0x08
    2fd2:	f9 85       	ldd	r31, Y+9	; 0x09
    2fd4:	80 85       	ldd	r24, Z+8	; 0x08
    2fd6:	91 85       	ldd	r25, Z+9	; 0x09
    2fd8:	00 97       	sbiw	r24, 0x00	; 0
    2fda:	a1 f0       	breq	.+40     	; 0x3004 <xStreamBufferSendFromISR+0xdc>
    2fdc:	e8 85       	ldd	r30, Y+8	; 0x08
    2fde:	f9 85       	ldd	r31, Y+9	; 0x09
    2fe0:	80 85       	ldd	r24, Z+8	; 0x08
    2fe2:	91 85       	ldd	r25, Z+9	; 0x09
    2fe4:	e8 89       	ldd	r30, Y+16	; 0x10
    2fe6:	f9 89       	ldd	r31, Y+17	; 0x11
    2fe8:	40 e0       	ldi	r20, 0x00	; 0
    2fea:	50 e0       	ldi	r21, 0x00	; 0
    2fec:	60 e0       	ldi	r22, 0x00	; 0
    2fee:	70 e0       	ldi	r23, 0x00	; 0
    2ff0:	20 e0       	ldi	r18, 0x00	; 0
    2ff2:	00 e0       	ldi	r16, 0x00	; 0
    2ff4:	10 e0       	ldi	r17, 0x00	; 0
    2ff6:	7f 01       	movw	r14, r30
    2ff8:	0e 94 f3 27 	call	0x4fe6	; 0x4fe6 <xTaskGenericNotifyFromISR>
    2ffc:	e8 85       	ldd	r30, Y+8	; 0x08
    2ffe:	f9 85       	ldd	r31, Y+9	; 0x09
    3000:	11 86       	std	Z+9, r1	; 0x09
    3002:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    3004:	8e 81       	ldd	r24, Y+6	; 0x06
    3006:	9f 81       	ldd	r25, Y+7	; 0x07
}
    3008:	61 96       	adiw	r28, 0x11	; 17
    300a:	0f b6       	in	r0, 0x3f	; 63
    300c:	f8 94       	cli
    300e:	de bf       	out	0x3e, r29	; 62
    3010:	0f be       	out	0x3f, r0	; 63
    3012:	cd bf       	out	0x3d, r28	; 61
    3014:	cf 91       	pop	r28
    3016:	df 91       	pop	r29
    3018:	1f 91       	pop	r17
    301a:	0f 91       	pop	r16
    301c:	ff 90       	pop	r15
    301e:	ef 90       	pop	r14
    3020:	08 95       	ret

00003022 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    3022:	0f 93       	push	r16
    3024:	1f 93       	push	r17
    3026:	df 93       	push	r29
    3028:	cf 93       	push	r28
    302a:	cd b7       	in	r28, 0x3d	; 61
    302c:	de b7       	in	r29, 0x3e	; 62
    302e:	61 97       	sbiw	r28, 0x11	; 17
    3030:	0f b6       	in	r0, 0x3f	; 63
    3032:	f8 94       	cli
    3034:	de bf       	out	0x3e, r29	; 62
    3036:	0f be       	out	0x3f, r0	; 63
    3038:	cd bf       	out	0x3d, r28	; 61
    303a:	9d 83       	std	Y+5, r25	; 0x05
    303c:	8c 83       	std	Y+4, r24	; 0x04
    303e:	7f 83       	std	Y+7, r23	; 0x07
    3040:	6e 83       	std	Y+6, r22	; 0x06
    3042:	59 87       	std	Y+9, r21	; 0x09
    3044:	48 87       	std	Y+8, r20	; 0x08
    3046:	3b 87       	std	Y+11, r19	; 0x0b
    3048:	2a 87       	std	Y+10, r18	; 0x0a
    304a:	1d 87       	std	Y+13, r17	; 0x0d
    304c:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    304e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3050:	9b 85       	ldd	r25, Y+11	; 0x0b
    3052:	00 97       	sbiw	r24, 0x00	; 0
    3054:	11 f4       	brne	.+4      	; 0x305a <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    3056:	1b 82       	std	Y+3, r1	; 0x03
    3058:	38 c0       	rjmp	.+112    	; 0x30ca <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    305a:	ec 81       	ldd	r30, Y+4	; 0x04
    305c:	fd 81       	ldd	r31, Y+5	; 0x05
    305e:	86 85       	ldd	r24, Z+14	; 0x0e
    3060:	88 2f       	mov	r24, r24
    3062:	90 e0       	ldi	r25, 0x00	; 0
    3064:	81 70       	andi	r24, 0x01	; 1
    3066:	90 70       	andi	r25, 0x00	; 0
    3068:	00 97       	sbiw	r24, 0x00	; 0
    306a:	d1 f4       	brne	.+52     	; 0x30a0 <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    306c:	81 e0       	ldi	r24, 0x01	; 1
    306e:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    3070:	28 85       	ldd	r18, Y+8	; 0x08
    3072:	39 85       	ldd	r19, Y+9	; 0x09
    3074:	39 8b       	std	Y+17, r19	; 0x11
    3076:	28 8b       	std	Y+16, r18	; 0x10
    3078:	8a 85       	ldd	r24, Y+10	; 0x0a
    307a:	9b 85       	ldd	r25, Y+11	; 0x0b
    307c:	9f 87       	std	Y+15, r25	; 0x0f
    307e:	8e 87       	std	Y+14, r24	; 0x0e
    3080:	2e 85       	ldd	r18, Y+14	; 0x0e
    3082:	3f 85       	ldd	r19, Y+15	; 0x0f
    3084:	88 89       	ldd	r24, Y+16	; 0x10
    3086:	99 89       	ldd	r25, Y+17	; 0x11
    3088:	82 17       	cp	r24, r18
    308a:	93 07       	cpc	r25, r19
    308c:	20 f4       	brcc	.+8      	; 0x3096 <prvWriteMessageToBuffer+0x74>
    308e:	28 89       	ldd	r18, Y+16	; 0x10
    3090:	39 89       	ldd	r19, Y+17	; 0x11
    3092:	3f 87       	std	Y+15, r19	; 0x0f
    3094:	2e 87       	std	Y+14, r18	; 0x0e
    3096:	8e 85       	ldd	r24, Y+14	; 0x0e
    3098:	9f 85       	ldd	r25, Y+15	; 0x0f
    309a:	99 87       	std	Y+9, r25	; 0x09
    309c:	88 87       	std	Y+8, r24	; 0x08
    309e:	15 c0       	rjmp	.+42     	; 0x30ca <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    30a0:	2a 85       	ldd	r18, Y+10	; 0x0a
    30a2:	3b 85       	ldd	r19, Y+11	; 0x0b
    30a4:	8c 85       	ldd	r24, Y+12	; 0x0c
    30a6:	9d 85       	ldd	r25, Y+13	; 0x0d
    30a8:	28 17       	cp	r18, r24
    30aa:	39 07       	cpc	r19, r25
    30ac:	68 f0       	brcs	.+26     	; 0x30c8 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    30ae:	81 e0       	ldi	r24, 0x01	; 1
    30b0:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    30b2:	9e 01       	movw	r18, r28
    30b4:	28 5f       	subi	r18, 0xF8	; 248
    30b6:	3f 4f       	sbci	r19, 0xFF	; 255
    30b8:	8c 81       	ldd	r24, Y+4	; 0x04
    30ba:	9d 81       	ldd	r25, Y+5	; 0x05
    30bc:	b9 01       	movw	r22, r18
    30be:	42 e0       	ldi	r20, 0x02	; 2
    30c0:	50 e0       	ldi	r21, 0x00	; 0
    30c2:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <prvWriteBytesToBuffer>
    30c6:	01 c0       	rjmp	.+2      	; 0x30ca <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    30c8:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    30ca:	8b 81       	ldd	r24, Y+3	; 0x03
    30cc:	88 23       	and	r24, r24
    30ce:	61 f0       	breq	.+24     	; 0x30e8 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    30d0:	2e 81       	ldd	r18, Y+6	; 0x06
    30d2:	3f 81       	ldd	r19, Y+7	; 0x07
    30d4:	48 85       	ldd	r20, Y+8	; 0x08
    30d6:	59 85       	ldd	r21, Y+9	; 0x09
    30d8:	8c 81       	ldd	r24, Y+4	; 0x04
    30da:	9d 81       	ldd	r25, Y+5	; 0x05
    30dc:	b9 01       	movw	r22, r18
    30de:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <prvWriteBytesToBuffer>
    30e2:	9a 83       	std	Y+2, r25	; 0x02
    30e4:	89 83       	std	Y+1, r24	; 0x01
    30e6:	02 c0       	rjmp	.+4      	; 0x30ec <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    30e8:	1a 82       	std	Y+2, r1	; 0x02
    30ea:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    30ec:	89 81       	ldd	r24, Y+1	; 0x01
    30ee:	9a 81       	ldd	r25, Y+2	; 0x02
}
    30f0:	61 96       	adiw	r28, 0x11	; 17
    30f2:	0f b6       	in	r0, 0x3f	; 63
    30f4:	f8 94       	cli
    30f6:	de bf       	out	0x3e, r29	; 62
    30f8:	0f be       	out	0x3f, r0	; 63
    30fa:	cd bf       	out	0x3d, r28	; 61
    30fc:	cf 91       	pop	r28
    30fe:	df 91       	pop	r29
    3100:	1f 91       	pop	r17
    3102:	0f 91       	pop	r16
    3104:	08 95       	ret

00003106 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    3106:	ef 92       	push	r14
    3108:	ff 92       	push	r15
    310a:	0f 93       	push	r16
    310c:	1f 93       	push	r17
    310e:	df 93       	push	r29
    3110:	cf 93       	push	r28
    3112:	cd b7       	in	r28, 0x3d	; 61
    3114:	de b7       	in	r29, 0x3e	; 62
    3116:	60 97       	sbiw	r28, 0x10	; 16
    3118:	0f b6       	in	r0, 0x3f	; 63
    311a:	f8 94       	cli
    311c:	de bf       	out	0x3e, r29	; 62
    311e:	0f be       	out	0x3f, r0	; 63
    3120:	cd bf       	out	0x3d, r28	; 61
    3122:	9a 87       	std	Y+10, r25	; 0x0a
    3124:	89 87       	std	Y+9, r24	; 0x09
    3126:	7c 87       	std	Y+12, r23	; 0x0c
    3128:	6b 87       	std	Y+11, r22	; 0x0b
    312a:	5e 87       	std	Y+14, r21	; 0x0e
    312c:	4d 87       	std	Y+13, r20	; 0x0d
    312e:	38 8b       	std	Y+16, r19	; 0x10
    3130:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3132:	89 85       	ldd	r24, Y+9	; 0x09
    3134:	9a 85       	ldd	r25, Y+10	; 0x0a
    3136:	98 87       	std	Y+8, r25	; 0x08
    3138:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    313a:	1e 82       	std	Y+6, r1	; 0x06
    313c:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    313e:	ef 81       	ldd	r30, Y+7	; 0x07
    3140:	f8 85       	ldd	r31, Y+8	; 0x08
    3142:	86 85       	ldd	r24, Z+14	; 0x0e
    3144:	88 2f       	mov	r24, r24
    3146:	90 e0       	ldi	r25, 0x00	; 0
    3148:	81 70       	andi	r24, 0x01	; 1
    314a:	90 70       	andi	r25, 0x00	; 0
    314c:	88 23       	and	r24, r24
    314e:	29 f0       	breq	.+10     	; 0x315a <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3150:	82 e0       	ldi	r24, 0x02	; 2
    3152:	90 e0       	ldi	r25, 0x00	; 0
    3154:	9a 83       	std	Y+2, r25	; 0x02
    3156:	89 83       	std	Y+1, r24	; 0x01
    3158:	02 c0       	rjmp	.+4      	; 0x315e <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    315a:	1a 82       	std	Y+2, r1	; 0x02
    315c:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    315e:	8f 85       	ldd	r24, Y+15	; 0x0f
    3160:	98 89       	ldd	r25, Y+16	; 0x10
    3162:	00 97       	sbiw	r24, 0x00	; 0
    3164:	09 f4       	brne	.+2      	; 0x3168 <xStreamBufferReceive+0x62>
    3166:	3d c0       	rjmp	.+122    	; 0x31e2 <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    3168:	0f b6       	in	r0, 0x3f	; 63
    316a:	f8 94       	cli
    316c:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    316e:	8f 81       	ldd	r24, Y+7	; 0x07
    3170:	98 85       	ldd	r25, Y+8	; 0x08
    3172:	0e 94 98 1c 	call	0x3930	; 0x3930 <prvBytesInBuffer>
    3176:	9c 83       	std	Y+4, r25	; 0x04
    3178:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    317a:	2b 81       	ldd	r18, Y+3	; 0x03
    317c:	3c 81       	ldd	r19, Y+4	; 0x04
    317e:	89 81       	ldd	r24, Y+1	; 0x01
    3180:	9a 81       	ldd	r25, Y+2	; 0x02
    3182:	82 17       	cp	r24, r18
    3184:	93 07       	cpc	r25, r19
    3186:	50 f0       	brcs	.+20     	; 0x319c <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    3188:	80 e0       	ldi	r24, 0x00	; 0
    318a:	90 e0       	ldi	r25, 0x00	; 0
    318c:	0e 94 71 29 	call	0x52e2	; 0x52e2 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    3190:	0e 94 ca 25 	call	0x4b94	; 0x4b94 <xTaskGetCurrentTaskHandle>
    3194:	ef 81       	ldd	r30, Y+7	; 0x07
    3196:	f8 85       	ldd	r31, Y+8	; 0x08
    3198:	91 87       	std	Z+9, r25	; 0x09
    319a:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    319c:	0f 90       	pop	r0
    319e:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    31a0:	2b 81       	ldd	r18, Y+3	; 0x03
    31a2:	3c 81       	ldd	r19, Y+4	; 0x04
    31a4:	89 81       	ldd	r24, Y+1	; 0x01
    31a6:	9a 81       	ldd	r25, Y+2	; 0x02
    31a8:	82 17       	cp	r24, r18
    31aa:	93 07       	cpc	r25, r19
    31ac:	00 f1       	brcs	.+64     	; 0x31ee <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    31ae:	ef 85       	ldd	r30, Y+15	; 0x0f
    31b0:	f8 89       	ldd	r31, Y+16	; 0x10
    31b2:	60 e0       	ldi	r22, 0x00	; 0
    31b4:	70 e0       	ldi	r23, 0x00	; 0
    31b6:	80 e0       	ldi	r24, 0x00	; 0
    31b8:	90 e0       	ldi	r25, 0x00	; 0
    31ba:	20 e0       	ldi	r18, 0x00	; 0
    31bc:	30 e0       	ldi	r19, 0x00	; 0
    31be:	40 e0       	ldi	r20, 0x00	; 0
    31c0:	50 e0       	ldi	r21, 0x00	; 0
    31c2:	00 e0       	ldi	r16, 0x00	; 0
    31c4:	10 e0       	ldi	r17, 0x00	; 0
    31c6:	7f 01       	movw	r14, r30
    31c8:	0e 94 7a 26 	call	0x4cf4	; 0x4cf4 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    31cc:	ef 81       	ldd	r30, Y+7	; 0x07
    31ce:	f8 85       	ldd	r31, Y+8	; 0x08
    31d0:	11 86       	std	Z+9, r1	; 0x09
    31d2:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    31d4:	8f 81       	ldd	r24, Y+7	; 0x07
    31d6:	98 85       	ldd	r25, Y+8	; 0x08
    31d8:	0e 94 98 1c 	call	0x3930	; 0x3930 <prvBytesInBuffer>
    31dc:	9c 83       	std	Y+4, r25	; 0x04
    31de:	8b 83       	std	Y+3, r24	; 0x03
    31e0:	06 c0       	rjmp	.+12     	; 0x31ee <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    31e2:	8f 81       	ldd	r24, Y+7	; 0x07
    31e4:	98 85       	ldd	r25, Y+8	; 0x08
    31e6:	0e 94 98 1c 	call	0x3930	; 0x3930 <prvBytesInBuffer>
    31ea:	9c 83       	std	Y+4, r25	; 0x04
    31ec:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    31ee:	2b 81       	ldd	r18, Y+3	; 0x03
    31f0:	3c 81       	ldd	r19, Y+4	; 0x04
    31f2:	89 81       	ldd	r24, Y+1	; 0x01
    31f4:	9a 81       	ldd	r25, Y+2	; 0x02
    31f6:	82 17       	cp	r24, r18
    31f8:	93 07       	cpc	r25, r19
    31fa:	80 f5       	brcc	.+96     	; 0x325c <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    31fc:	8f 81       	ldd	r24, Y+7	; 0x07
    31fe:	98 85       	ldd	r25, Y+8	; 0x08
    3200:	2b 85       	ldd	r18, Y+11	; 0x0b
    3202:	3c 85       	ldd	r19, Y+12	; 0x0c
    3204:	4d 85       	ldd	r20, Y+13	; 0x0d
    3206:	5e 85       	ldd	r21, Y+14	; 0x0e
    3208:	eb 81       	ldd	r30, Y+3	; 0x03
    320a:	fc 81       	ldd	r31, Y+4	; 0x04
    320c:	a9 81       	ldd	r26, Y+1	; 0x01
    320e:	ba 81       	ldd	r27, Y+2	; 0x02
    3210:	b9 01       	movw	r22, r18
    3212:	9f 01       	movw	r18, r30
    3214:	8d 01       	movw	r16, r26
    3216:	0e 94 07 1a 	call	0x340e	; 0x340e <prvReadMessageFromBuffer>
    321a:	9e 83       	std	Y+6, r25	; 0x06
    321c:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    321e:	8d 81       	ldd	r24, Y+5	; 0x05
    3220:	9e 81       	ldd	r25, Y+6	; 0x06
    3222:	00 97       	sbiw	r24, 0x00	; 0
    3224:	d9 f0       	breq	.+54     	; 0x325c <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    3226:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <vTaskSuspendAll>
    322a:	ef 81       	ldd	r30, Y+7	; 0x07
    322c:	f8 85       	ldd	r31, Y+8	; 0x08
    322e:	82 85       	ldd	r24, Z+10	; 0x0a
    3230:	93 85       	ldd	r25, Z+11	; 0x0b
    3232:	00 97       	sbiw	r24, 0x00	; 0
    3234:	89 f0       	breq	.+34     	; 0x3258 <xStreamBufferReceive+0x152>
    3236:	ef 81       	ldd	r30, Y+7	; 0x07
    3238:	f8 85       	ldd	r31, Y+8	; 0x08
    323a:	82 85       	ldd	r24, Z+10	; 0x0a
    323c:	93 85       	ldd	r25, Z+11	; 0x0b
    323e:	40 e0       	ldi	r20, 0x00	; 0
    3240:	50 e0       	ldi	r21, 0x00	; 0
    3242:	60 e0       	ldi	r22, 0x00	; 0
    3244:	70 e0       	ldi	r23, 0x00	; 0
    3246:	20 e0       	ldi	r18, 0x00	; 0
    3248:	00 e0       	ldi	r16, 0x00	; 0
    324a:	10 e0       	ldi	r17, 0x00	; 0
    324c:	0e 94 16 27 	call	0x4e2c	; 0x4e2c <xTaskGenericNotify>
    3250:	ef 81       	ldd	r30, Y+7	; 0x07
    3252:	f8 85       	ldd	r31, Y+8	; 0x08
    3254:	13 86       	std	Z+11, r1	; 0x0b
    3256:	12 86       	std	Z+10, r1	; 0x0a
    3258:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    325c:	8d 81       	ldd	r24, Y+5	; 0x05
    325e:	9e 81       	ldd	r25, Y+6	; 0x06
}
    3260:	60 96       	adiw	r28, 0x10	; 16
    3262:	0f b6       	in	r0, 0x3f	; 63
    3264:	f8 94       	cli
    3266:	de bf       	out	0x3e, r29	; 62
    3268:	0f be       	out	0x3f, r0	; 63
    326a:	cd bf       	out	0x3d, r28	; 61
    326c:	cf 91       	pop	r28
    326e:	df 91       	pop	r29
    3270:	1f 91       	pop	r17
    3272:	0f 91       	pop	r16
    3274:	ff 90       	pop	r15
    3276:	ef 90       	pop	r14
    3278:	08 95       	ret

0000327a <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    327a:	df 93       	push	r29
    327c:	cf 93       	push	r28
    327e:	cd b7       	in	r28, 0x3d	; 61
    3280:	de b7       	in	r29, 0x3e	; 62
    3282:	2c 97       	sbiw	r28, 0x0c	; 12
    3284:	0f b6       	in	r0, 0x3f	; 63
    3286:	f8 94       	cli
    3288:	de bf       	out	0x3e, r29	; 62
    328a:	0f be       	out	0x3f, r0	; 63
    328c:	cd bf       	out	0x3d, r28	; 61
    328e:	9c 87       	std	Y+12, r25	; 0x0c
    3290:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3292:	8b 85       	ldd	r24, Y+11	; 0x0b
    3294:	9c 85       	ldd	r25, Y+12	; 0x0c
    3296:	98 87       	std	Y+8, r25	; 0x08
    3298:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    329a:	ef 81       	ldd	r30, Y+7	; 0x07
    329c:	f8 85       	ldd	r31, Y+8	; 0x08
    329e:	86 85       	ldd	r24, Z+14	; 0x0e
    32a0:	88 2f       	mov	r24, r24
    32a2:	90 e0       	ldi	r25, 0x00	; 0
    32a4:	81 70       	andi	r24, 0x01	; 1
    32a6:	90 70       	andi	r25, 0x00	; 0
    32a8:	88 23       	and	r24, r24
    32aa:	61 f1       	breq	.+88     	; 0x3304 <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    32ac:	8f 81       	ldd	r24, Y+7	; 0x07
    32ae:	98 85       	ldd	r25, Y+8	; 0x08
    32b0:	0e 94 98 1c 	call	0x3930	; 0x3930 <prvBytesInBuffer>
    32b4:	9c 83       	std	Y+4, r25	; 0x04
    32b6:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    32b8:	8b 81       	ldd	r24, Y+3	; 0x03
    32ba:	9c 81       	ldd	r25, Y+4	; 0x04
    32bc:	83 30       	cpi	r24, 0x03	; 3
    32be:	91 05       	cpc	r25, r1
    32c0:	f0 f0       	brcs	.+60     	; 0x32fe <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    32c2:	ef 81       	ldd	r30, Y+7	; 0x07
    32c4:	f8 85       	ldd	r31, Y+8	; 0x08
    32c6:	80 81       	ld	r24, Z
    32c8:	91 81       	ldd	r25, Z+1	; 0x01
    32ca:	9a 83       	std	Y+2, r25	; 0x02
    32cc:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    32ce:	9e 01       	movw	r18, r28
    32d0:	27 5f       	subi	r18, 0xF7	; 247
    32d2:	3f 4f       	sbci	r19, 0xFF	; 255
    32d4:	8f 81       	ldd	r24, Y+7	; 0x07
    32d6:	98 85       	ldd	r25, Y+8	; 0x08
    32d8:	eb 81       	ldd	r30, Y+3	; 0x03
    32da:	fc 81       	ldd	r31, Y+4	; 0x04
    32dc:	b9 01       	movw	r22, r18
    32de:	42 e0       	ldi	r20, 0x02	; 2
    32e0:	50 e0       	ldi	r21, 0x00	; 0
    32e2:	9f 01       	movw	r18, r30
    32e4:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    32e8:	89 85       	ldd	r24, Y+9	; 0x09
    32ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    32ec:	9e 83       	std	Y+6, r25	; 0x06
    32ee:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    32f0:	ef 81       	ldd	r30, Y+7	; 0x07
    32f2:	f8 85       	ldd	r31, Y+8	; 0x08
    32f4:	89 81       	ldd	r24, Y+1	; 0x01
    32f6:	9a 81       	ldd	r25, Y+2	; 0x02
    32f8:	91 83       	std	Z+1, r25	; 0x01
    32fa:	80 83       	st	Z, r24
    32fc:	05 c0       	rjmp	.+10     	; 0x3308 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    32fe:	1e 82       	std	Y+6, r1	; 0x06
    3300:	1d 82       	std	Y+5, r1	; 0x05
    3302:	02 c0       	rjmp	.+4      	; 0x3308 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    3304:	1e 82       	std	Y+6, r1	; 0x06
    3306:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    3308:	8d 81       	ldd	r24, Y+5	; 0x05
    330a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    330c:	2c 96       	adiw	r28, 0x0c	; 12
    330e:	0f b6       	in	r0, 0x3f	; 63
    3310:	f8 94       	cli
    3312:	de bf       	out	0x3e, r29	; 62
    3314:	0f be       	out	0x3f, r0	; 63
    3316:	cd bf       	out	0x3d, r28	; 61
    3318:	cf 91       	pop	r28
    331a:	df 91       	pop	r29
    331c:	08 95       	ret

0000331e <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    331e:	ef 92       	push	r14
    3320:	ff 92       	push	r15
    3322:	0f 93       	push	r16
    3324:	1f 93       	push	r17
    3326:	df 93       	push	r29
    3328:	cf 93       	push	r28
    332a:	cd b7       	in	r28, 0x3d	; 61
    332c:	de b7       	in	r29, 0x3e	; 62
    332e:	61 97       	sbiw	r28, 0x11	; 17
    3330:	0f b6       	in	r0, 0x3f	; 63
    3332:	f8 94       	cli
    3334:	de bf       	out	0x3e, r29	; 62
    3336:	0f be       	out	0x3f, r0	; 63
    3338:	cd bf       	out	0x3d, r28	; 61
    333a:	9b 87       	std	Y+11, r25	; 0x0b
    333c:	8a 87       	std	Y+10, r24	; 0x0a
    333e:	7d 87       	std	Y+13, r23	; 0x0d
    3340:	6c 87       	std	Y+12, r22	; 0x0c
    3342:	5f 87       	std	Y+15, r21	; 0x0f
    3344:	4e 87       	std	Y+14, r20	; 0x0e
    3346:	39 8b       	std	Y+17, r19	; 0x11
    3348:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    334a:	8a 85       	ldd	r24, Y+10	; 0x0a
    334c:	9b 85       	ldd	r25, Y+11	; 0x0b
    334e:	99 87       	std	Y+9, r25	; 0x09
    3350:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    3352:	1f 82       	std	Y+7, r1	; 0x07
    3354:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3356:	e8 85       	ldd	r30, Y+8	; 0x08
    3358:	f9 85       	ldd	r31, Y+9	; 0x09
    335a:	86 85       	ldd	r24, Z+14	; 0x0e
    335c:	88 2f       	mov	r24, r24
    335e:	90 e0       	ldi	r25, 0x00	; 0
    3360:	81 70       	andi	r24, 0x01	; 1
    3362:	90 70       	andi	r25, 0x00	; 0
    3364:	88 23       	and	r24, r24
    3366:	29 f0       	breq	.+10     	; 0x3372 <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3368:	82 e0       	ldi	r24, 0x02	; 2
    336a:	90 e0       	ldi	r25, 0x00	; 0
    336c:	9b 83       	std	Y+3, r25	; 0x03
    336e:	8a 83       	std	Y+2, r24	; 0x02
    3370:	02 c0       	rjmp	.+4      	; 0x3376 <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    3372:	1b 82       	std	Y+3, r1	; 0x03
    3374:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    3376:	88 85       	ldd	r24, Y+8	; 0x08
    3378:	99 85       	ldd	r25, Y+9	; 0x09
    337a:	0e 94 98 1c 	call	0x3930	; 0x3930 <prvBytesInBuffer>
    337e:	9d 83       	std	Y+5, r25	; 0x05
    3380:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    3382:	2c 81       	ldd	r18, Y+4	; 0x04
    3384:	3d 81       	ldd	r19, Y+5	; 0x05
    3386:	8a 81       	ldd	r24, Y+2	; 0x02
    3388:	9b 81       	ldd	r25, Y+3	; 0x03
    338a:	82 17       	cp	r24, r18
    338c:	93 07       	cpc	r25, r19
    338e:	80 f5       	brcc	.+96     	; 0x33f0 <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    3390:	88 85       	ldd	r24, Y+8	; 0x08
    3392:	99 85       	ldd	r25, Y+9	; 0x09
    3394:	2c 85       	ldd	r18, Y+12	; 0x0c
    3396:	3d 85       	ldd	r19, Y+13	; 0x0d
    3398:	4e 85       	ldd	r20, Y+14	; 0x0e
    339a:	5f 85       	ldd	r21, Y+15	; 0x0f
    339c:	ec 81       	ldd	r30, Y+4	; 0x04
    339e:	fd 81       	ldd	r31, Y+5	; 0x05
    33a0:	aa 81       	ldd	r26, Y+2	; 0x02
    33a2:	bb 81       	ldd	r27, Y+3	; 0x03
    33a4:	b9 01       	movw	r22, r18
    33a6:	9f 01       	movw	r18, r30
    33a8:	8d 01       	movw	r16, r26
    33aa:	0e 94 07 1a 	call	0x340e	; 0x340e <prvReadMessageFromBuffer>
    33ae:	9f 83       	std	Y+7, r25	; 0x07
    33b0:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    33b2:	8e 81       	ldd	r24, Y+6	; 0x06
    33b4:	9f 81       	ldd	r25, Y+7	; 0x07
    33b6:	00 97       	sbiw	r24, 0x00	; 0
    33b8:	d9 f0       	breq	.+54     	; 0x33f0 <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    33ba:	19 82       	std	Y+1, r1	; 0x01
    33bc:	e8 85       	ldd	r30, Y+8	; 0x08
    33be:	f9 85       	ldd	r31, Y+9	; 0x09
    33c0:	82 85       	ldd	r24, Z+10	; 0x0a
    33c2:	93 85       	ldd	r25, Z+11	; 0x0b
    33c4:	00 97       	sbiw	r24, 0x00	; 0
    33c6:	a1 f0       	breq	.+40     	; 0x33f0 <xStreamBufferReceiveFromISR+0xd2>
    33c8:	e8 85       	ldd	r30, Y+8	; 0x08
    33ca:	f9 85       	ldd	r31, Y+9	; 0x09
    33cc:	82 85       	ldd	r24, Z+10	; 0x0a
    33ce:	93 85       	ldd	r25, Z+11	; 0x0b
    33d0:	e8 89       	ldd	r30, Y+16	; 0x10
    33d2:	f9 89       	ldd	r31, Y+17	; 0x11
    33d4:	40 e0       	ldi	r20, 0x00	; 0
    33d6:	50 e0       	ldi	r21, 0x00	; 0
    33d8:	60 e0       	ldi	r22, 0x00	; 0
    33da:	70 e0       	ldi	r23, 0x00	; 0
    33dc:	20 e0       	ldi	r18, 0x00	; 0
    33de:	00 e0       	ldi	r16, 0x00	; 0
    33e0:	10 e0       	ldi	r17, 0x00	; 0
    33e2:	7f 01       	movw	r14, r30
    33e4:	0e 94 f3 27 	call	0x4fe6	; 0x4fe6 <xTaskGenericNotifyFromISR>
    33e8:	e8 85       	ldd	r30, Y+8	; 0x08
    33ea:	f9 85       	ldd	r31, Y+9	; 0x09
    33ec:	13 86       	std	Z+11, r1	; 0x0b
    33ee:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    33f0:	8e 81       	ldd	r24, Y+6	; 0x06
    33f2:	9f 81       	ldd	r25, Y+7	; 0x07
}
    33f4:	61 96       	adiw	r28, 0x11	; 17
    33f6:	0f b6       	in	r0, 0x3f	; 63
    33f8:	f8 94       	cli
    33fa:	de bf       	out	0x3e, r29	; 62
    33fc:	0f be       	out	0x3f, r0	; 63
    33fe:	cd bf       	out	0x3d, r28	; 61
    3400:	cf 91       	pop	r28
    3402:	df 91       	pop	r29
    3404:	1f 91       	pop	r17
    3406:	0f 91       	pop	r16
    3408:	ff 90       	pop	r15
    340a:	ef 90       	pop	r14
    340c:	08 95       	ret

0000340e <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    340e:	0f 93       	push	r16
    3410:	1f 93       	push	r17
    3412:	df 93       	push	r29
    3414:	cf 93       	push	r28
    3416:	cd b7       	in	r28, 0x3d	; 61
    3418:	de b7       	in	r29, 0x3e	; 62
    341a:	62 97       	sbiw	r28, 0x12	; 18
    341c:	0f b6       	in	r0, 0x3f	; 63
    341e:	f8 94       	cli
    3420:	de bf       	out	0x3e, r29	; 62
    3422:	0f be       	out	0x3f, r0	; 63
    3424:	cd bf       	out	0x3d, r28	; 61
    3426:	9a 87       	std	Y+10, r25	; 0x0a
    3428:	89 87       	std	Y+9, r24	; 0x09
    342a:	7c 87       	std	Y+12, r23	; 0x0c
    342c:	6b 87       	std	Y+11, r22	; 0x0b
    342e:	5e 87       	std	Y+14, r21	; 0x0e
    3430:	4d 87       	std	Y+13, r20	; 0x0d
    3432:	38 8b       	std	Y+16, r19	; 0x10
    3434:	2f 87       	std	Y+15, r18	; 0x0f
    3436:	1a 8b       	std	Y+18, r17	; 0x12
    3438:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    343a:	89 89       	ldd	r24, Y+17	; 0x11
    343c:	9a 89       	ldd	r25, Y+18	; 0x12
    343e:	00 97       	sbiw	r24, 0x00	; 0
    3440:	91 f1       	breq	.+100    	; 0x34a6 <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    3442:	e9 85       	ldd	r30, Y+9	; 0x09
    3444:	fa 85       	ldd	r31, Y+10	; 0x0a
    3446:	80 81       	ld	r24, Z
    3448:	91 81       	ldd	r25, Z+1	; 0x01
    344a:	9e 83       	std	Y+6, r25	; 0x06
    344c:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    344e:	ae 01       	movw	r20, r28
    3450:	49 5f       	subi	r20, 0xF9	; 249
    3452:	5f 4f       	sbci	r21, 0xFF	; 255
    3454:	89 85       	ldd	r24, Y+9	; 0x09
    3456:	9a 85       	ldd	r25, Y+10	; 0x0a
    3458:	29 89       	ldd	r18, Y+17	; 0x11
    345a:	3a 89       	ldd	r19, Y+18	; 0x12
    345c:	ef 85       	ldd	r30, Y+15	; 0x0f
    345e:	f8 89       	ldd	r31, Y+16	; 0x10
    3460:	ba 01       	movw	r22, r20
    3462:	a9 01       	movw	r20, r18
    3464:	9f 01       	movw	r18, r30
    3466:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    346a:	8f 81       	ldd	r24, Y+7	; 0x07
    346c:	98 85       	ldd	r25, Y+8	; 0x08
    346e:	9a 83       	std	Y+2, r25	; 0x02
    3470:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    3472:	2f 85       	ldd	r18, Y+15	; 0x0f
    3474:	38 89       	ldd	r19, Y+16	; 0x10
    3476:	89 89       	ldd	r24, Y+17	; 0x11
    3478:	9a 89       	ldd	r25, Y+18	; 0x12
    347a:	a9 01       	movw	r20, r18
    347c:	48 1b       	sub	r20, r24
    347e:	59 0b       	sbc	r21, r25
    3480:	ca 01       	movw	r24, r20
    3482:	98 8b       	std	Y+16, r25	; 0x10
    3484:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    3486:	29 81       	ldd	r18, Y+1	; 0x01
    3488:	3a 81       	ldd	r19, Y+2	; 0x02
    348a:	8d 85       	ldd	r24, Y+13	; 0x0d
    348c:	9e 85       	ldd	r25, Y+14	; 0x0e
    348e:	82 17       	cp	r24, r18
    3490:	93 07       	cpc	r25, r19
    3492:	68 f4       	brcc	.+26     	; 0x34ae <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    3494:	e9 85       	ldd	r30, Y+9	; 0x09
    3496:	fa 85       	ldd	r31, Y+10	; 0x0a
    3498:	8d 81       	ldd	r24, Y+5	; 0x05
    349a:	9e 81       	ldd	r25, Y+6	; 0x06
    349c:	91 83       	std	Z+1, r25	; 0x01
    349e:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    34a0:	1a 82       	std	Y+2, r1	; 0x02
    34a2:	19 82       	std	Y+1, r1	; 0x01
    34a4:	04 c0       	rjmp	.+8      	; 0x34ae <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    34a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    34a8:	9e 85       	ldd	r25, Y+14	; 0x0e
    34aa:	9a 83       	std	Y+2, r25	; 0x02
    34ac:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    34ae:	4b 85       	ldd	r20, Y+11	; 0x0b
    34b0:	5c 85       	ldd	r21, Y+12	; 0x0c
    34b2:	89 85       	ldd	r24, Y+9	; 0x09
    34b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    34b6:	29 81       	ldd	r18, Y+1	; 0x01
    34b8:	3a 81       	ldd	r19, Y+2	; 0x02
    34ba:	ef 85       	ldd	r30, Y+15	; 0x0f
    34bc:	f8 89       	ldd	r31, Y+16	; 0x10
    34be:	ba 01       	movw	r22, r20
    34c0:	a9 01       	movw	r20, r18
    34c2:	9f 01       	movw	r18, r30
    34c4:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <prvReadBytesFromBuffer>
    34c8:	9c 83       	std	Y+4, r25	; 0x04
    34ca:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    34cc:	8b 81       	ldd	r24, Y+3	; 0x03
    34ce:	9c 81       	ldd	r25, Y+4	; 0x04
}
    34d0:	62 96       	adiw	r28, 0x12	; 18
    34d2:	0f b6       	in	r0, 0x3f	; 63
    34d4:	f8 94       	cli
    34d6:	de bf       	out	0x3e, r29	; 62
    34d8:	0f be       	out	0x3f, r0	; 63
    34da:	cd bf       	out	0x3d, r28	; 61
    34dc:	cf 91       	pop	r28
    34de:	df 91       	pop	r29
    34e0:	1f 91       	pop	r17
    34e2:	0f 91       	pop	r16
    34e4:	08 95       	ret

000034e6 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    34e6:	df 93       	push	r29
    34e8:	cf 93       	push	r28
    34ea:	cd b7       	in	r28, 0x3d	; 61
    34ec:	de b7       	in	r29, 0x3e	; 62
    34ee:	27 97       	sbiw	r28, 0x07	; 7
    34f0:	0f b6       	in	r0, 0x3f	; 63
    34f2:	f8 94       	cli
    34f4:	de bf       	out	0x3e, r29	; 62
    34f6:	0f be       	out	0x3f, r0	; 63
    34f8:	cd bf       	out	0x3d, r28	; 61
    34fa:	9f 83       	std	Y+7, r25	; 0x07
    34fc:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    34fe:	8e 81       	ldd	r24, Y+6	; 0x06
    3500:	9f 81       	ldd	r25, Y+7	; 0x07
    3502:	9d 83       	std	Y+5, r25	; 0x05
    3504:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    3506:	ec 81       	ldd	r30, Y+4	; 0x04
    3508:	fd 81       	ldd	r31, Y+5	; 0x05
    350a:	80 81       	ld	r24, Z
    350c:	91 81       	ldd	r25, Z+1	; 0x01
    350e:	9a 83       	std	Y+2, r25	; 0x02
    3510:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    3512:	ec 81       	ldd	r30, Y+4	; 0x04
    3514:	fd 81       	ldd	r31, Y+5	; 0x05
    3516:	22 81       	ldd	r18, Z+2	; 0x02
    3518:	33 81       	ldd	r19, Z+3	; 0x03
    351a:	89 81       	ldd	r24, Y+1	; 0x01
    351c:	9a 81       	ldd	r25, Y+2	; 0x02
    351e:	28 17       	cp	r18, r24
    3520:	39 07       	cpc	r19, r25
    3522:	19 f4       	brne	.+6      	; 0x352a <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    3524:	81 e0       	ldi	r24, 0x01	; 1
    3526:	8b 83       	std	Y+3, r24	; 0x03
    3528:	01 c0       	rjmp	.+2      	; 0x352c <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    352a:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    352c:	8b 81       	ldd	r24, Y+3	; 0x03
}
    352e:	27 96       	adiw	r28, 0x07	; 7
    3530:	0f b6       	in	r0, 0x3f	; 63
    3532:	f8 94       	cli
    3534:	de bf       	out	0x3e, r29	; 62
    3536:	0f be       	out	0x3f, r0	; 63
    3538:	cd bf       	out	0x3d, r28	; 61
    353a:	cf 91       	pop	r28
    353c:	df 91       	pop	r29
    353e:	08 95       	ret

00003540 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    3540:	df 93       	push	r29
    3542:	cf 93       	push	r28
    3544:	cd b7       	in	r28, 0x3d	; 61
    3546:	de b7       	in	r29, 0x3e	; 62
    3548:	27 97       	sbiw	r28, 0x07	; 7
    354a:	0f b6       	in	r0, 0x3f	; 63
    354c:	f8 94       	cli
    354e:	de bf       	out	0x3e, r29	; 62
    3550:	0f be       	out	0x3f, r0	; 63
    3552:	cd bf       	out	0x3d, r28	; 61
    3554:	9f 83       	std	Y+7, r25	; 0x07
    3556:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    3558:	8e 81       	ldd	r24, Y+6	; 0x06
    355a:	9f 81       	ldd	r25, Y+7	; 0x07
    355c:	9a 83       	std	Y+2, r25	; 0x02
    355e:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    3560:	e9 81       	ldd	r30, Y+1	; 0x01
    3562:	fa 81       	ldd	r31, Y+2	; 0x02
    3564:	86 85       	ldd	r24, Z+14	; 0x0e
    3566:	88 2f       	mov	r24, r24
    3568:	90 e0       	ldi	r25, 0x00	; 0
    356a:	81 70       	andi	r24, 0x01	; 1
    356c:	90 70       	andi	r25, 0x00	; 0
    356e:	88 23       	and	r24, r24
    3570:	29 f0       	breq	.+10     	; 0x357c <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    3572:	82 e0       	ldi	r24, 0x02	; 2
    3574:	90 e0       	ldi	r25, 0x00	; 0
    3576:	9c 83       	std	Y+4, r25	; 0x04
    3578:	8b 83       	std	Y+3, r24	; 0x03
    357a:	02 c0       	rjmp	.+4      	; 0x3580 <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    357c:	1c 82       	std	Y+4, r1	; 0x04
    357e:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    3580:	8e 81       	ldd	r24, Y+6	; 0x06
    3582:	9f 81       	ldd	r25, Y+7	; 0x07
    3584:	0e 94 68 16 	call	0x2cd0	; 0x2cd0 <xStreamBufferSpacesAvailable>
    3588:	9c 01       	movw	r18, r24
    358a:	8b 81       	ldd	r24, Y+3	; 0x03
    358c:	9c 81       	ldd	r25, Y+4	; 0x04
    358e:	82 17       	cp	r24, r18
    3590:	93 07       	cpc	r25, r19
    3592:	18 f0       	brcs	.+6      	; 0x359a <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    3594:	81 e0       	ldi	r24, 0x01	; 1
    3596:	8d 83       	std	Y+5, r24	; 0x05
    3598:	01 c0       	rjmp	.+2      	; 0x359c <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    359a:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    359c:	8d 81       	ldd	r24, Y+5	; 0x05
}
    359e:	27 96       	adiw	r28, 0x07	; 7
    35a0:	0f b6       	in	r0, 0x3f	; 63
    35a2:	f8 94       	cli
    35a4:	de bf       	out	0x3e, r29	; 62
    35a6:	0f be       	out	0x3f, r0	; 63
    35a8:	cd bf       	out	0x3d, r28	; 61
    35aa:	cf 91       	pop	r28
    35ac:	df 91       	pop	r29
    35ae:	08 95       	ret

000035b0 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    35b0:	ef 92       	push	r14
    35b2:	ff 92       	push	r15
    35b4:	0f 93       	push	r16
    35b6:	1f 93       	push	r17
    35b8:	df 93       	push	r29
    35ba:	cf 93       	push	r28
    35bc:	cd b7       	in	r28, 0x3d	; 61
    35be:	de b7       	in	r29, 0x3e	; 62
    35c0:	28 97       	sbiw	r28, 0x08	; 8
    35c2:	0f b6       	in	r0, 0x3f	; 63
    35c4:	f8 94       	cli
    35c6:	de bf       	out	0x3e, r29	; 62
    35c8:	0f be       	out	0x3f, r0	; 63
    35ca:	cd bf       	out	0x3d, r28	; 61
    35cc:	9e 83       	std	Y+6, r25	; 0x06
    35ce:	8d 83       	std	Y+5, r24	; 0x05
    35d0:	78 87       	std	Y+8, r23	; 0x08
    35d2:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    35d4:	8d 81       	ldd	r24, Y+5	; 0x05
    35d6:	9e 81       	ldd	r25, Y+6	; 0x06
    35d8:	9c 83       	std	Y+4, r25	; 0x04
    35da:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    35dc:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    35de:	eb 81       	ldd	r30, Y+3	; 0x03
    35e0:	fc 81       	ldd	r31, Y+4	; 0x04
    35e2:	80 85       	ldd	r24, Z+8	; 0x08
    35e4:	91 85       	ldd	r25, Z+9	; 0x09
    35e6:	00 97       	sbiw	r24, 0x00	; 0
    35e8:	b9 f0       	breq	.+46     	; 0x3618 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    35ea:	eb 81       	ldd	r30, Y+3	; 0x03
    35ec:	fc 81       	ldd	r31, Y+4	; 0x04
    35ee:	80 85       	ldd	r24, Z+8	; 0x08
    35f0:	91 85       	ldd	r25, Z+9	; 0x09
    35f2:	ef 81       	ldd	r30, Y+7	; 0x07
    35f4:	f8 85       	ldd	r31, Y+8	; 0x08
    35f6:	40 e0       	ldi	r20, 0x00	; 0
    35f8:	50 e0       	ldi	r21, 0x00	; 0
    35fa:	60 e0       	ldi	r22, 0x00	; 0
    35fc:	70 e0       	ldi	r23, 0x00	; 0
    35fe:	20 e0       	ldi	r18, 0x00	; 0
    3600:	00 e0       	ldi	r16, 0x00	; 0
    3602:	10 e0       	ldi	r17, 0x00	; 0
    3604:	7f 01       	movw	r14, r30
    3606:	0e 94 f3 27 	call	0x4fe6	; 0x4fe6 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    360a:	eb 81       	ldd	r30, Y+3	; 0x03
    360c:	fc 81       	ldd	r31, Y+4	; 0x04
    360e:	11 86       	std	Z+9, r1	; 0x09
    3610:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    3612:	81 e0       	ldi	r24, 0x01	; 1
    3614:	8a 83       	std	Y+2, r24	; 0x02
    3616:	01 c0       	rjmp	.+2      	; 0x361a <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    3618:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    361a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    361c:	28 96       	adiw	r28, 0x08	; 8
    361e:	0f b6       	in	r0, 0x3f	; 63
    3620:	f8 94       	cli
    3622:	de bf       	out	0x3e, r29	; 62
    3624:	0f be       	out	0x3f, r0	; 63
    3626:	cd bf       	out	0x3d, r28	; 61
    3628:	cf 91       	pop	r28
    362a:	df 91       	pop	r29
    362c:	1f 91       	pop	r17
    362e:	0f 91       	pop	r16
    3630:	ff 90       	pop	r15
    3632:	ef 90       	pop	r14
    3634:	08 95       	ret

00003636 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    3636:	ef 92       	push	r14
    3638:	ff 92       	push	r15
    363a:	0f 93       	push	r16
    363c:	1f 93       	push	r17
    363e:	df 93       	push	r29
    3640:	cf 93       	push	r28
    3642:	cd b7       	in	r28, 0x3d	; 61
    3644:	de b7       	in	r29, 0x3e	; 62
    3646:	28 97       	sbiw	r28, 0x08	; 8
    3648:	0f b6       	in	r0, 0x3f	; 63
    364a:	f8 94       	cli
    364c:	de bf       	out	0x3e, r29	; 62
    364e:	0f be       	out	0x3f, r0	; 63
    3650:	cd bf       	out	0x3d, r28	; 61
    3652:	9e 83       	std	Y+6, r25	; 0x06
    3654:	8d 83       	std	Y+5, r24	; 0x05
    3656:	78 87       	std	Y+8, r23	; 0x08
    3658:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    365a:	8d 81       	ldd	r24, Y+5	; 0x05
    365c:	9e 81       	ldd	r25, Y+6	; 0x06
    365e:	9c 83       	std	Y+4, r25	; 0x04
    3660:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    3662:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    3664:	eb 81       	ldd	r30, Y+3	; 0x03
    3666:	fc 81       	ldd	r31, Y+4	; 0x04
    3668:	82 85       	ldd	r24, Z+10	; 0x0a
    366a:	93 85       	ldd	r25, Z+11	; 0x0b
    366c:	00 97       	sbiw	r24, 0x00	; 0
    366e:	b9 f0       	breq	.+46     	; 0x369e <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    3670:	eb 81       	ldd	r30, Y+3	; 0x03
    3672:	fc 81       	ldd	r31, Y+4	; 0x04
    3674:	82 85       	ldd	r24, Z+10	; 0x0a
    3676:	93 85       	ldd	r25, Z+11	; 0x0b
    3678:	ef 81       	ldd	r30, Y+7	; 0x07
    367a:	f8 85       	ldd	r31, Y+8	; 0x08
    367c:	40 e0       	ldi	r20, 0x00	; 0
    367e:	50 e0       	ldi	r21, 0x00	; 0
    3680:	60 e0       	ldi	r22, 0x00	; 0
    3682:	70 e0       	ldi	r23, 0x00	; 0
    3684:	20 e0       	ldi	r18, 0x00	; 0
    3686:	00 e0       	ldi	r16, 0x00	; 0
    3688:	10 e0       	ldi	r17, 0x00	; 0
    368a:	7f 01       	movw	r14, r30
    368c:	0e 94 f3 27 	call	0x4fe6	; 0x4fe6 <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    3690:	eb 81       	ldd	r30, Y+3	; 0x03
    3692:	fc 81       	ldd	r31, Y+4	; 0x04
    3694:	13 86       	std	Z+11, r1	; 0x0b
    3696:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    3698:	81 e0       	ldi	r24, 0x01	; 1
    369a:	8a 83       	std	Y+2, r24	; 0x02
    369c:	01 c0       	rjmp	.+2      	; 0x36a0 <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    369e:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    36a0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    36a2:	28 96       	adiw	r28, 0x08	; 8
    36a4:	0f b6       	in	r0, 0x3f	; 63
    36a6:	f8 94       	cli
    36a8:	de bf       	out	0x3e, r29	; 62
    36aa:	0f be       	out	0x3f, r0	; 63
    36ac:	cd bf       	out	0x3d, r28	; 61
    36ae:	cf 91       	pop	r28
    36b0:	df 91       	pop	r29
    36b2:	1f 91       	pop	r17
    36b4:	0f 91       	pop	r16
    36b6:	ff 90       	pop	r15
    36b8:	ef 90       	pop	r14
    36ba:	08 95       	ret

000036bc <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    36bc:	df 93       	push	r29
    36be:	cf 93       	push	r28
    36c0:	cd b7       	in	r28, 0x3d	; 61
    36c2:	de b7       	in	r29, 0x3e	; 62
    36c4:	2e 97       	sbiw	r28, 0x0e	; 14
    36c6:	0f b6       	in	r0, 0x3f	; 63
    36c8:	f8 94       	cli
    36ca:	de bf       	out	0x3e, r29	; 62
    36cc:	0f be       	out	0x3f, r0	; 63
    36ce:	cd bf       	out	0x3d, r28	; 61
    36d0:	9e 83       	std	Y+6, r25	; 0x06
    36d2:	8d 83       	std	Y+5, r24	; 0x05
    36d4:	78 87       	std	Y+8, r23	; 0x08
    36d6:	6f 83       	std	Y+7, r22	; 0x07
    36d8:	5a 87       	std	Y+10, r21	; 0x0a
    36da:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    36dc:	ed 81       	ldd	r30, Y+5	; 0x05
    36de:	fe 81       	ldd	r31, Y+6	; 0x06
    36e0:	82 81       	ldd	r24, Z+2	; 0x02
    36e2:	93 81       	ldd	r25, Z+3	; 0x03
    36e4:	9c 83       	std	Y+4, r25	; 0x04
    36e6:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    36e8:	ed 81       	ldd	r30, Y+5	; 0x05
    36ea:	fe 81       	ldd	r31, Y+6	; 0x06
    36ec:	24 81       	ldd	r18, Z+4	; 0x04
    36ee:	35 81       	ldd	r19, Z+5	; 0x05
    36f0:	8b 81       	ldd	r24, Y+3	; 0x03
    36f2:	9c 81       	ldd	r25, Y+4	; 0x04
    36f4:	a9 01       	movw	r20, r18
    36f6:	48 1b       	sub	r20, r24
    36f8:	59 0b       	sbc	r21, r25
    36fa:	ca 01       	movw	r24, r20
    36fc:	29 85       	ldd	r18, Y+9	; 0x09
    36fe:	3a 85       	ldd	r19, Y+10	; 0x0a
    3700:	3e 87       	std	Y+14, r19	; 0x0e
    3702:	2d 87       	std	Y+13, r18	; 0x0d
    3704:	9c 87       	std	Y+12, r25	; 0x0c
    3706:	8b 87       	std	Y+11, r24	; 0x0b
    3708:	4b 85       	ldd	r20, Y+11	; 0x0b
    370a:	5c 85       	ldd	r21, Y+12	; 0x0c
    370c:	8d 85       	ldd	r24, Y+13	; 0x0d
    370e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3710:	84 17       	cp	r24, r20
    3712:	95 07       	cpc	r25, r21
    3714:	20 f4       	brcc	.+8      	; 0x371e <prvWriteBytesToBuffer+0x62>
    3716:	2d 85       	ldd	r18, Y+13	; 0x0d
    3718:	3e 85       	ldd	r19, Y+14	; 0x0e
    371a:	3c 87       	std	Y+12, r19	; 0x0c
    371c:	2b 87       	std	Y+11, r18	; 0x0b
    371e:	4b 85       	ldd	r20, Y+11	; 0x0b
    3720:	5c 85       	ldd	r21, Y+12	; 0x0c
    3722:	5a 83       	std	Y+2, r21	; 0x02
    3724:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3726:	ed 81       	ldd	r30, Y+5	; 0x05
    3728:	fe 81       	ldd	r31, Y+6	; 0x06
    372a:	24 85       	ldd	r18, Z+12	; 0x0c
    372c:	35 85       	ldd	r19, Z+13	; 0x0d
    372e:	8b 81       	ldd	r24, Y+3	; 0x03
    3730:	9c 81       	ldd	r25, Y+4	; 0x04
    3732:	82 0f       	add	r24, r18
    3734:	93 1f       	adc	r25, r19
    3736:	2f 81       	ldd	r18, Y+7	; 0x07
    3738:	38 85       	ldd	r19, Y+8	; 0x08
    373a:	49 81       	ldd	r20, Y+1	; 0x01
    373c:	5a 81       	ldd	r21, Y+2	; 0x02
    373e:	b9 01       	movw	r22, r18
    3740:	0e 94 27 2a 	call	0x544e	; 0x544e <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    3744:	29 85       	ldd	r18, Y+9	; 0x09
    3746:	3a 85       	ldd	r19, Y+10	; 0x0a
    3748:	89 81       	ldd	r24, Y+1	; 0x01
    374a:	9a 81       	ldd	r25, Y+2	; 0x02
    374c:	82 17       	cp	r24, r18
    374e:	93 07       	cpc	r25, r19
    3750:	b0 f4       	brcc	.+44     	; 0x377e <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    3752:	ed 81       	ldd	r30, Y+5	; 0x05
    3754:	fe 81       	ldd	r31, Y+6	; 0x06
    3756:	64 85       	ldd	r22, Z+12	; 0x0c
    3758:	75 85       	ldd	r23, Z+13	; 0x0d
    375a:	2f 81       	ldd	r18, Y+7	; 0x07
    375c:	38 85       	ldd	r19, Y+8	; 0x08
    375e:	89 81       	ldd	r24, Y+1	; 0x01
    3760:	9a 81       	ldd	r25, Y+2	; 0x02
    3762:	a9 01       	movw	r20, r18
    3764:	48 0f       	add	r20, r24
    3766:	59 1f       	adc	r21, r25
    3768:	29 85       	ldd	r18, Y+9	; 0x09
    376a:	3a 85       	ldd	r19, Y+10	; 0x0a
    376c:	89 81       	ldd	r24, Y+1	; 0x01
    376e:	9a 81       	ldd	r25, Y+2	; 0x02
    3770:	28 1b       	sub	r18, r24
    3772:	39 0b       	sbc	r19, r25
    3774:	cb 01       	movw	r24, r22
    3776:	ba 01       	movw	r22, r20
    3778:	a9 01       	movw	r20, r18
    377a:	0e 94 27 2a 	call	0x544e	; 0x544e <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    377e:	2b 81       	ldd	r18, Y+3	; 0x03
    3780:	3c 81       	ldd	r19, Y+4	; 0x04
    3782:	89 85       	ldd	r24, Y+9	; 0x09
    3784:	9a 85       	ldd	r25, Y+10	; 0x0a
    3786:	82 0f       	add	r24, r18
    3788:	93 1f       	adc	r25, r19
    378a:	9c 83       	std	Y+4, r25	; 0x04
    378c:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    378e:	ed 81       	ldd	r30, Y+5	; 0x05
    3790:	fe 81       	ldd	r31, Y+6	; 0x06
    3792:	24 81       	ldd	r18, Z+4	; 0x04
    3794:	35 81       	ldd	r19, Z+5	; 0x05
    3796:	8b 81       	ldd	r24, Y+3	; 0x03
    3798:	9c 81       	ldd	r25, Y+4	; 0x04
    379a:	82 17       	cp	r24, r18
    379c:	93 07       	cpc	r25, r19
    379e:	50 f0       	brcs	.+20     	; 0x37b4 <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    37a0:	ed 81       	ldd	r30, Y+5	; 0x05
    37a2:	fe 81       	ldd	r31, Y+6	; 0x06
    37a4:	24 81       	ldd	r18, Z+4	; 0x04
    37a6:	35 81       	ldd	r19, Z+5	; 0x05
    37a8:	8b 81       	ldd	r24, Y+3	; 0x03
    37aa:	9c 81       	ldd	r25, Y+4	; 0x04
    37ac:	82 1b       	sub	r24, r18
    37ae:	93 0b       	sbc	r25, r19
    37b0:	9c 83       	std	Y+4, r25	; 0x04
    37b2:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    37b4:	ed 81       	ldd	r30, Y+5	; 0x05
    37b6:	fe 81       	ldd	r31, Y+6	; 0x06
    37b8:	8b 81       	ldd	r24, Y+3	; 0x03
    37ba:	9c 81       	ldd	r25, Y+4	; 0x04
    37bc:	93 83       	std	Z+3, r25	; 0x03
    37be:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    37c0:	89 85       	ldd	r24, Y+9	; 0x09
    37c2:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    37c4:	2e 96       	adiw	r28, 0x0e	; 14
    37c6:	0f b6       	in	r0, 0x3f	; 63
    37c8:	f8 94       	cli
    37ca:	de bf       	out	0x3e, r29	; 62
    37cc:	0f be       	out	0x3f, r0	; 63
    37ce:	cd bf       	out	0x3d, r28	; 61
    37d0:	cf 91       	pop	r28
    37d2:	df 91       	pop	r29
    37d4:	08 95       	ret

000037d6 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    37d6:	df 93       	push	r29
    37d8:	cf 93       	push	r28
    37da:	cd b7       	in	r28, 0x3d	; 61
    37dc:	de b7       	in	r29, 0x3e	; 62
    37de:	66 97       	sbiw	r28, 0x16	; 22
    37e0:	0f b6       	in	r0, 0x3f	; 63
    37e2:	f8 94       	cli
    37e4:	de bf       	out	0x3e, r29	; 62
    37e6:	0f be       	out	0x3f, r0	; 63
    37e8:	cd bf       	out	0x3d, r28	; 61
    37ea:	98 87       	std	Y+8, r25	; 0x08
    37ec:	8f 83       	std	Y+7, r24	; 0x07
    37ee:	7a 87       	std	Y+10, r23	; 0x0a
    37f0:	69 87       	std	Y+9, r22	; 0x09
    37f2:	5c 87       	std	Y+12, r21	; 0x0c
    37f4:	4b 87       	std	Y+11, r20	; 0x0b
    37f6:	3e 87       	std	Y+14, r19	; 0x0e
    37f8:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    37fa:	2d 85       	ldd	r18, Y+13	; 0x0d
    37fc:	3e 85       	ldd	r19, Y+14	; 0x0e
    37fe:	3a 8b       	std	Y+18, r19	; 0x12
    3800:	29 8b       	std	Y+17, r18	; 0x11
    3802:	4b 85       	ldd	r20, Y+11	; 0x0b
    3804:	5c 85       	ldd	r21, Y+12	; 0x0c
    3806:	58 8b       	std	Y+16, r21	; 0x10
    3808:	4f 87       	std	Y+15, r20	; 0x0f
    380a:	8f 85       	ldd	r24, Y+15	; 0x0f
    380c:	98 89       	ldd	r25, Y+16	; 0x10
    380e:	29 89       	ldd	r18, Y+17	; 0x11
    3810:	3a 89       	ldd	r19, Y+18	; 0x12
    3812:	28 17       	cp	r18, r24
    3814:	39 07       	cpc	r19, r25
    3816:	20 f4       	brcc	.+8      	; 0x3820 <prvReadBytesFromBuffer+0x4a>
    3818:	49 89       	ldd	r20, Y+17	; 0x11
    381a:	5a 89       	ldd	r21, Y+18	; 0x12
    381c:	58 8b       	std	Y+16, r21	; 0x10
    381e:	4f 87       	std	Y+15, r20	; 0x0f
    3820:	8f 85       	ldd	r24, Y+15	; 0x0f
    3822:	98 89       	ldd	r25, Y+16	; 0x10
    3824:	9e 83       	std	Y+6, r25	; 0x06
    3826:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    3828:	8d 81       	ldd	r24, Y+5	; 0x05
    382a:	9e 81       	ldd	r25, Y+6	; 0x06
    382c:	00 97       	sbiw	r24, 0x00	; 0
    382e:	09 f4       	brne	.+2      	; 0x3832 <prvReadBytesFromBuffer+0x5c>
    3830:	74 c0       	rjmp	.+232    	; 0x391a <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    3832:	ef 81       	ldd	r30, Y+7	; 0x07
    3834:	f8 85       	ldd	r31, Y+8	; 0x08
    3836:	80 81       	ld	r24, Z
    3838:	91 81       	ldd	r25, Z+1	; 0x01
    383a:	9a 83       	std	Y+2, r25	; 0x02
    383c:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    383e:	ef 81       	ldd	r30, Y+7	; 0x07
    3840:	f8 85       	ldd	r31, Y+8	; 0x08
    3842:	24 81       	ldd	r18, Z+4	; 0x04
    3844:	35 81       	ldd	r19, Z+5	; 0x05
    3846:	89 81       	ldd	r24, Y+1	; 0x01
    3848:	9a 81       	ldd	r25, Y+2	; 0x02
    384a:	a9 01       	movw	r20, r18
    384c:	48 1b       	sub	r20, r24
    384e:	59 0b       	sbc	r21, r25
    3850:	ca 01       	movw	r24, r20
    3852:	2d 81       	ldd	r18, Y+5	; 0x05
    3854:	3e 81       	ldd	r19, Y+6	; 0x06
    3856:	3e 8b       	std	Y+22, r19	; 0x16
    3858:	2d 8b       	std	Y+21, r18	; 0x15
    385a:	9c 8b       	std	Y+20, r25	; 0x14
    385c:	8b 8b       	std	Y+19, r24	; 0x13
    385e:	4b 89       	ldd	r20, Y+19	; 0x13
    3860:	5c 89       	ldd	r21, Y+20	; 0x14
    3862:	8d 89       	ldd	r24, Y+21	; 0x15
    3864:	9e 89       	ldd	r25, Y+22	; 0x16
    3866:	84 17       	cp	r24, r20
    3868:	95 07       	cpc	r25, r21
    386a:	20 f4       	brcc	.+8      	; 0x3874 <prvReadBytesFromBuffer+0x9e>
    386c:	2d 89       	ldd	r18, Y+21	; 0x15
    386e:	3e 89       	ldd	r19, Y+22	; 0x16
    3870:	3c 8b       	std	Y+20, r19	; 0x14
    3872:	2b 8b       	std	Y+19, r18	; 0x13
    3874:	4b 89       	ldd	r20, Y+19	; 0x13
    3876:	5c 89       	ldd	r21, Y+20	; 0x14
    3878:	5c 83       	std	Y+4, r21	; 0x04
    387a:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    387c:	ef 81       	ldd	r30, Y+7	; 0x07
    387e:	f8 85       	ldd	r31, Y+8	; 0x08
    3880:	24 85       	ldd	r18, Z+12	; 0x0c
    3882:	35 85       	ldd	r19, Z+13	; 0x0d
    3884:	89 81       	ldd	r24, Y+1	; 0x01
    3886:	9a 81       	ldd	r25, Y+2	; 0x02
    3888:	a9 01       	movw	r20, r18
    388a:	48 0f       	add	r20, r24
    388c:	59 1f       	adc	r21, r25
    388e:	89 85       	ldd	r24, Y+9	; 0x09
    3890:	9a 85       	ldd	r25, Y+10	; 0x0a
    3892:	2b 81       	ldd	r18, Y+3	; 0x03
    3894:	3c 81       	ldd	r19, Y+4	; 0x04
    3896:	ba 01       	movw	r22, r20
    3898:	a9 01       	movw	r20, r18
    389a:	0e 94 27 2a 	call	0x544e	; 0x544e <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    389e:	2d 81       	ldd	r18, Y+5	; 0x05
    38a0:	3e 81       	ldd	r19, Y+6	; 0x06
    38a2:	8b 81       	ldd	r24, Y+3	; 0x03
    38a4:	9c 81       	ldd	r25, Y+4	; 0x04
    38a6:	82 17       	cp	r24, r18
    38a8:	93 07       	cpc	r25, r19
    38aa:	b0 f4       	brcc	.+44     	; 0x38d8 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    38ac:	29 85       	ldd	r18, Y+9	; 0x09
    38ae:	3a 85       	ldd	r19, Y+10	; 0x0a
    38b0:	8b 81       	ldd	r24, Y+3	; 0x03
    38b2:	9c 81       	ldd	r25, Y+4	; 0x04
    38b4:	b9 01       	movw	r22, r18
    38b6:	68 0f       	add	r22, r24
    38b8:	79 1f       	adc	r23, r25
    38ba:	ef 81       	ldd	r30, Y+7	; 0x07
    38bc:	f8 85       	ldd	r31, Y+8	; 0x08
    38be:	44 85       	ldd	r20, Z+12	; 0x0c
    38c0:	55 85       	ldd	r21, Z+13	; 0x0d
    38c2:	2d 81       	ldd	r18, Y+5	; 0x05
    38c4:	3e 81       	ldd	r19, Y+6	; 0x06
    38c6:	8b 81       	ldd	r24, Y+3	; 0x03
    38c8:	9c 81       	ldd	r25, Y+4	; 0x04
    38ca:	28 1b       	sub	r18, r24
    38cc:	39 0b       	sbc	r19, r25
    38ce:	cb 01       	movw	r24, r22
    38d0:	ba 01       	movw	r22, r20
    38d2:	a9 01       	movw	r20, r18
    38d4:	0e 94 27 2a 	call	0x544e	; 0x544e <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    38d8:	29 81       	ldd	r18, Y+1	; 0x01
    38da:	3a 81       	ldd	r19, Y+2	; 0x02
    38dc:	8d 81       	ldd	r24, Y+5	; 0x05
    38de:	9e 81       	ldd	r25, Y+6	; 0x06
    38e0:	82 0f       	add	r24, r18
    38e2:	93 1f       	adc	r25, r19
    38e4:	9a 83       	std	Y+2, r25	; 0x02
    38e6:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    38e8:	ef 81       	ldd	r30, Y+7	; 0x07
    38ea:	f8 85       	ldd	r31, Y+8	; 0x08
    38ec:	24 81       	ldd	r18, Z+4	; 0x04
    38ee:	35 81       	ldd	r19, Z+5	; 0x05
    38f0:	89 81       	ldd	r24, Y+1	; 0x01
    38f2:	9a 81       	ldd	r25, Y+2	; 0x02
    38f4:	82 17       	cp	r24, r18
    38f6:	93 07       	cpc	r25, r19
    38f8:	50 f0       	brcs	.+20     	; 0x390e <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    38fa:	ef 81       	ldd	r30, Y+7	; 0x07
    38fc:	f8 85       	ldd	r31, Y+8	; 0x08
    38fe:	24 81       	ldd	r18, Z+4	; 0x04
    3900:	35 81       	ldd	r19, Z+5	; 0x05
    3902:	89 81       	ldd	r24, Y+1	; 0x01
    3904:	9a 81       	ldd	r25, Y+2	; 0x02
    3906:	82 1b       	sub	r24, r18
    3908:	93 0b       	sbc	r25, r19
    390a:	9a 83       	std	Y+2, r25	; 0x02
    390c:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    390e:	ef 81       	ldd	r30, Y+7	; 0x07
    3910:	f8 85       	ldd	r31, Y+8	; 0x08
    3912:	89 81       	ldd	r24, Y+1	; 0x01
    3914:	9a 81       	ldd	r25, Y+2	; 0x02
    3916:	91 83       	std	Z+1, r25	; 0x01
    3918:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    391a:	8d 81       	ldd	r24, Y+5	; 0x05
    391c:	9e 81       	ldd	r25, Y+6	; 0x06
}
    391e:	66 96       	adiw	r28, 0x16	; 22
    3920:	0f b6       	in	r0, 0x3f	; 63
    3922:	f8 94       	cli
    3924:	de bf       	out	0x3e, r29	; 62
    3926:	0f be       	out	0x3f, r0	; 63
    3928:	cd bf       	out	0x3d, r28	; 61
    392a:	cf 91       	pop	r28
    392c:	df 91       	pop	r29
    392e:	08 95       	ret

00003930 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    3930:	df 93       	push	r29
    3932:	cf 93       	push	r28
    3934:	00 d0       	rcall	.+0      	; 0x3936 <prvBytesInBuffer+0x6>
    3936:	00 d0       	rcall	.+0      	; 0x3938 <prvBytesInBuffer+0x8>
    3938:	cd b7       	in	r28, 0x3d	; 61
    393a:	de b7       	in	r29, 0x3e	; 62
    393c:	9c 83       	std	Y+4, r25	; 0x04
    393e:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    3940:	eb 81       	ldd	r30, Y+3	; 0x03
    3942:	fc 81       	ldd	r31, Y+4	; 0x04
    3944:	24 81       	ldd	r18, Z+4	; 0x04
    3946:	35 81       	ldd	r19, Z+5	; 0x05
    3948:	eb 81       	ldd	r30, Y+3	; 0x03
    394a:	fc 81       	ldd	r31, Y+4	; 0x04
    394c:	82 81       	ldd	r24, Z+2	; 0x02
    394e:	93 81       	ldd	r25, Z+3	; 0x03
    3950:	82 0f       	add	r24, r18
    3952:	93 1f       	adc	r25, r19
    3954:	9a 83       	std	Y+2, r25	; 0x02
    3956:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    3958:	eb 81       	ldd	r30, Y+3	; 0x03
    395a:	fc 81       	ldd	r31, Y+4	; 0x04
    395c:	20 81       	ld	r18, Z
    395e:	31 81       	ldd	r19, Z+1	; 0x01
    3960:	89 81       	ldd	r24, Y+1	; 0x01
    3962:	9a 81       	ldd	r25, Y+2	; 0x02
    3964:	82 1b       	sub	r24, r18
    3966:	93 0b       	sbc	r25, r19
    3968:	9a 83       	std	Y+2, r25	; 0x02
    396a:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    396c:	eb 81       	ldd	r30, Y+3	; 0x03
    396e:	fc 81       	ldd	r31, Y+4	; 0x04
    3970:	24 81       	ldd	r18, Z+4	; 0x04
    3972:	35 81       	ldd	r19, Z+5	; 0x05
    3974:	89 81       	ldd	r24, Y+1	; 0x01
    3976:	9a 81       	ldd	r25, Y+2	; 0x02
    3978:	82 17       	cp	r24, r18
    397a:	93 07       	cpc	r25, r19
    397c:	50 f0       	brcs	.+20     	; 0x3992 <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    397e:	eb 81       	ldd	r30, Y+3	; 0x03
    3980:	fc 81       	ldd	r31, Y+4	; 0x04
    3982:	24 81       	ldd	r18, Z+4	; 0x04
    3984:	35 81       	ldd	r19, Z+5	; 0x05
    3986:	89 81       	ldd	r24, Y+1	; 0x01
    3988:	9a 81       	ldd	r25, Y+2	; 0x02
    398a:	82 1b       	sub	r24, r18
    398c:	93 0b       	sbc	r25, r19
    398e:	9a 83       	std	Y+2, r25	; 0x02
    3990:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    3992:	89 81       	ldd	r24, Y+1	; 0x01
    3994:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3996:	0f 90       	pop	r0
    3998:	0f 90       	pop	r0
    399a:	0f 90       	pop	r0
    399c:	0f 90       	pop	r0
    399e:	cf 91       	pop	r28
    39a0:	df 91       	pop	r29
    39a2:	08 95       	ret

000039a4 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    39a4:	0f 93       	push	r16
    39a6:	df 93       	push	r29
    39a8:	cf 93       	push	r28
    39aa:	cd b7       	in	r28, 0x3d	; 61
    39ac:	de b7       	in	r29, 0x3e	; 62
    39ae:	29 97       	sbiw	r28, 0x09	; 9
    39b0:	0f b6       	in	r0, 0x3f	; 63
    39b2:	f8 94       	cli
    39b4:	de bf       	out	0x3e, r29	; 62
    39b6:	0f be       	out	0x3f, r0	; 63
    39b8:	cd bf       	out	0x3d, r28	; 61
    39ba:	9a 83       	std	Y+2, r25	; 0x02
    39bc:	89 83       	std	Y+1, r24	; 0x01
    39be:	7c 83       	std	Y+4, r23	; 0x04
    39c0:	6b 83       	std	Y+3, r22	; 0x03
    39c2:	5e 83       	std	Y+6, r21	; 0x06
    39c4:	4d 83       	std	Y+5, r20	; 0x05
    39c6:	38 87       	std	Y+8, r19	; 0x08
    39c8:	2f 83       	std	Y+7, r18	; 0x07
    39ca:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    39cc:	89 81       	ldd	r24, Y+1	; 0x01
    39ce:	9a 81       	ldd	r25, Y+2	; 0x02
    39d0:	60 e0       	ldi	r22, 0x00	; 0
    39d2:	70 e0       	ldi	r23, 0x00	; 0
    39d4:	4f e0       	ldi	r20, 0x0F	; 15
    39d6:	50 e0       	ldi	r21, 0x00	; 0
    39d8:	0e 94 30 2a 	call	0x5460	; 0x5460 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    39dc:	e9 81       	ldd	r30, Y+1	; 0x01
    39de:	fa 81       	ldd	r31, Y+2	; 0x02
    39e0:	8b 81       	ldd	r24, Y+3	; 0x03
    39e2:	9c 81       	ldd	r25, Y+4	; 0x04
    39e4:	95 87       	std	Z+13, r25	; 0x0d
    39e6:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    39e8:	e9 81       	ldd	r30, Y+1	; 0x01
    39ea:	fa 81       	ldd	r31, Y+2	; 0x02
    39ec:	8d 81       	ldd	r24, Y+5	; 0x05
    39ee:	9e 81       	ldd	r25, Y+6	; 0x06
    39f0:	95 83       	std	Z+5, r25	; 0x05
    39f2:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    39f4:	e9 81       	ldd	r30, Y+1	; 0x01
    39f6:	fa 81       	ldd	r31, Y+2	; 0x02
    39f8:	8f 81       	ldd	r24, Y+7	; 0x07
    39fa:	98 85       	ldd	r25, Y+8	; 0x08
    39fc:	97 83       	std	Z+7, r25	; 0x07
    39fe:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    3a00:	e9 81       	ldd	r30, Y+1	; 0x01
    3a02:	fa 81       	ldd	r31, Y+2	; 0x02
    3a04:	89 85       	ldd	r24, Y+9	; 0x09
    3a06:	86 87       	std	Z+14, r24	; 0x0e
}
    3a08:	29 96       	adiw	r28, 0x09	; 9
    3a0a:	0f b6       	in	r0, 0x3f	; 63
    3a0c:	f8 94       	cli
    3a0e:	de bf       	out	0x3e, r29	; 62
    3a10:	0f be       	out	0x3f, r0	; 63
    3a12:	cd bf       	out	0x3d, r28	; 61
    3a14:	cf 91       	pop	r28
    3a16:	df 91       	pop	r29
    3a18:	0f 91       	pop	r16
    3a1a:	08 95       	ret

00003a1c <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    3a1c:	8f 92       	push	r8
    3a1e:	9f 92       	push	r9
    3a20:	af 92       	push	r10
    3a22:	bf 92       	push	r11
    3a24:	cf 92       	push	r12
    3a26:	df 92       	push	r13
    3a28:	ef 92       	push	r14
    3a2a:	ff 92       	push	r15
    3a2c:	0f 93       	push	r16
    3a2e:	1f 93       	push	r17
    3a30:	df 93       	push	r29
    3a32:	cf 93       	push	r28
    3a34:	cd b7       	in	r28, 0x3d	; 61
    3a36:	de b7       	in	r29, 0x3e	; 62
    3a38:	60 97       	sbiw	r28, 0x10	; 16
    3a3a:	0f b6       	in	r0, 0x3f	; 63
    3a3c:	f8 94       	cli
    3a3e:	de bf       	out	0x3e, r29	; 62
    3a40:	0f be       	out	0x3f, r0	; 63
    3a42:	cd bf       	out	0x3d, r28	; 61
    3a44:	9f 83       	std	Y+7, r25	; 0x07
    3a46:	8e 83       	std	Y+6, r24	; 0x06
    3a48:	79 87       	std	Y+9, r23	; 0x09
    3a4a:	68 87       	std	Y+8, r22	; 0x08
    3a4c:	5b 87       	std	Y+11, r21	; 0x0b
    3a4e:	4a 87       	std	Y+10, r20	; 0x0a
    3a50:	3d 87       	std	Y+13, r19	; 0x0d
    3a52:	2c 87       	std	Y+12, r18	; 0x0c
    3a54:	0e 87       	std	Y+14, r16	; 0x0e
    3a56:	f8 8a       	std	Y+16, r15	; 0x10
    3a58:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3a5a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a5c:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a5e:	0e 94 1b 07 	call	0xe36	; 0xe36 <pvPortMalloc>
    3a62:	9a 83       	std	Y+2, r25	; 0x02
    3a64:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    3a66:	89 81       	ldd	r24, Y+1	; 0x01
    3a68:	9a 81       	ldd	r25, Y+2	; 0x02
    3a6a:	00 97       	sbiw	r24, 0x00	; 0
    3a6c:	b1 f0       	breq	.+44     	; 0x3a9a <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3a6e:	8a e2       	ldi	r24, 0x2A	; 42
    3a70:	90 e0       	ldi	r25, 0x00	; 0
    3a72:	0e 94 1b 07 	call	0xe36	; 0xe36 <pvPortMalloc>
    3a76:	9d 83       	std	Y+5, r25	; 0x05
    3a78:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    3a7a:	8c 81       	ldd	r24, Y+4	; 0x04
    3a7c:	9d 81       	ldd	r25, Y+5	; 0x05
    3a7e:	00 97       	sbiw	r24, 0x00	; 0
    3a80:	39 f0       	breq	.+14     	; 0x3a90 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    3a82:	ec 81       	ldd	r30, Y+4	; 0x04
    3a84:	fd 81       	ldd	r31, Y+5	; 0x05
    3a86:	89 81       	ldd	r24, Y+1	; 0x01
    3a88:	9a 81       	ldd	r25, Y+2	; 0x02
    3a8a:	90 8f       	std	Z+24, r25	; 0x18
    3a8c:	87 8b       	std	Z+23, r24	; 0x17
    3a8e:	07 c0       	rjmp	.+14     	; 0x3a9e <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    3a90:	89 81       	ldd	r24, Y+1	; 0x01
    3a92:	9a 81       	ldd	r25, Y+2	; 0x02
    3a94:	0e 94 71 07 	call	0xee2	; 0xee2 <vPortFree>
    3a98:	02 c0       	rjmp	.+4      	; 0x3a9e <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    3a9a:	1d 82       	std	Y+5, r1	; 0x05
    3a9c:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    3a9e:	8c 81       	ldd	r24, Y+4	; 0x04
    3aa0:	9d 81       	ldd	r25, Y+5	; 0x05
    3aa2:	00 97       	sbiw	r24, 0x00	; 0
    3aa4:	e9 f0       	breq	.+58     	; 0x3ae0 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3aa6:	8a 85       	ldd	r24, Y+10	; 0x0a
    3aa8:	9b 85       	ldd	r25, Y+11	; 0x0b
    3aaa:	9c 01       	movw	r18, r24
    3aac:	40 e0       	ldi	r20, 0x00	; 0
    3aae:	50 e0       	ldi	r21, 0x00	; 0
    3ab0:	8e 81       	ldd	r24, Y+6	; 0x06
    3ab2:	9f 81       	ldd	r25, Y+7	; 0x07
    3ab4:	68 85       	ldd	r22, Y+8	; 0x08
    3ab6:	79 85       	ldd	r23, Y+9	; 0x09
    3ab8:	ec 85       	ldd	r30, Y+12	; 0x0c
    3aba:	fd 85       	ldd	r31, Y+13	; 0x0d
    3abc:	af 85       	ldd	r26, Y+15	; 0x0f
    3abe:	b8 89       	ldd	r27, Y+16	; 0x10
    3ac0:	ac 80       	ldd	r10, Y+4	; 0x04
    3ac2:	bd 80       	ldd	r11, Y+5	; 0x05
    3ac4:	8f 01       	movw	r16, r30
    3ac6:	ee 84       	ldd	r14, Y+14	; 0x0e
    3ac8:	6d 01       	movw	r12, r26
    3aca:	88 24       	eor	r8, r8
    3acc:	99 24       	eor	r9, r9
    3ace:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    3ad2:	8c 81       	ldd	r24, Y+4	; 0x04
    3ad4:	9d 81       	ldd	r25, Y+5	; 0x05
    3ad6:	0e 94 42 1e 	call	0x3c84	; 0x3c84 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    3ada:	81 e0       	ldi	r24, 0x01	; 1
    3adc:	8b 83       	std	Y+3, r24	; 0x03
    3ade:	02 c0       	rjmp	.+4      	; 0x3ae4 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3ae0:	8f ef       	ldi	r24, 0xFF	; 255
    3ae2:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    3ae4:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    3ae6:	60 96       	adiw	r28, 0x10	; 16
    3ae8:	0f b6       	in	r0, 0x3f	; 63
    3aea:	f8 94       	cli
    3aec:	de bf       	out	0x3e, r29	; 62
    3aee:	0f be       	out	0x3f, r0	; 63
    3af0:	cd bf       	out	0x3d, r28	; 61
    3af2:	cf 91       	pop	r28
    3af4:	df 91       	pop	r29
    3af6:	1f 91       	pop	r17
    3af8:	0f 91       	pop	r16
    3afa:	ff 90       	pop	r15
    3afc:	ef 90       	pop	r14
    3afe:	df 90       	pop	r13
    3b00:	cf 90       	pop	r12
    3b02:	bf 90       	pop	r11
    3b04:	af 90       	pop	r10
    3b06:	9f 90       	pop	r9
    3b08:	8f 90       	pop	r8
    3b0a:	08 95       	ret

00003b0c <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    3b0c:	8f 92       	push	r8
    3b0e:	9f 92       	push	r9
    3b10:	af 92       	push	r10
    3b12:	bf 92       	push	r11
    3b14:	cf 92       	push	r12
    3b16:	df 92       	push	r13
    3b18:	ef 92       	push	r14
    3b1a:	0f 93       	push	r16
    3b1c:	1f 93       	push	r17
    3b1e:	df 93       	push	r29
    3b20:	cf 93       	push	r28
    3b22:	cd b7       	in	r28, 0x3d	; 61
    3b24:	de b7       	in	r29, 0x3e	; 62
    3b26:	64 97       	sbiw	r28, 0x14	; 20
    3b28:	0f b6       	in	r0, 0x3f	; 63
    3b2a:	f8 94       	cli
    3b2c:	de bf       	out	0x3e, r29	; 62
    3b2e:	0f be       	out	0x3f, r0	; 63
    3b30:	cd bf       	out	0x3d, r28	; 61
    3b32:	9d 83       	std	Y+5, r25	; 0x05
    3b34:	8c 83       	std	Y+4, r24	; 0x04
    3b36:	7f 83       	std	Y+7, r23	; 0x07
    3b38:	6e 83       	std	Y+6, r22	; 0x06
    3b3a:	28 87       	std	Y+8, r18	; 0x08
    3b3c:	39 87       	std	Y+9, r19	; 0x09
    3b3e:	4a 87       	std	Y+10, r20	; 0x0a
    3b40:	5b 87       	std	Y+11, r21	; 0x0b
    3b42:	1d 87       	std	Y+13, r17	; 0x0d
    3b44:	0c 87       	std	Y+12, r16	; 0x0c
    3b46:	ee 86       	std	Y+14, r14	; 0x0e
    3b48:	d8 8a       	std	Y+16, r13	; 0x10
    3b4a:	cf 86       	std	Y+15, r12	; 0x0f
    3b4c:	ba 8a       	std	Y+18, r11	; 0x12
    3b4e:	a9 8a       	std	Y+17, r10	; 0x11
    3b50:	9c 8a       	std	Y+20, r9	; 0x14
    3b52:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3b54:	e9 89       	ldd	r30, Y+17	; 0x11
    3b56:	fa 89       	ldd	r31, Y+18	; 0x12
    3b58:	27 89       	ldd	r18, Z+23	; 0x17
    3b5a:	30 8d       	ldd	r19, Z+24	; 0x18
    3b5c:	88 85       	ldd	r24, Y+8	; 0x08
    3b5e:	99 85       	ldd	r25, Y+9	; 0x09
    3b60:	01 97       	sbiw	r24, 0x01	; 1
    3b62:	82 0f       	add	r24, r18
    3b64:	93 1f       	adc	r25, r19
    3b66:	9b 83       	std	Y+3, r25	; 0x03
    3b68:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    3b6a:	8e 81       	ldd	r24, Y+6	; 0x06
    3b6c:	9f 81       	ldd	r25, Y+7	; 0x07
    3b6e:	00 97       	sbiw	r24, 0x00	; 0
    3b70:	51 f1       	breq	.+84     	; 0x3bc6 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3b72:	19 82       	std	Y+1, r1	; 0x01
    3b74:	21 c0       	rjmp	.+66     	; 0x3bb8 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3b76:	89 81       	ldd	r24, Y+1	; 0x01
    3b78:	48 2f       	mov	r20, r24
    3b7a:	50 e0       	ldi	r21, 0x00	; 0
    3b7c:	89 81       	ldd	r24, Y+1	; 0x01
    3b7e:	28 2f       	mov	r18, r24
    3b80:	30 e0       	ldi	r19, 0x00	; 0
    3b82:	8e 81       	ldd	r24, Y+6	; 0x06
    3b84:	9f 81       	ldd	r25, Y+7	; 0x07
    3b86:	fc 01       	movw	r30, r24
    3b88:	e2 0f       	add	r30, r18
    3b8a:	f3 1f       	adc	r31, r19
    3b8c:	20 81       	ld	r18, Z
    3b8e:	89 89       	ldd	r24, Y+17	; 0x11
    3b90:	9a 89       	ldd	r25, Y+18	; 0x12
    3b92:	84 0f       	add	r24, r20
    3b94:	95 1f       	adc	r25, r21
    3b96:	fc 01       	movw	r30, r24
    3b98:	79 96       	adiw	r30, 0x19	; 25
    3b9a:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    3b9c:	89 81       	ldd	r24, Y+1	; 0x01
    3b9e:	28 2f       	mov	r18, r24
    3ba0:	30 e0       	ldi	r19, 0x00	; 0
    3ba2:	8e 81       	ldd	r24, Y+6	; 0x06
    3ba4:	9f 81       	ldd	r25, Y+7	; 0x07
    3ba6:	fc 01       	movw	r30, r24
    3ba8:	e2 0f       	add	r30, r18
    3baa:	f3 1f       	adc	r31, r19
    3bac:	80 81       	ld	r24, Z
    3bae:	88 23       	and	r24, r24
    3bb0:	31 f0       	breq	.+12     	; 0x3bbe <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3bb2:	89 81       	ldd	r24, Y+1	; 0x01
    3bb4:	8f 5f       	subi	r24, 0xFF	; 255
    3bb6:	89 83       	std	Y+1, r24	; 0x01
    3bb8:	89 81       	ldd	r24, Y+1	; 0x01
    3bba:	8c 30       	cpi	r24, 0x0C	; 12
    3bbc:	e0 f2       	brcs	.-72     	; 0x3b76 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3bbe:	e9 89       	ldd	r30, Y+17	; 0x11
    3bc0:	fa 89       	ldd	r31, Y+18	; 0x12
    3bc2:	14 a2       	std	Z+36, r1	; 0x24
    3bc4:	03 c0       	rjmp	.+6      	; 0x3bcc <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3bc6:	e9 89       	ldd	r30, Y+17	; 0x11
    3bc8:	fa 89       	ldd	r31, Y+18	; 0x12
    3bca:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3bcc:	8e 85       	ldd	r24, Y+14	; 0x0e
    3bce:	84 30       	cpi	r24, 0x04	; 4
    3bd0:	10 f0       	brcs	.+4      	; 0x3bd6 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3bd2:	83 e0       	ldi	r24, 0x03	; 3
    3bd4:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    3bd6:	e9 89       	ldd	r30, Y+17	; 0x11
    3bd8:	fa 89       	ldd	r31, Y+18	; 0x12
    3bda:	8e 85       	ldd	r24, Y+14	; 0x0e
    3bdc:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3bde:	89 89       	ldd	r24, Y+17	; 0x11
    3be0:	9a 89       	ldd	r25, Y+18	; 0x12
    3be2:	02 96       	adiw	r24, 0x02	; 2
    3be4:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3be8:	89 89       	ldd	r24, Y+17	; 0x11
    3bea:	9a 89       	ldd	r25, Y+18	; 0x12
    3bec:	0c 96       	adiw	r24, 0x0c	; 12
    3bee:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3bf2:	e9 89       	ldd	r30, Y+17	; 0x11
    3bf4:	fa 89       	ldd	r31, Y+18	; 0x12
    3bf6:	89 89       	ldd	r24, Y+17	; 0x11
    3bf8:	9a 89       	ldd	r25, Y+18	; 0x12
    3bfa:	91 87       	std	Z+9, r25	; 0x09
    3bfc:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3bfe:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c00:	28 2f       	mov	r18, r24
    3c02:	30 e0       	ldi	r19, 0x00	; 0
    3c04:	84 e0       	ldi	r24, 0x04	; 4
    3c06:	90 e0       	ldi	r25, 0x00	; 0
    3c08:	82 1b       	sub	r24, r18
    3c0a:	93 0b       	sbc	r25, r19
    3c0c:	e9 89       	ldd	r30, Y+17	; 0x11
    3c0e:	fa 89       	ldd	r31, Y+18	; 0x12
    3c10:	95 87       	std	Z+13, r25	; 0x0d
    3c12:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3c14:	e9 89       	ldd	r30, Y+17	; 0x11
    3c16:	fa 89       	ldd	r31, Y+18	; 0x12
    3c18:	89 89       	ldd	r24, Y+17	; 0x11
    3c1a:	9a 89       	ldd	r25, Y+18	; 0x12
    3c1c:	93 8b       	std	Z+19, r25	; 0x13
    3c1e:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    3c20:	e9 89       	ldd	r30, Y+17	; 0x11
    3c22:	fa 89       	ldd	r31, Y+18	; 0x12
    3c24:	15 a2       	std	Z+37, r1	; 0x25
    3c26:	16 a2       	std	Z+38, r1	; 0x26
    3c28:	17 a2       	std	Z+39, r1	; 0x27
    3c2a:	10 a6       	std	Z+40, r1	; 0x28
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3c2c:	e9 89       	ldd	r30, Y+17	; 0x11
    3c2e:	fa 89       	ldd	r31, Y+18	; 0x12
    3c30:	11 a6       	std	Z+41, r1	; 0x29
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3c32:	8a 81       	ldd	r24, Y+2	; 0x02
    3c34:	9b 81       	ldd	r25, Y+3	; 0x03
    3c36:	2c 81       	ldd	r18, Y+4	; 0x04
    3c38:	3d 81       	ldd	r19, Y+5	; 0x05
    3c3a:	4c 85       	ldd	r20, Y+12	; 0x0c
    3c3c:	5d 85       	ldd	r21, Y+13	; 0x0d
    3c3e:	b9 01       	movw	r22, r18
    3c40:	0e 94 84 0b 	call	0x1708	; 0x1708 <pxPortInitialiseStack>
    3c44:	e9 89       	ldd	r30, Y+17	; 0x11
    3c46:	fa 89       	ldd	r31, Y+18	; 0x12
    3c48:	91 83       	std	Z+1, r25	; 0x01
    3c4a:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    3c4c:	8f 85       	ldd	r24, Y+15	; 0x0f
    3c4e:	98 89       	ldd	r25, Y+16	; 0x10
    3c50:	00 97       	sbiw	r24, 0x00	; 0
    3c52:	31 f0       	breq	.+12     	; 0x3c60 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3c54:	ef 85       	ldd	r30, Y+15	; 0x0f
    3c56:	f8 89       	ldd	r31, Y+16	; 0x10
    3c58:	89 89       	ldd	r24, Y+17	; 0x11
    3c5a:	9a 89       	ldd	r25, Y+18	; 0x12
    3c5c:	91 83       	std	Z+1, r25	; 0x01
    3c5e:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3c60:	64 96       	adiw	r28, 0x14	; 20
    3c62:	0f b6       	in	r0, 0x3f	; 63
    3c64:	f8 94       	cli
    3c66:	de bf       	out	0x3e, r29	; 62
    3c68:	0f be       	out	0x3f, r0	; 63
    3c6a:	cd bf       	out	0x3d, r28	; 61
    3c6c:	cf 91       	pop	r28
    3c6e:	df 91       	pop	r29
    3c70:	1f 91       	pop	r17
    3c72:	0f 91       	pop	r16
    3c74:	ef 90       	pop	r14
    3c76:	df 90       	pop	r13
    3c78:	cf 90       	pop	r12
    3c7a:	bf 90       	pop	r11
    3c7c:	af 90       	pop	r10
    3c7e:	9f 90       	pop	r9
    3c80:	8f 90       	pop	r8
    3c82:	08 95       	ret

00003c84 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    3c84:	df 93       	push	r29
    3c86:	cf 93       	push	r28
    3c88:	00 d0       	rcall	.+0      	; 0x3c8a <prvAddNewTaskToReadyList+0x6>
    3c8a:	cd b7       	in	r28, 0x3d	; 61
    3c8c:	de b7       	in	r29, 0x3e	; 62
    3c8e:	9a 83       	std	Y+2, r25	; 0x02
    3c90:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    3c92:	0f b6       	in	r0, 0x3f	; 63
    3c94:	f8 94       	cli
    3c96:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    3c98:	80 91 90 06 	lds	r24, 0x0690
    3c9c:	8f 5f       	subi	r24, 0xFF	; 255
    3c9e:	80 93 90 06 	sts	0x0690, r24
		if( pxCurrentTCB == NULL )
    3ca2:	80 91 8d 06 	lds	r24, 0x068D
    3ca6:	90 91 8e 06 	lds	r25, 0x068E
    3caa:	00 97       	sbiw	r24, 0x00	; 0
    3cac:	69 f4       	brne	.+26     	; 0x3cc8 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    3cae:	89 81       	ldd	r24, Y+1	; 0x01
    3cb0:	9a 81       	ldd	r25, Y+2	; 0x02
    3cb2:	90 93 8e 06 	sts	0x068E, r25
    3cb6:	80 93 8d 06 	sts	0x068D, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3cba:	80 91 90 06 	lds	r24, 0x0690
    3cbe:	81 30       	cpi	r24, 0x01	; 1
    3cc0:	b9 f4       	brne	.+46     	; 0x3cf0 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    3cc2:	0e 94 19 25 	call	0x4a32	; 0x4a32 <prvInitialiseTaskLists>
    3cc6:	14 c0       	rjmp	.+40     	; 0x3cf0 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    3cc8:	80 91 94 06 	lds	r24, 0x0694
    3ccc:	88 23       	and	r24, r24
    3cce:	81 f4       	brne	.+32     	; 0x3cf0 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3cd0:	e0 91 8d 06 	lds	r30, 0x068D
    3cd4:	f0 91 8e 06 	lds	r31, 0x068E
    3cd8:	96 89       	ldd	r25, Z+22	; 0x16
    3cda:	e9 81       	ldd	r30, Y+1	; 0x01
    3cdc:	fa 81       	ldd	r31, Y+2	; 0x02
    3cde:	86 89       	ldd	r24, Z+22	; 0x16
    3ce0:	89 17       	cp	r24, r25
    3ce2:	30 f0       	brcs	.+12     	; 0x3cf0 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    3ce4:	89 81       	ldd	r24, Y+1	; 0x01
    3ce6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ce8:	90 93 8e 06 	sts	0x068E, r25
    3cec:	80 93 8d 06 	sts	0x068D, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    3cf0:	80 91 98 06 	lds	r24, 0x0698
    3cf4:	8f 5f       	subi	r24, 0xFF	; 255
    3cf6:	80 93 98 06 	sts	0x0698, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    3cfa:	e9 81       	ldd	r30, Y+1	; 0x01
    3cfc:	fa 81       	ldd	r31, Y+2	; 0x02
    3cfe:	96 89       	ldd	r25, Z+22	; 0x16
    3d00:	80 91 93 06 	lds	r24, 0x0693
    3d04:	89 17       	cp	r24, r25
    3d06:	28 f4       	brcc	.+10     	; 0x3d12 <prvAddNewTaskToReadyList+0x8e>
    3d08:	e9 81       	ldd	r30, Y+1	; 0x01
    3d0a:	fa 81       	ldd	r31, Y+2	; 0x02
    3d0c:	86 89       	ldd	r24, Z+22	; 0x16
    3d0e:	80 93 93 06 	sts	0x0693, r24
    3d12:	e9 81       	ldd	r30, Y+1	; 0x01
    3d14:	fa 81       	ldd	r31, Y+2	; 0x02
    3d16:	86 89       	ldd	r24, Z+22	; 0x16
    3d18:	28 2f       	mov	r18, r24
    3d1a:	30 e0       	ldi	r19, 0x00	; 0
    3d1c:	c9 01       	movw	r24, r18
    3d1e:	88 0f       	add	r24, r24
    3d20:	99 1f       	adc	r25, r25
    3d22:	88 0f       	add	r24, r24
    3d24:	99 1f       	adc	r25, r25
    3d26:	88 0f       	add	r24, r24
    3d28:	99 1f       	adc	r25, r25
    3d2a:	82 0f       	add	r24, r18
    3d2c:	93 1f       	adc	r25, r19
    3d2e:	ac 01       	movw	r20, r24
    3d30:	42 56       	subi	r20, 0x62	; 98
    3d32:	59 4f       	sbci	r21, 0xF9	; 249
    3d34:	89 81       	ldd	r24, Y+1	; 0x01
    3d36:	9a 81       	ldd	r25, Y+2	; 0x02
    3d38:	9c 01       	movw	r18, r24
    3d3a:	2e 5f       	subi	r18, 0xFE	; 254
    3d3c:	3f 4f       	sbci	r19, 0xFF	; 255
    3d3e:	ca 01       	movw	r24, r20
    3d40:	b9 01       	movw	r22, r18
    3d42:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    3d46:	0f 90       	pop	r0
    3d48:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    3d4a:	80 91 94 06 	lds	r24, 0x0694
    3d4e:	88 23       	and	r24, r24
    3d50:	61 f0       	breq	.+24     	; 0x3d6a <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3d52:	e0 91 8d 06 	lds	r30, 0x068D
    3d56:	f0 91 8e 06 	lds	r31, 0x068E
    3d5a:	96 89       	ldd	r25, Z+22	; 0x16
    3d5c:	e9 81       	ldd	r30, Y+1	; 0x01
    3d5e:	fa 81       	ldd	r31, Y+2	; 0x02
    3d60:	86 89       	ldd	r24, Z+22	; 0x16
    3d62:	98 17       	cp	r25, r24
    3d64:	10 f4       	brcc	.+4      	; 0x3d6a <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    3d66:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3d6a:	0f 90       	pop	r0
    3d6c:	0f 90       	pop	r0
    3d6e:	cf 91       	pop	r28
    3d70:	df 91       	pop	r29
    3d72:	08 95       	ret

00003d74 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    3d74:	df 93       	push	r29
    3d76:	cf 93       	push	r28
    3d78:	00 d0       	rcall	.+0      	; 0x3d7a <vTaskDelete+0x6>
    3d7a:	00 d0       	rcall	.+0      	; 0x3d7c <vTaskDelete+0x8>
    3d7c:	00 d0       	rcall	.+0      	; 0x3d7e <vTaskDelete+0xa>
    3d7e:	cd b7       	in	r28, 0x3d	; 61
    3d80:	de b7       	in	r29, 0x3e	; 62
    3d82:	9c 83       	std	Y+4, r25	; 0x04
    3d84:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3d86:	0f b6       	in	r0, 0x3f	; 63
    3d88:	f8 94       	cli
    3d8a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3d8c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d8e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d90:	00 97       	sbiw	r24, 0x00	; 0
    3d92:	39 f4       	brne	.+14     	; 0x3da2 <vTaskDelete+0x2e>
    3d94:	80 91 8d 06 	lds	r24, 0x068D
    3d98:	90 91 8e 06 	lds	r25, 0x068E
    3d9c:	9e 83       	std	Y+6, r25	; 0x06
    3d9e:	8d 83       	std	Y+5, r24	; 0x05
    3da0:	04 c0       	rjmp	.+8      	; 0x3daa <vTaskDelete+0x36>
    3da2:	8b 81       	ldd	r24, Y+3	; 0x03
    3da4:	9c 81       	ldd	r25, Y+4	; 0x04
    3da6:	9e 83       	std	Y+6, r25	; 0x06
    3da8:	8d 83       	std	Y+5, r24	; 0x05
    3daa:	8d 81       	ldd	r24, Y+5	; 0x05
    3dac:	9e 81       	ldd	r25, Y+6	; 0x06
    3dae:	9a 83       	std	Y+2, r25	; 0x02
    3db0:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3db2:	89 81       	ldd	r24, Y+1	; 0x01
    3db4:	9a 81       	ldd	r25, Y+2	; 0x02
    3db6:	02 96       	adiw	r24, 0x02	; 2
    3db8:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3dbc:	e9 81       	ldd	r30, Y+1	; 0x01
    3dbe:	fa 81       	ldd	r31, Y+2	; 0x02
    3dc0:	84 89       	ldd	r24, Z+20	; 0x14
    3dc2:	95 89       	ldd	r25, Z+21	; 0x15
    3dc4:	00 97       	sbiw	r24, 0x00	; 0
    3dc6:	29 f0       	breq	.+10     	; 0x3dd2 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3dc8:	89 81       	ldd	r24, Y+1	; 0x01
    3dca:	9a 81       	ldd	r25, Y+2	; 0x02
    3dcc:	0c 96       	adiw	r24, 0x0c	; 12
    3dce:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    3dd2:	80 91 98 06 	lds	r24, 0x0698
    3dd6:	8f 5f       	subi	r24, 0xFF	; 255
    3dd8:	80 93 98 06 	sts	0x0698, r24

			if( pxTCB == pxCurrentTCB )
    3ddc:	20 91 8d 06 	lds	r18, 0x068D
    3de0:	30 91 8e 06 	lds	r19, 0x068E
    3de4:	89 81       	ldd	r24, Y+1	; 0x01
    3de6:	9a 81       	ldd	r25, Y+2	; 0x02
    3de8:	82 17       	cp	r24, r18
    3dea:	93 07       	cpc	r25, r19
    3dec:	81 f4       	brne	.+32     	; 0x3e0e <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3dee:	89 81       	ldd	r24, Y+1	; 0x01
    3df0:	9a 81       	ldd	r25, Y+2	; 0x02
    3df2:	9c 01       	movw	r18, r24
    3df4:	2e 5f       	subi	r18, 0xFE	; 254
    3df6:	3f 4f       	sbci	r19, 0xFF	; 255
    3df8:	81 ee       	ldi	r24, 0xE1	; 225
    3dfa:	96 e0       	ldi	r25, 0x06	; 6
    3dfc:	b9 01       	movw	r22, r18
    3dfe:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    3e02:	80 91 8f 06 	lds	r24, 0x068F
    3e06:	8f 5f       	subi	r24, 0xFF	; 255
    3e08:	80 93 8f 06 	sts	0x068F, r24
    3e0c:	0b c0       	rjmp	.+22     	; 0x3e24 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    3e0e:	80 91 90 06 	lds	r24, 0x0690
    3e12:	81 50       	subi	r24, 0x01	; 1
    3e14:	80 93 90 06 	sts	0x0690, r24
				prvDeleteTCB( pxTCB );
    3e18:	89 81       	ldd	r24, Y+1	; 0x01
    3e1a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e1c:	0e 94 89 25 	call	0x4b12	; 0x4b12 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    3e20:	0e 94 9f 25 	call	0x4b3e	; 0x4b3e <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    3e24:	0f 90       	pop	r0
    3e26:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    3e28:	80 91 94 06 	lds	r24, 0x0694
    3e2c:	88 23       	and	r24, r24
    3e2e:	59 f0       	breq	.+22     	; 0x3e46 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    3e30:	20 91 8d 06 	lds	r18, 0x068D
    3e34:	30 91 8e 06 	lds	r19, 0x068E
    3e38:	89 81       	ldd	r24, Y+1	; 0x01
    3e3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e3c:	82 17       	cp	r24, r18
    3e3e:	93 07       	cpc	r25, r19
    3e40:	11 f4       	brne	.+4      	; 0x3e46 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3e42:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    3e46:	26 96       	adiw	r28, 0x06	; 6
    3e48:	0f b6       	in	r0, 0x3f	; 63
    3e4a:	f8 94       	cli
    3e4c:	de bf       	out	0x3e, r29	; 62
    3e4e:	0f be       	out	0x3f, r0	; 63
    3e50:	cd bf       	out	0x3d, r28	; 61
    3e52:	cf 91       	pop	r28
    3e54:	df 91       	pop	r29
    3e56:	08 95       	ret

00003e58 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3e58:	df 93       	push	r29
    3e5a:	cf 93       	push	r28
    3e5c:	00 d0       	rcall	.+0      	; 0x3e5e <vTaskDelay+0x6>
    3e5e:	0f 92       	push	r0
    3e60:	cd b7       	in	r28, 0x3d	; 61
    3e62:	de b7       	in	r29, 0x3e	; 62
    3e64:	9b 83       	std	Y+3, r25	; 0x03
    3e66:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    3e68:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3e6a:	8a 81       	ldd	r24, Y+2	; 0x02
    3e6c:	9b 81       	ldd	r25, Y+3	; 0x03
    3e6e:	00 97       	sbiw	r24, 0x00	; 0
    3e70:	51 f0       	breq	.+20     	; 0x3e86 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    3e72:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3e76:	8a 81       	ldd	r24, Y+2	; 0x02
    3e78:	9b 81       	ldd	r25, Y+3	; 0x03
    3e7a:	60 e0       	ldi	r22, 0x00	; 0
    3e7c:	0e 94 ab 29 	call	0x5356	; 0x5356 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3e80:	0e 94 05 21 	call	0x420a	; 0x420a <xTaskResumeAll>
    3e84:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3e86:	89 81       	ldd	r24, Y+1	; 0x01
    3e88:	88 23       	and	r24, r24
    3e8a:	11 f4       	brne	.+4      	; 0x3e90 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    3e8c:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3e90:	0f 90       	pop	r0
    3e92:	0f 90       	pop	r0
    3e94:	0f 90       	pop	r0
    3e96:	cf 91       	pop	r28
    3e98:	df 91       	pop	r29
    3e9a:	08 95       	ret

00003e9c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    3e9c:	df 93       	push	r29
    3e9e:	cf 93       	push	r28
    3ea0:	00 d0       	rcall	.+0      	; 0x3ea2 <vTaskSuspend+0x6>
    3ea2:	00 d0       	rcall	.+0      	; 0x3ea4 <vTaskSuspend+0x8>
    3ea4:	00 d0       	rcall	.+0      	; 0x3ea6 <vTaskSuspend+0xa>
    3ea6:	cd b7       	in	r28, 0x3d	; 61
    3ea8:	de b7       	in	r29, 0x3e	; 62
    3eaa:	9c 83       	std	Y+4, r25	; 0x04
    3eac:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3eae:	0f b6       	in	r0, 0x3f	; 63
    3eb0:	f8 94       	cli
    3eb2:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    3eb4:	8b 81       	ldd	r24, Y+3	; 0x03
    3eb6:	9c 81       	ldd	r25, Y+4	; 0x04
    3eb8:	00 97       	sbiw	r24, 0x00	; 0
    3eba:	39 f4       	brne	.+14     	; 0x3eca <vTaskSuspend+0x2e>
    3ebc:	80 91 8d 06 	lds	r24, 0x068D
    3ec0:	90 91 8e 06 	lds	r25, 0x068E
    3ec4:	9e 83       	std	Y+6, r25	; 0x06
    3ec6:	8d 83       	std	Y+5, r24	; 0x05
    3ec8:	04 c0       	rjmp	.+8      	; 0x3ed2 <vTaskSuspend+0x36>
    3eca:	8b 81       	ldd	r24, Y+3	; 0x03
    3ecc:	9c 81       	ldd	r25, Y+4	; 0x04
    3ece:	9e 83       	std	Y+6, r25	; 0x06
    3ed0:	8d 83       	std	Y+5, r24	; 0x05
    3ed2:	8d 81       	ldd	r24, Y+5	; 0x05
    3ed4:	9e 81       	ldd	r25, Y+6	; 0x06
    3ed6:	9a 83       	std	Y+2, r25	; 0x02
    3ed8:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3eda:	89 81       	ldd	r24, Y+1	; 0x01
    3edc:	9a 81       	ldd	r25, Y+2	; 0x02
    3ede:	02 96       	adiw	r24, 0x02	; 2
    3ee0:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3ee4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ee6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ee8:	84 89       	ldd	r24, Z+20	; 0x14
    3eea:	95 89       	ldd	r25, Z+21	; 0x15
    3eec:	00 97       	sbiw	r24, 0x00	; 0
    3eee:	29 f0       	breq	.+10     	; 0x3efa <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3ef0:	89 81       	ldd	r24, Y+1	; 0x01
    3ef2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ef4:	0c 96       	adiw	r24, 0x0c	; 12
    3ef6:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    3efa:	89 81       	ldd	r24, Y+1	; 0x01
    3efc:	9a 81       	ldd	r25, Y+2	; 0x02
    3efe:	9c 01       	movw	r18, r24
    3f00:	2e 5f       	subi	r18, 0xFE	; 254
    3f02:	3f 4f       	sbci	r19, 0xFF	; 255
    3f04:	8a ee       	ldi	r24, 0xEA	; 234
    3f06:	96 e0       	ldi	r25, 0x06	; 6
    3f08:	b9 01       	movw	r22, r18
    3f0a:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    3f0e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f10:	fa 81       	ldd	r31, Y+2	; 0x02
    3f12:	81 a5       	ldd	r24, Z+41	; 0x29
    3f14:	81 30       	cpi	r24, 0x01	; 1
    3f16:	19 f4       	brne	.+6      	; 0x3f1e <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3f18:	e9 81       	ldd	r30, Y+1	; 0x01
    3f1a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f1c:	11 a6       	std	Z+41, r1	; 0x29
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    3f1e:	0f 90       	pop	r0
    3f20:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    3f22:	80 91 94 06 	lds	r24, 0x0694
    3f26:	88 23       	and	r24, r24
    3f28:	39 f0       	breq	.+14     	; 0x3f38 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    3f2a:	0f b6       	in	r0, 0x3f	; 63
    3f2c:	f8 94       	cli
    3f2e:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    3f30:	0e 94 9f 25 	call	0x4b3e	; 0x4b3e <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    3f34:	0f 90       	pop	r0
    3f36:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    3f38:	20 91 8d 06 	lds	r18, 0x068D
    3f3c:	30 91 8e 06 	lds	r19, 0x068E
    3f40:	89 81       	ldd	r24, Y+1	; 0x01
    3f42:	9a 81       	ldd	r25, Y+2	; 0x02
    3f44:	82 17       	cp	r24, r18
    3f46:	93 07       	cpc	r25, r19
    3f48:	a1 f4       	brne	.+40     	; 0x3f72 <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    3f4a:	80 91 94 06 	lds	r24, 0x0694
    3f4e:	88 23       	and	r24, r24
    3f50:	19 f0       	breq	.+6      	; 0x3f58 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    3f52:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
    3f56:	0d c0       	rjmp	.+26     	; 0x3f72 <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    3f58:	90 91 ea 06 	lds	r25, 0x06EA
    3f5c:	80 91 90 06 	lds	r24, 0x0690
    3f60:	98 17       	cp	r25, r24
    3f62:	29 f4       	brne	.+10     	; 0x3f6e <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3f64:	10 92 8e 06 	sts	0x068E, r1
    3f68:	10 92 8d 06 	sts	0x068D, r1
    3f6c:	02 c0       	rjmp	.+4      	; 0x3f72 <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    3f6e:	0e 94 da 22 	call	0x45b4	; 0x45b4 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3f72:	26 96       	adiw	r28, 0x06	; 6
    3f74:	0f b6       	in	r0, 0x3f	; 63
    3f76:	f8 94       	cli
    3f78:	de bf       	out	0x3e, r29	; 62
    3f7a:	0f be       	out	0x3f, r0	; 63
    3f7c:	cd bf       	out	0x3d, r28	; 61
    3f7e:	cf 91       	pop	r28
    3f80:	df 91       	pop	r29
    3f82:	08 95       	ret

00003f84 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    3f84:	df 93       	push	r29
    3f86:	cf 93       	push	r28
    3f88:	00 d0       	rcall	.+0      	; 0x3f8a <prvTaskIsTaskSuspended+0x6>
    3f8a:	00 d0       	rcall	.+0      	; 0x3f8c <prvTaskIsTaskSuspended+0x8>
    3f8c:	0f 92       	push	r0
    3f8e:	cd b7       	in	r28, 0x3d	; 61
    3f90:	de b7       	in	r29, 0x3e	; 62
    3f92:	9d 83       	std	Y+5, r25	; 0x05
    3f94:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    3f96:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    3f98:	8c 81       	ldd	r24, Y+4	; 0x04
    3f9a:	9d 81       	ldd	r25, Y+5	; 0x05
    3f9c:	9a 83       	std	Y+2, r25	; 0x02
    3f9e:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    3fa0:	e9 81       	ldd	r30, Y+1	; 0x01
    3fa2:	fa 81       	ldd	r31, Y+2	; 0x02
    3fa4:	82 85       	ldd	r24, Z+10	; 0x0a
    3fa6:	93 85       	ldd	r25, Z+11	; 0x0b
    3fa8:	26 e0       	ldi	r18, 0x06	; 6
    3faa:	8a 3e       	cpi	r24, 0xEA	; 234
    3fac:	92 07       	cpc	r25, r18
    3fae:	81 f4       	brne	.+32     	; 0x3fd0 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    3fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb4:	84 89       	ldd	r24, Z+20	; 0x14
    3fb6:	95 89       	ldd	r25, Z+21	; 0x15
    3fb8:	26 e0       	ldi	r18, 0x06	; 6
    3fba:	88 3d       	cpi	r24, 0xD8	; 216
    3fbc:	92 07       	cpc	r25, r18
    3fbe:	41 f0       	breq	.+16     	; 0x3fd0 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    3fc0:	e9 81       	ldd	r30, Y+1	; 0x01
    3fc2:	fa 81       	ldd	r31, Y+2	; 0x02
    3fc4:	84 89       	ldd	r24, Z+20	; 0x14
    3fc6:	95 89       	ldd	r25, Z+21	; 0x15
    3fc8:	00 97       	sbiw	r24, 0x00	; 0
    3fca:	11 f4       	brne	.+4      	; 0x3fd0 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    3fcc:	81 e0       	ldi	r24, 0x01	; 1
    3fce:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3fd0:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    3fd2:	0f 90       	pop	r0
    3fd4:	0f 90       	pop	r0
    3fd6:	0f 90       	pop	r0
    3fd8:	0f 90       	pop	r0
    3fda:	0f 90       	pop	r0
    3fdc:	cf 91       	pop	r28
    3fde:	df 91       	pop	r29
    3fe0:	08 95       	ret

00003fe2 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    3fe2:	df 93       	push	r29
    3fe4:	cf 93       	push	r28
    3fe6:	00 d0       	rcall	.+0      	; 0x3fe8 <vTaskResume+0x6>
    3fe8:	00 d0       	rcall	.+0      	; 0x3fea <vTaskResume+0x8>
    3fea:	cd b7       	in	r28, 0x3d	; 61
    3fec:	de b7       	in	r29, 0x3e	; 62
    3fee:	9c 83       	std	Y+4, r25	; 0x04
    3ff0:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    3ff2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ff4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ff6:	9a 83       	std	Y+2, r25	; 0x02
    3ff8:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    3ffa:	20 91 8d 06 	lds	r18, 0x068D
    3ffe:	30 91 8e 06 	lds	r19, 0x068E
    4002:	89 81       	ldd	r24, Y+1	; 0x01
    4004:	9a 81       	ldd	r25, Y+2	; 0x02
    4006:	82 17       	cp	r24, r18
    4008:	93 07       	cpc	r25, r19
    400a:	09 f4       	brne	.+2      	; 0x400e <vTaskResume+0x2c>
    400c:	47 c0       	rjmp	.+142    	; 0x409c <vTaskResume+0xba>
    400e:	89 81       	ldd	r24, Y+1	; 0x01
    4010:	9a 81       	ldd	r25, Y+2	; 0x02
    4012:	00 97       	sbiw	r24, 0x00	; 0
    4014:	09 f4       	brne	.+2      	; 0x4018 <vTaskResume+0x36>
    4016:	42 c0       	rjmp	.+132    	; 0x409c <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    4018:	0f b6       	in	r0, 0x3f	; 63
    401a:	f8 94       	cli
    401c:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    401e:	89 81       	ldd	r24, Y+1	; 0x01
    4020:	9a 81       	ldd	r25, Y+2	; 0x02
    4022:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <prvTaskIsTaskSuspended>
    4026:	88 23       	and	r24, r24
    4028:	b9 f1       	breq	.+110    	; 0x4098 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    402a:	89 81       	ldd	r24, Y+1	; 0x01
    402c:	9a 81       	ldd	r25, Y+2	; 0x02
    402e:	02 96       	adiw	r24, 0x02	; 2
    4030:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4034:	e9 81       	ldd	r30, Y+1	; 0x01
    4036:	fa 81       	ldd	r31, Y+2	; 0x02
    4038:	96 89       	ldd	r25, Z+22	; 0x16
    403a:	80 91 93 06 	lds	r24, 0x0693
    403e:	89 17       	cp	r24, r25
    4040:	28 f4       	brcc	.+10     	; 0x404c <vTaskResume+0x6a>
    4042:	e9 81       	ldd	r30, Y+1	; 0x01
    4044:	fa 81       	ldd	r31, Y+2	; 0x02
    4046:	86 89       	ldd	r24, Z+22	; 0x16
    4048:	80 93 93 06 	sts	0x0693, r24
    404c:	e9 81       	ldd	r30, Y+1	; 0x01
    404e:	fa 81       	ldd	r31, Y+2	; 0x02
    4050:	86 89       	ldd	r24, Z+22	; 0x16
    4052:	28 2f       	mov	r18, r24
    4054:	30 e0       	ldi	r19, 0x00	; 0
    4056:	c9 01       	movw	r24, r18
    4058:	88 0f       	add	r24, r24
    405a:	99 1f       	adc	r25, r25
    405c:	88 0f       	add	r24, r24
    405e:	99 1f       	adc	r25, r25
    4060:	88 0f       	add	r24, r24
    4062:	99 1f       	adc	r25, r25
    4064:	82 0f       	add	r24, r18
    4066:	93 1f       	adc	r25, r19
    4068:	ac 01       	movw	r20, r24
    406a:	42 56       	subi	r20, 0x62	; 98
    406c:	59 4f       	sbci	r21, 0xF9	; 249
    406e:	89 81       	ldd	r24, Y+1	; 0x01
    4070:	9a 81       	ldd	r25, Y+2	; 0x02
    4072:	9c 01       	movw	r18, r24
    4074:	2e 5f       	subi	r18, 0xFE	; 254
    4076:	3f 4f       	sbci	r19, 0xFF	; 255
    4078:	ca 01       	movw	r24, r20
    407a:	b9 01       	movw	r22, r18
    407c:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4080:	e9 81       	ldd	r30, Y+1	; 0x01
    4082:	fa 81       	ldd	r31, Y+2	; 0x02
    4084:	96 89       	ldd	r25, Z+22	; 0x16
    4086:	e0 91 8d 06 	lds	r30, 0x068D
    408a:	f0 91 8e 06 	lds	r31, 0x068E
    408e:	86 89       	ldd	r24, Z+22	; 0x16
    4090:	98 17       	cp	r25, r24
    4092:	10 f0       	brcs	.+4      	; 0x4098 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    4094:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    4098:	0f 90       	pop	r0
    409a:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    409c:	0f 90       	pop	r0
    409e:	0f 90       	pop	r0
    40a0:	0f 90       	pop	r0
    40a2:	0f 90       	pop	r0
    40a4:	cf 91       	pop	r28
    40a6:	df 91       	pop	r29
    40a8:	08 95       	ret

000040aa <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    40aa:	df 93       	push	r29
    40ac:	cf 93       	push	r28
    40ae:	00 d0       	rcall	.+0      	; 0x40b0 <xTaskResumeFromISR+0x6>
    40b0:	00 d0       	rcall	.+0      	; 0x40b2 <xTaskResumeFromISR+0x8>
    40b2:	00 d0       	rcall	.+0      	; 0x40b4 <xTaskResumeFromISR+0xa>
    40b4:	cd b7       	in	r28, 0x3d	; 61
    40b6:	de b7       	in	r29, 0x3e	; 62
    40b8:	9e 83       	std	Y+6, r25	; 0x06
    40ba:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    40bc:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    40be:	8d 81       	ldd	r24, Y+5	; 0x05
    40c0:	9e 81       	ldd	r25, Y+6	; 0x06
    40c2:	9b 83       	std	Y+3, r25	; 0x03
    40c4:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    40c6:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    40c8:	8a 81       	ldd	r24, Y+2	; 0x02
    40ca:	9b 81       	ldd	r25, Y+3	; 0x03
    40cc:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <prvTaskIsTaskSuspended>
    40d0:	88 23       	and	r24, r24
    40d2:	09 f4       	brne	.+2      	; 0x40d6 <xTaskResumeFromISR+0x2c>
    40d4:	46 c0       	rjmp	.+140    	; 0x4162 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    40d6:	80 91 9d 06 	lds	r24, 0x069D
    40da:	88 23       	and	r24, r24
    40dc:	c1 f5       	brne	.+112    	; 0x414e <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    40de:	ea 81       	ldd	r30, Y+2	; 0x02
    40e0:	fb 81       	ldd	r31, Y+3	; 0x03
    40e2:	96 89       	ldd	r25, Z+22	; 0x16
    40e4:	e0 91 8d 06 	lds	r30, 0x068D
    40e8:	f0 91 8e 06 	lds	r31, 0x068E
    40ec:	86 89       	ldd	r24, Z+22	; 0x16
    40ee:	98 17       	cp	r25, r24
    40f0:	10 f0       	brcs	.+4      	; 0x40f6 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    40f2:	81 e0       	ldi	r24, 0x01	; 1
    40f4:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    40f6:	8a 81       	ldd	r24, Y+2	; 0x02
    40f8:	9b 81       	ldd	r25, Y+3	; 0x03
    40fa:	02 96       	adiw	r24, 0x02	; 2
    40fc:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4100:	ea 81       	ldd	r30, Y+2	; 0x02
    4102:	fb 81       	ldd	r31, Y+3	; 0x03
    4104:	96 89       	ldd	r25, Z+22	; 0x16
    4106:	80 91 93 06 	lds	r24, 0x0693
    410a:	89 17       	cp	r24, r25
    410c:	28 f4       	brcc	.+10     	; 0x4118 <xTaskResumeFromISR+0x6e>
    410e:	ea 81       	ldd	r30, Y+2	; 0x02
    4110:	fb 81       	ldd	r31, Y+3	; 0x03
    4112:	86 89       	ldd	r24, Z+22	; 0x16
    4114:	80 93 93 06 	sts	0x0693, r24
    4118:	ea 81       	ldd	r30, Y+2	; 0x02
    411a:	fb 81       	ldd	r31, Y+3	; 0x03
    411c:	86 89       	ldd	r24, Z+22	; 0x16
    411e:	28 2f       	mov	r18, r24
    4120:	30 e0       	ldi	r19, 0x00	; 0
    4122:	c9 01       	movw	r24, r18
    4124:	88 0f       	add	r24, r24
    4126:	99 1f       	adc	r25, r25
    4128:	88 0f       	add	r24, r24
    412a:	99 1f       	adc	r25, r25
    412c:	88 0f       	add	r24, r24
    412e:	99 1f       	adc	r25, r25
    4130:	82 0f       	add	r24, r18
    4132:	93 1f       	adc	r25, r19
    4134:	ac 01       	movw	r20, r24
    4136:	42 56       	subi	r20, 0x62	; 98
    4138:	59 4f       	sbci	r21, 0xF9	; 249
    413a:	8a 81       	ldd	r24, Y+2	; 0x02
    413c:	9b 81       	ldd	r25, Y+3	; 0x03
    413e:	9c 01       	movw	r18, r24
    4140:	2e 5f       	subi	r18, 0xFE	; 254
    4142:	3f 4f       	sbci	r19, 0xFF	; 255
    4144:	ca 01       	movw	r24, r20
    4146:	b9 01       	movw	r22, r18
    4148:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>
    414c:	0a c0       	rjmp	.+20     	; 0x4162 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    414e:	8a 81       	ldd	r24, Y+2	; 0x02
    4150:	9b 81       	ldd	r25, Y+3	; 0x03
    4152:	9c 01       	movw	r18, r24
    4154:	24 5f       	subi	r18, 0xF4	; 244
    4156:	3f 4f       	sbci	r19, 0xFF	; 255
    4158:	88 ed       	ldi	r24, 0xD8	; 216
    415a:	96 e0       	ldi	r25, 0x06	; 6
    415c:	b9 01       	movw	r22, r18
    415e:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    4162:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    4164:	26 96       	adiw	r28, 0x06	; 6
    4166:	0f b6       	in	r0, 0x3f	; 63
    4168:	f8 94       	cli
    416a:	de bf       	out	0x3e, r29	; 62
    416c:	0f be       	out	0x3f, r0	; 63
    416e:	cd bf       	out	0x3d, r28	; 61
    4170:	cf 91       	pop	r28
    4172:	df 91       	pop	r29
    4174:	08 95       	ret

00004176 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4176:	ef 92       	push	r14
    4178:	ff 92       	push	r15
    417a:	0f 93       	push	r16
    417c:	df 93       	push	r29
    417e:	cf 93       	push	r28
    4180:	0f 92       	push	r0
    4182:	cd b7       	in	r28, 0x3d	; 61
    4184:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    4186:	8f e0       	ldi	r24, 0x0F	; 15
    4188:	95 e2       	ldi	r25, 0x25	; 37
    418a:	21 ea       	ldi	r18, 0xA1	; 161
    418c:	30 e0       	ldi	r19, 0x00	; 0
    418e:	eb e9       	ldi	r30, 0x9B	; 155
    4190:	f6 e0       	ldi	r31, 0x06	; 6
    4192:	b9 01       	movw	r22, r18
    4194:	45 e5       	ldi	r20, 0x55	; 85
    4196:	50 e0       	ldi	r21, 0x00	; 0
    4198:	20 e0       	ldi	r18, 0x00	; 0
    419a:	30 e0       	ldi	r19, 0x00	; 0
    419c:	00 e0       	ldi	r16, 0x00	; 0
    419e:	7f 01       	movw	r14, r30
    41a0:	0e 94 0e 1d 	call	0x3a1c	; 0x3a1c <xTaskCreate>
    41a4:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    41a6:	89 81       	ldd	r24, Y+1	; 0x01
    41a8:	81 30       	cpi	r24, 0x01	; 1
    41aa:	81 f4       	brne	.+32     	; 0x41cc <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    41ac:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    41ae:	8f ef       	ldi	r24, 0xFF	; 255
    41b0:	9f ef       	ldi	r25, 0xFF	; 255
    41b2:	90 93 9a 06 	sts	0x069A, r25
    41b6:	80 93 99 06 	sts	0x0699, r24
		xSchedulerRunning = pdTRUE;
    41ba:	81 e0       	ldi	r24, 0x01	; 1
    41bc:	80 93 94 06 	sts	0x0694, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    41c0:	10 92 92 06 	sts	0x0692, r1
    41c4:	10 92 91 06 	sts	0x0691, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    41c8:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    41cc:	0f 90       	pop	r0
    41ce:	cf 91       	pop	r28
    41d0:	df 91       	pop	r29
    41d2:	0f 91       	pop	r16
    41d4:	ff 90       	pop	r15
    41d6:	ef 90       	pop	r14
    41d8:	08 95       	ret

000041da <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    41da:	df 93       	push	r29
    41dc:	cf 93       	push	r28
    41de:	cd b7       	in	r28, 0x3d	; 61
    41e0:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    41e2:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    41e4:	10 92 94 06 	sts	0x0694, r1
	vPortEndScheduler();
    41e8:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <vPortEndScheduler>
}
    41ec:	cf 91       	pop	r28
    41ee:	df 91       	pop	r29
    41f0:	08 95       	ret

000041f2 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    41f2:	df 93       	push	r29
    41f4:	cf 93       	push	r28
    41f6:	cd b7       	in	r28, 0x3d	; 61
    41f8:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    41fa:	80 91 9d 06 	lds	r24, 0x069D
    41fe:	8f 5f       	subi	r24, 0xFF	; 255
    4200:	80 93 9d 06 	sts	0x069D, r24
}
    4204:	cf 91       	pop	r28
    4206:	df 91       	pop	r29
    4208:	08 95       	ret

0000420a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    420a:	df 93       	push	r29
    420c:	cf 93       	push	r28
    420e:	00 d0       	rcall	.+0      	; 0x4210 <xTaskResumeAll+0x6>
    4210:	00 d0       	rcall	.+0      	; 0x4212 <xTaskResumeAll+0x8>
    4212:	cd b7       	in	r28, 0x3d	; 61
    4214:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    4216:	1c 82       	std	Y+4, r1	; 0x04
    4218:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    421a:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    421c:	0f b6       	in	r0, 0x3f	; 63
    421e:	f8 94       	cli
    4220:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4222:	80 91 9d 06 	lds	r24, 0x069D
    4226:	81 50       	subi	r24, 0x01	; 1
    4228:	80 93 9d 06 	sts	0x069D, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    422c:	80 91 9d 06 	lds	r24, 0x069D
    4230:	88 23       	and	r24, r24
    4232:	09 f0       	breq	.+2      	; 0x4236 <xTaskResumeAll+0x2c>
    4234:	73 c0       	rjmp	.+230    	; 0x431c <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    4236:	80 91 90 06 	lds	r24, 0x0690
    423a:	88 23       	and	r24, r24
    423c:	09 f4       	brne	.+2      	; 0x4240 <xTaskResumeAll+0x36>
    423e:	6e c0       	rjmp	.+220    	; 0x431c <xTaskResumeAll+0x112>
    4240:	45 c0       	rjmp	.+138    	; 0x42cc <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4242:	e0 91 dd 06 	lds	r30, 0x06DD
    4246:	f0 91 de 06 	lds	r31, 0x06DE
    424a:	86 81       	ldd	r24, Z+6	; 0x06
    424c:	97 81       	ldd	r25, Z+7	; 0x07
    424e:	9c 83       	std	Y+4, r25	; 0x04
    4250:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4252:	8b 81       	ldd	r24, Y+3	; 0x03
    4254:	9c 81       	ldd	r25, Y+4	; 0x04
    4256:	0c 96       	adiw	r24, 0x0c	; 12
    4258:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    425c:	8b 81       	ldd	r24, Y+3	; 0x03
    425e:	9c 81       	ldd	r25, Y+4	; 0x04
    4260:	02 96       	adiw	r24, 0x02	; 2
    4262:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4266:	eb 81       	ldd	r30, Y+3	; 0x03
    4268:	fc 81       	ldd	r31, Y+4	; 0x04
    426a:	96 89       	ldd	r25, Z+22	; 0x16
    426c:	80 91 93 06 	lds	r24, 0x0693
    4270:	89 17       	cp	r24, r25
    4272:	28 f4       	brcc	.+10     	; 0x427e <xTaskResumeAll+0x74>
    4274:	eb 81       	ldd	r30, Y+3	; 0x03
    4276:	fc 81       	ldd	r31, Y+4	; 0x04
    4278:	86 89       	ldd	r24, Z+22	; 0x16
    427a:	80 93 93 06 	sts	0x0693, r24
    427e:	eb 81       	ldd	r30, Y+3	; 0x03
    4280:	fc 81       	ldd	r31, Y+4	; 0x04
    4282:	86 89       	ldd	r24, Z+22	; 0x16
    4284:	28 2f       	mov	r18, r24
    4286:	30 e0       	ldi	r19, 0x00	; 0
    4288:	c9 01       	movw	r24, r18
    428a:	88 0f       	add	r24, r24
    428c:	99 1f       	adc	r25, r25
    428e:	88 0f       	add	r24, r24
    4290:	99 1f       	adc	r25, r25
    4292:	88 0f       	add	r24, r24
    4294:	99 1f       	adc	r25, r25
    4296:	82 0f       	add	r24, r18
    4298:	93 1f       	adc	r25, r19
    429a:	ac 01       	movw	r20, r24
    429c:	42 56       	subi	r20, 0x62	; 98
    429e:	59 4f       	sbci	r21, 0xF9	; 249
    42a0:	8b 81       	ldd	r24, Y+3	; 0x03
    42a2:	9c 81       	ldd	r25, Y+4	; 0x04
    42a4:	9c 01       	movw	r18, r24
    42a6:	2e 5f       	subi	r18, 0xFE	; 254
    42a8:	3f 4f       	sbci	r19, 0xFF	; 255
    42aa:	ca 01       	movw	r24, r20
    42ac:	b9 01       	movw	r22, r18
    42ae:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    42b2:	eb 81       	ldd	r30, Y+3	; 0x03
    42b4:	fc 81       	ldd	r31, Y+4	; 0x04
    42b6:	96 89       	ldd	r25, Z+22	; 0x16
    42b8:	e0 91 8d 06 	lds	r30, 0x068D
    42bc:	f0 91 8e 06 	lds	r31, 0x068E
    42c0:	86 89       	ldd	r24, Z+22	; 0x16
    42c2:	98 17       	cp	r25, r24
    42c4:	18 f0       	brcs	.+6      	; 0x42cc <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    42c6:	81 e0       	ldi	r24, 0x01	; 1
    42c8:	80 93 96 06 	sts	0x0696, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    42cc:	80 91 d8 06 	lds	r24, 0x06D8
    42d0:	88 23       	and	r24, r24
    42d2:	09 f0       	breq	.+2      	; 0x42d6 <xTaskResumeAll+0xcc>
    42d4:	b6 cf       	rjmp	.-148    	; 0x4242 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    42d6:	8b 81       	ldd	r24, Y+3	; 0x03
    42d8:	9c 81       	ldd	r25, Y+4	; 0x04
    42da:	00 97       	sbiw	r24, 0x00	; 0
    42dc:	11 f0       	breq	.+4      	; 0x42e2 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    42de:	0e 94 9f 25 	call	0x4b3e	; 0x4b3e <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    42e2:	80 91 95 06 	lds	r24, 0x0695
    42e6:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    42e8:	89 81       	ldd	r24, Y+1	; 0x01
    42ea:	88 23       	and	r24, r24
    42ec:	79 f0       	breq	.+30     	; 0x430c <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    42ee:	0e 94 f5 21 	call	0x43ea	; 0x43ea <xTaskIncrementTick>
    42f2:	88 23       	and	r24, r24
    42f4:	19 f0       	breq	.+6      	; 0x42fc <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    42f6:	81 e0       	ldi	r24, 0x01	; 1
    42f8:	80 93 96 06 	sts	0x0696, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    42fc:	89 81       	ldd	r24, Y+1	; 0x01
    42fe:	81 50       	subi	r24, 0x01	; 1
    4300:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    4302:	89 81       	ldd	r24, Y+1	; 0x01
    4304:	88 23       	and	r24, r24
    4306:	99 f7       	brne	.-26     	; 0x42ee <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    4308:	10 92 95 06 	sts	0x0695, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    430c:	80 91 96 06 	lds	r24, 0x0696
    4310:	88 23       	and	r24, r24
    4312:	21 f0       	breq	.+8      	; 0x431c <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    4314:	81 e0       	ldi	r24, 0x01	; 1
    4316:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    4318:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    431c:	0f 90       	pop	r0
    431e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4320:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4322:	0f 90       	pop	r0
    4324:	0f 90       	pop	r0
    4326:	0f 90       	pop	r0
    4328:	0f 90       	pop	r0
    432a:	cf 91       	pop	r28
    432c:	df 91       	pop	r29
    432e:	08 95       	ret

00004330 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    4330:	df 93       	push	r29
    4332:	cf 93       	push	r28
    4334:	00 d0       	rcall	.+0      	; 0x4336 <xTaskGetTickCount+0x6>
    4336:	cd b7       	in	r28, 0x3d	; 61
    4338:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    433a:	0f b6       	in	r0, 0x3f	; 63
    433c:	f8 94       	cli
    433e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4340:	80 91 91 06 	lds	r24, 0x0691
    4344:	90 91 92 06 	lds	r25, 0x0692
    4348:	9a 83       	std	Y+2, r25	; 0x02
    434a:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    434c:	0f 90       	pop	r0
    434e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4350:	89 81       	ldd	r24, Y+1	; 0x01
    4352:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4354:	0f 90       	pop	r0
    4356:	0f 90       	pop	r0
    4358:	cf 91       	pop	r28
    435a:	df 91       	pop	r29
    435c:	08 95       	ret

0000435e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    435e:	df 93       	push	r29
    4360:	cf 93       	push	r28
    4362:	00 d0       	rcall	.+0      	; 0x4364 <xTaskGetTickCountFromISR+0x6>
    4364:	0f 92       	push	r0
    4366:	cd b7       	in	r28, 0x3d	; 61
    4368:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    436a:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    436c:	80 91 91 06 	lds	r24, 0x0691
    4370:	90 91 92 06 	lds	r25, 0x0692
    4374:	9b 83       	std	Y+3, r25	; 0x03
    4376:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4378:	8a 81       	ldd	r24, Y+2	; 0x02
    437a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    437c:	0f 90       	pop	r0
    437e:	0f 90       	pop	r0
    4380:	0f 90       	pop	r0
    4382:	cf 91       	pop	r28
    4384:	df 91       	pop	r29
    4386:	08 95       	ret

00004388 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    4388:	df 93       	push	r29
    438a:	cf 93       	push	r28
    438c:	cd b7       	in	r28, 0x3d	; 61
    438e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    4390:	80 91 90 06 	lds	r24, 0x0690
}
    4394:	cf 91       	pop	r28
    4396:	df 91       	pop	r29
    4398:	08 95       	ret

0000439a <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    439a:	df 93       	push	r29
    439c:	cf 93       	push	r28
    439e:	00 d0       	rcall	.+0      	; 0x43a0 <pcTaskGetName+0x6>
    43a0:	00 d0       	rcall	.+0      	; 0x43a2 <pcTaskGetName+0x8>
    43a2:	00 d0       	rcall	.+0      	; 0x43a4 <pcTaskGetName+0xa>
    43a4:	cd b7       	in	r28, 0x3d	; 61
    43a6:	de b7       	in	r29, 0x3e	; 62
    43a8:	9c 83       	std	Y+4, r25	; 0x04
    43aa:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    43ac:	8b 81       	ldd	r24, Y+3	; 0x03
    43ae:	9c 81       	ldd	r25, Y+4	; 0x04
    43b0:	00 97       	sbiw	r24, 0x00	; 0
    43b2:	39 f4       	brne	.+14     	; 0x43c2 <pcTaskGetName+0x28>
    43b4:	80 91 8d 06 	lds	r24, 0x068D
    43b8:	90 91 8e 06 	lds	r25, 0x068E
    43bc:	9e 83       	std	Y+6, r25	; 0x06
    43be:	8d 83       	std	Y+5, r24	; 0x05
    43c0:	04 c0       	rjmp	.+8      	; 0x43ca <pcTaskGetName+0x30>
    43c2:	8b 81       	ldd	r24, Y+3	; 0x03
    43c4:	9c 81       	ldd	r25, Y+4	; 0x04
    43c6:	9e 83       	std	Y+6, r25	; 0x06
    43c8:	8d 83       	std	Y+5, r24	; 0x05
    43ca:	8d 81       	ldd	r24, Y+5	; 0x05
    43cc:	9e 81       	ldd	r25, Y+6	; 0x06
    43ce:	9a 83       	std	Y+2, r25	; 0x02
    43d0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    43d2:	89 81       	ldd	r24, Y+1	; 0x01
    43d4:	9a 81       	ldd	r25, Y+2	; 0x02
    43d6:	49 96       	adiw	r24, 0x19	; 25
}
    43d8:	26 96       	adiw	r28, 0x06	; 6
    43da:	0f b6       	in	r0, 0x3f	; 63
    43dc:	f8 94       	cli
    43de:	de bf       	out	0x3e, r29	; 62
    43e0:	0f be       	out	0x3f, r0	; 63
    43e2:	cd bf       	out	0x3d, r28	; 61
    43e4:	cf 91       	pop	r28
    43e6:	df 91       	pop	r29
    43e8:	08 95       	ret

000043ea <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    43ea:	df 93       	push	r29
    43ec:	cf 93       	push	r28
    43ee:	cd b7       	in	r28, 0x3d	; 61
    43f0:	de b7       	in	r29, 0x3e	; 62
    43f2:	29 97       	sbiw	r28, 0x09	; 9
    43f4:	0f b6       	in	r0, 0x3f	; 63
    43f6:	f8 94       	cli
    43f8:	de bf       	out	0x3e, r29	; 62
    43fa:	0f be       	out	0x3f, r0	; 63
    43fc:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    43fe:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4400:	80 91 9d 06 	lds	r24, 0x069D
    4404:	88 23       	and	r24, r24
    4406:	09 f0       	breq	.+2      	; 0x440a <xTaskIncrementTick+0x20>
    4408:	c0 c0       	rjmp	.+384    	; 0x458a <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    440a:	80 91 91 06 	lds	r24, 0x0691
    440e:	90 91 92 06 	lds	r25, 0x0692
    4412:	01 96       	adiw	r24, 0x01	; 1
    4414:	9c 83       	std	Y+4, r25	; 0x04
    4416:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    4418:	8b 81       	ldd	r24, Y+3	; 0x03
    441a:	9c 81       	ldd	r25, Y+4	; 0x04
    441c:	90 93 92 06 	sts	0x0692, r25
    4420:	80 93 91 06 	sts	0x0691, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4424:	8b 81       	ldd	r24, Y+3	; 0x03
    4426:	9c 81       	ldd	r25, Y+4	; 0x04
    4428:	00 97       	sbiw	r24, 0x00	; 0
    442a:	d9 f4       	brne	.+54     	; 0x4462 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    442c:	80 91 d4 06 	lds	r24, 0x06D4
    4430:	90 91 d5 06 	lds	r25, 0x06D5
    4434:	9a 83       	std	Y+2, r25	; 0x02
    4436:	89 83       	std	Y+1, r24	; 0x01
    4438:	80 91 d6 06 	lds	r24, 0x06D6
    443c:	90 91 d7 06 	lds	r25, 0x06D7
    4440:	90 93 d5 06 	sts	0x06D5, r25
    4444:	80 93 d4 06 	sts	0x06D4, r24
    4448:	89 81       	ldd	r24, Y+1	; 0x01
    444a:	9a 81       	ldd	r25, Y+2	; 0x02
    444c:	90 93 d7 06 	sts	0x06D7, r25
    4450:	80 93 d6 06 	sts	0x06D6, r24
    4454:	80 91 97 06 	lds	r24, 0x0697
    4458:	8f 5f       	subi	r24, 0xFF	; 255
    445a:	80 93 97 06 	sts	0x0697, r24
    445e:	0e 94 9f 25 	call	0x4b3e	; 0x4b3e <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    4462:	20 91 99 06 	lds	r18, 0x0699
    4466:	30 91 9a 06 	lds	r19, 0x069A
    446a:	8b 81       	ldd	r24, Y+3	; 0x03
    446c:	9c 81       	ldd	r25, Y+4	; 0x04
    446e:	82 17       	cp	r24, r18
    4470:	93 07       	cpc	r25, r19
    4472:	08 f4       	brcc	.+2      	; 0x4476 <xTaskIncrementTick+0x8c>
    4474:	71 c0       	rjmp	.+226    	; 0x4558 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4476:	e0 91 d4 06 	lds	r30, 0x06D4
    447a:	f0 91 d5 06 	lds	r31, 0x06D5
    447e:	80 81       	ld	r24, Z
    4480:	88 23       	and	r24, r24
    4482:	39 f4       	brne	.+14     	; 0x4492 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4484:	8f ef       	ldi	r24, 0xFF	; 255
    4486:	9f ef       	ldi	r25, 0xFF	; 255
    4488:	90 93 9a 06 	sts	0x069A, r25
    448c:	80 93 99 06 	sts	0x0699, r24
    4490:	63 c0       	rjmp	.+198    	; 0x4558 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4492:	e0 91 d4 06 	lds	r30, 0x06D4
    4496:	f0 91 d5 06 	lds	r31, 0x06D5
    449a:	05 80       	ldd	r0, Z+5	; 0x05
    449c:	f6 81       	ldd	r31, Z+6	; 0x06
    449e:	e0 2d       	mov	r30, r0
    44a0:	86 81       	ldd	r24, Z+6	; 0x06
    44a2:	97 81       	ldd	r25, Z+7	; 0x07
    44a4:	99 87       	std	Y+9, r25	; 0x09
    44a6:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    44a8:	e8 85       	ldd	r30, Y+8	; 0x08
    44aa:	f9 85       	ldd	r31, Y+9	; 0x09
    44ac:	82 81       	ldd	r24, Z+2	; 0x02
    44ae:	93 81       	ldd	r25, Z+3	; 0x03
    44b0:	9f 83       	std	Y+7, r25	; 0x07
    44b2:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    44b4:	2b 81       	ldd	r18, Y+3	; 0x03
    44b6:	3c 81       	ldd	r19, Y+4	; 0x04
    44b8:	8e 81       	ldd	r24, Y+6	; 0x06
    44ba:	9f 81       	ldd	r25, Y+7	; 0x07
    44bc:	28 17       	cp	r18, r24
    44be:	39 07       	cpc	r19, r25
    44c0:	38 f4       	brcc	.+14     	; 0x44d0 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    44c2:	8e 81       	ldd	r24, Y+6	; 0x06
    44c4:	9f 81       	ldd	r25, Y+7	; 0x07
    44c6:	90 93 9a 06 	sts	0x069A, r25
    44ca:	80 93 99 06 	sts	0x0699, r24
    44ce:	44 c0       	rjmp	.+136    	; 0x4558 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    44d0:	88 85       	ldd	r24, Y+8	; 0x08
    44d2:	99 85       	ldd	r25, Y+9	; 0x09
    44d4:	02 96       	adiw	r24, 0x02	; 2
    44d6:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    44da:	e8 85       	ldd	r30, Y+8	; 0x08
    44dc:	f9 85       	ldd	r31, Y+9	; 0x09
    44de:	84 89       	ldd	r24, Z+20	; 0x14
    44e0:	95 89       	ldd	r25, Z+21	; 0x15
    44e2:	00 97       	sbiw	r24, 0x00	; 0
    44e4:	29 f0       	breq	.+10     	; 0x44f0 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    44e6:	88 85       	ldd	r24, Y+8	; 0x08
    44e8:	99 85       	ldd	r25, Y+9	; 0x09
    44ea:	0c 96       	adiw	r24, 0x0c	; 12
    44ec:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    44f0:	e8 85       	ldd	r30, Y+8	; 0x08
    44f2:	f9 85       	ldd	r31, Y+9	; 0x09
    44f4:	96 89       	ldd	r25, Z+22	; 0x16
    44f6:	80 91 93 06 	lds	r24, 0x0693
    44fa:	89 17       	cp	r24, r25
    44fc:	28 f4       	brcc	.+10     	; 0x4508 <xTaskIncrementTick+0x11e>
    44fe:	e8 85       	ldd	r30, Y+8	; 0x08
    4500:	f9 85       	ldd	r31, Y+9	; 0x09
    4502:	86 89       	ldd	r24, Z+22	; 0x16
    4504:	80 93 93 06 	sts	0x0693, r24
    4508:	e8 85       	ldd	r30, Y+8	; 0x08
    450a:	f9 85       	ldd	r31, Y+9	; 0x09
    450c:	86 89       	ldd	r24, Z+22	; 0x16
    450e:	28 2f       	mov	r18, r24
    4510:	30 e0       	ldi	r19, 0x00	; 0
    4512:	c9 01       	movw	r24, r18
    4514:	88 0f       	add	r24, r24
    4516:	99 1f       	adc	r25, r25
    4518:	88 0f       	add	r24, r24
    451a:	99 1f       	adc	r25, r25
    451c:	88 0f       	add	r24, r24
    451e:	99 1f       	adc	r25, r25
    4520:	82 0f       	add	r24, r18
    4522:	93 1f       	adc	r25, r19
    4524:	ac 01       	movw	r20, r24
    4526:	42 56       	subi	r20, 0x62	; 98
    4528:	59 4f       	sbci	r21, 0xF9	; 249
    452a:	88 85       	ldd	r24, Y+8	; 0x08
    452c:	99 85       	ldd	r25, Y+9	; 0x09
    452e:	9c 01       	movw	r18, r24
    4530:	2e 5f       	subi	r18, 0xFE	; 254
    4532:	3f 4f       	sbci	r19, 0xFF	; 255
    4534:	ca 01       	movw	r24, r20
    4536:	b9 01       	movw	r22, r18
    4538:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    453c:	e8 85       	ldd	r30, Y+8	; 0x08
    453e:	f9 85       	ldd	r31, Y+9	; 0x09
    4540:	96 89       	ldd	r25, Z+22	; 0x16
    4542:	e0 91 8d 06 	lds	r30, 0x068D
    4546:	f0 91 8e 06 	lds	r31, 0x068E
    454a:	86 89       	ldd	r24, Z+22	; 0x16
    454c:	98 17       	cp	r25, r24
    454e:	08 f4       	brcc	.+2      	; 0x4552 <xTaskIncrementTick+0x168>
    4550:	92 cf       	rjmp	.-220    	; 0x4476 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    4552:	81 e0       	ldi	r24, 0x01	; 1
    4554:	8d 83       	std	Y+5, r24	; 0x05
    4556:	8f cf       	rjmp	.-226    	; 0x4476 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    4558:	e0 91 8d 06 	lds	r30, 0x068D
    455c:	f0 91 8e 06 	lds	r31, 0x068E
    4560:	86 89       	ldd	r24, Z+22	; 0x16
    4562:	28 2f       	mov	r18, r24
    4564:	30 e0       	ldi	r19, 0x00	; 0
    4566:	c9 01       	movw	r24, r18
    4568:	88 0f       	add	r24, r24
    456a:	99 1f       	adc	r25, r25
    456c:	88 0f       	add	r24, r24
    456e:	99 1f       	adc	r25, r25
    4570:	88 0f       	add	r24, r24
    4572:	99 1f       	adc	r25, r25
    4574:	82 0f       	add	r24, r18
    4576:	93 1f       	adc	r25, r19
    4578:	fc 01       	movw	r30, r24
    457a:	e2 56       	subi	r30, 0x62	; 98
    457c:	f9 4f       	sbci	r31, 0xF9	; 249
    457e:	80 81       	ld	r24, Z
    4580:	82 30       	cpi	r24, 0x02	; 2
    4582:	40 f0       	brcs	.+16     	; 0x4594 <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    4584:	81 e0       	ldi	r24, 0x01	; 1
    4586:	8d 83       	std	Y+5, r24	; 0x05
    4588:	05 c0       	rjmp	.+10     	; 0x4594 <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    458a:	80 91 95 06 	lds	r24, 0x0695
    458e:	8f 5f       	subi	r24, 0xFF	; 255
    4590:	80 93 95 06 	sts	0x0695, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    4594:	80 91 96 06 	lds	r24, 0x0696
    4598:	88 23       	and	r24, r24
    459a:	11 f0       	breq	.+4      	; 0x45a0 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    459c:	81 e0       	ldi	r24, 0x01	; 1
    459e:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    45a0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    45a2:	29 96       	adiw	r28, 0x09	; 9
    45a4:	0f b6       	in	r0, 0x3f	; 63
    45a6:	f8 94       	cli
    45a8:	de bf       	out	0x3e, r29	; 62
    45aa:	0f be       	out	0x3f, r0	; 63
    45ac:	cd bf       	out	0x3d, r28	; 61
    45ae:	cf 91       	pop	r28
    45b0:	df 91       	pop	r29
    45b2:	08 95       	ret

000045b4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    45b4:	df 93       	push	r29
    45b6:	cf 93       	push	r28
    45b8:	00 d0       	rcall	.+0      	; 0x45ba <vTaskSwitchContext+0x6>
    45ba:	0f 92       	push	r0
    45bc:	cd b7       	in	r28, 0x3d	; 61
    45be:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    45c0:	80 91 9d 06 	lds	r24, 0x069D
    45c4:	88 23       	and	r24, r24
    45c6:	21 f0       	breq	.+8      	; 0x45d0 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    45c8:	81 e0       	ldi	r24, 0x01	; 1
    45ca:	80 93 96 06 	sts	0x0696, r24
    45ce:	59 c0       	rjmp	.+178    	; 0x4682 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    45d0:	10 92 96 06 	sts	0x0696, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    45d4:	80 91 93 06 	lds	r24, 0x0693
    45d8:	8b 83       	std	Y+3, r24	; 0x03
    45da:	03 c0       	rjmp	.+6      	; 0x45e2 <vTaskSwitchContext+0x2e>
    45dc:	8b 81       	ldd	r24, Y+3	; 0x03
    45de:	81 50       	subi	r24, 0x01	; 1
    45e0:	8b 83       	std	Y+3, r24	; 0x03
    45e2:	8b 81       	ldd	r24, Y+3	; 0x03
    45e4:	28 2f       	mov	r18, r24
    45e6:	30 e0       	ldi	r19, 0x00	; 0
    45e8:	c9 01       	movw	r24, r18
    45ea:	88 0f       	add	r24, r24
    45ec:	99 1f       	adc	r25, r25
    45ee:	88 0f       	add	r24, r24
    45f0:	99 1f       	adc	r25, r25
    45f2:	88 0f       	add	r24, r24
    45f4:	99 1f       	adc	r25, r25
    45f6:	82 0f       	add	r24, r18
    45f8:	93 1f       	adc	r25, r19
    45fa:	fc 01       	movw	r30, r24
    45fc:	e2 56       	subi	r30, 0x62	; 98
    45fe:	f9 4f       	sbci	r31, 0xF9	; 249
    4600:	80 81       	ld	r24, Z
    4602:	88 23       	and	r24, r24
    4604:	59 f3       	breq	.-42     	; 0x45dc <vTaskSwitchContext+0x28>
    4606:	8b 81       	ldd	r24, Y+3	; 0x03
    4608:	28 2f       	mov	r18, r24
    460a:	30 e0       	ldi	r19, 0x00	; 0
    460c:	c9 01       	movw	r24, r18
    460e:	88 0f       	add	r24, r24
    4610:	99 1f       	adc	r25, r25
    4612:	88 0f       	add	r24, r24
    4614:	99 1f       	adc	r25, r25
    4616:	88 0f       	add	r24, r24
    4618:	99 1f       	adc	r25, r25
    461a:	82 0f       	add	r24, r18
    461c:	93 1f       	adc	r25, r19
    461e:	82 56       	subi	r24, 0x62	; 98
    4620:	99 4f       	sbci	r25, 0xF9	; 249
    4622:	9a 83       	std	Y+2, r25	; 0x02
    4624:	89 83       	std	Y+1, r24	; 0x01
    4626:	e9 81       	ldd	r30, Y+1	; 0x01
    4628:	fa 81       	ldd	r31, Y+2	; 0x02
    462a:	01 80       	ldd	r0, Z+1	; 0x01
    462c:	f2 81       	ldd	r31, Z+2	; 0x02
    462e:	e0 2d       	mov	r30, r0
    4630:	82 81       	ldd	r24, Z+2	; 0x02
    4632:	93 81       	ldd	r25, Z+3	; 0x03
    4634:	e9 81       	ldd	r30, Y+1	; 0x01
    4636:	fa 81       	ldd	r31, Y+2	; 0x02
    4638:	92 83       	std	Z+2, r25	; 0x02
    463a:	81 83       	std	Z+1, r24	; 0x01
    463c:	e9 81       	ldd	r30, Y+1	; 0x01
    463e:	fa 81       	ldd	r31, Y+2	; 0x02
    4640:	21 81       	ldd	r18, Z+1	; 0x01
    4642:	32 81       	ldd	r19, Z+2	; 0x02
    4644:	89 81       	ldd	r24, Y+1	; 0x01
    4646:	9a 81       	ldd	r25, Y+2	; 0x02
    4648:	03 96       	adiw	r24, 0x03	; 3
    464a:	28 17       	cp	r18, r24
    464c:	39 07       	cpc	r19, r25
    464e:	59 f4       	brne	.+22     	; 0x4666 <vTaskSwitchContext+0xb2>
    4650:	e9 81       	ldd	r30, Y+1	; 0x01
    4652:	fa 81       	ldd	r31, Y+2	; 0x02
    4654:	01 80       	ldd	r0, Z+1	; 0x01
    4656:	f2 81       	ldd	r31, Z+2	; 0x02
    4658:	e0 2d       	mov	r30, r0
    465a:	82 81       	ldd	r24, Z+2	; 0x02
    465c:	93 81       	ldd	r25, Z+3	; 0x03
    465e:	e9 81       	ldd	r30, Y+1	; 0x01
    4660:	fa 81       	ldd	r31, Y+2	; 0x02
    4662:	92 83       	std	Z+2, r25	; 0x02
    4664:	81 83       	std	Z+1, r24	; 0x01
    4666:	e9 81       	ldd	r30, Y+1	; 0x01
    4668:	fa 81       	ldd	r31, Y+2	; 0x02
    466a:	01 80       	ldd	r0, Z+1	; 0x01
    466c:	f2 81       	ldd	r31, Z+2	; 0x02
    466e:	e0 2d       	mov	r30, r0
    4670:	86 81       	ldd	r24, Z+6	; 0x06
    4672:	97 81       	ldd	r25, Z+7	; 0x07
    4674:	90 93 8e 06 	sts	0x068E, r25
    4678:	80 93 8d 06 	sts	0x068D, r24
    467c:	8b 81       	ldd	r24, Y+3	; 0x03
    467e:	80 93 93 06 	sts	0x0693, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    4682:	0f 90       	pop	r0
    4684:	0f 90       	pop	r0
    4686:	0f 90       	pop	r0
    4688:	cf 91       	pop	r28
    468a:	df 91       	pop	r29
    468c:	08 95       	ret

0000468e <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    468e:	df 93       	push	r29
    4690:	cf 93       	push	r28
    4692:	00 d0       	rcall	.+0      	; 0x4694 <vTaskPlaceOnEventList+0x6>
    4694:	00 d0       	rcall	.+0      	; 0x4696 <vTaskPlaceOnEventList+0x8>
    4696:	cd b7       	in	r28, 0x3d	; 61
    4698:	de b7       	in	r29, 0x3e	; 62
    469a:	9a 83       	std	Y+2, r25	; 0x02
    469c:	89 83       	std	Y+1, r24	; 0x01
    469e:	7c 83       	std	Y+4, r23	; 0x04
    46a0:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    46a2:	80 91 8d 06 	lds	r24, 0x068D
    46a6:	90 91 8e 06 	lds	r25, 0x068E
    46aa:	9c 01       	movw	r18, r24
    46ac:	24 5f       	subi	r18, 0xF4	; 244
    46ae:	3f 4f       	sbci	r19, 0xFF	; 255
    46b0:	89 81       	ldd	r24, Y+1	; 0x01
    46b2:	9a 81       	ldd	r25, Y+2	; 0x02
    46b4:	b9 01       	movw	r22, r18
    46b6:	0e 94 af 0a 	call	0x155e	; 0x155e <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    46ba:	8b 81       	ldd	r24, Y+3	; 0x03
    46bc:	9c 81       	ldd	r25, Y+4	; 0x04
    46be:	61 e0       	ldi	r22, 0x01	; 1
    46c0:	0e 94 ab 29 	call	0x5356	; 0x5356 <prvAddCurrentTaskToDelayedList>
}
    46c4:	0f 90       	pop	r0
    46c6:	0f 90       	pop	r0
    46c8:	0f 90       	pop	r0
    46ca:	0f 90       	pop	r0
    46cc:	cf 91       	pop	r28
    46ce:	df 91       	pop	r29
    46d0:	08 95       	ret

000046d2 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    46d2:	df 93       	push	r29
    46d4:	cf 93       	push	r28
    46d6:	00 d0       	rcall	.+0      	; 0x46d8 <vTaskPlaceOnUnorderedEventList+0x6>
    46d8:	00 d0       	rcall	.+0      	; 0x46da <vTaskPlaceOnUnorderedEventList+0x8>
    46da:	00 d0       	rcall	.+0      	; 0x46dc <vTaskPlaceOnUnorderedEventList+0xa>
    46dc:	cd b7       	in	r28, 0x3d	; 61
    46de:	de b7       	in	r29, 0x3e	; 62
    46e0:	9a 83       	std	Y+2, r25	; 0x02
    46e2:	89 83       	std	Y+1, r24	; 0x01
    46e4:	7c 83       	std	Y+4, r23	; 0x04
    46e6:	6b 83       	std	Y+3, r22	; 0x03
    46e8:	5e 83       	std	Y+6, r21	; 0x06
    46ea:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    46ec:	e0 91 8d 06 	lds	r30, 0x068D
    46f0:	f0 91 8e 06 	lds	r31, 0x068E
    46f4:	8b 81       	ldd	r24, Y+3	; 0x03
    46f6:	9c 81       	ldd	r25, Y+4	; 0x04
    46f8:	90 68       	ori	r25, 0x80	; 128
    46fa:	95 87       	std	Z+13, r25	; 0x0d
    46fc:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    46fe:	80 91 8d 06 	lds	r24, 0x068D
    4702:	90 91 8e 06 	lds	r25, 0x068E
    4706:	9c 01       	movw	r18, r24
    4708:	24 5f       	subi	r18, 0xF4	; 244
    470a:	3f 4f       	sbci	r19, 0xFF	; 255
    470c:	89 81       	ldd	r24, Y+1	; 0x01
    470e:	9a 81       	ldd	r25, Y+2	; 0x02
    4710:	b9 01       	movw	r22, r18
    4712:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4716:	8d 81       	ldd	r24, Y+5	; 0x05
    4718:	9e 81       	ldd	r25, Y+6	; 0x06
    471a:	61 e0       	ldi	r22, 0x01	; 1
    471c:	0e 94 ab 29 	call	0x5356	; 0x5356 <prvAddCurrentTaskToDelayedList>
}
    4720:	26 96       	adiw	r28, 0x06	; 6
    4722:	0f b6       	in	r0, 0x3f	; 63
    4724:	f8 94       	cli
    4726:	de bf       	out	0x3e, r29	; 62
    4728:	0f be       	out	0x3f, r0	; 63
    472a:	cd bf       	out	0x3d, r28	; 61
    472c:	cf 91       	pop	r28
    472e:	df 91       	pop	r29
    4730:	08 95       	ret

00004732 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4732:	df 93       	push	r29
    4734:	cf 93       	push	r28
    4736:	00 d0       	rcall	.+0      	; 0x4738 <xTaskRemoveFromEventList+0x6>
    4738:	00 d0       	rcall	.+0      	; 0x473a <xTaskRemoveFromEventList+0x8>
    473a:	0f 92       	push	r0
    473c:	cd b7       	in	r28, 0x3d	; 61
    473e:	de b7       	in	r29, 0x3e	; 62
    4740:	9d 83       	std	Y+5, r25	; 0x05
    4742:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4744:	ec 81       	ldd	r30, Y+4	; 0x04
    4746:	fd 81       	ldd	r31, Y+5	; 0x05
    4748:	05 80       	ldd	r0, Z+5	; 0x05
    474a:	f6 81       	ldd	r31, Z+6	; 0x06
    474c:	e0 2d       	mov	r30, r0
    474e:	86 81       	ldd	r24, Z+6	; 0x06
    4750:	97 81       	ldd	r25, Z+7	; 0x07
    4752:	9b 83       	std	Y+3, r25	; 0x03
    4754:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4756:	8a 81       	ldd	r24, Y+2	; 0x02
    4758:	9b 81       	ldd	r25, Y+3	; 0x03
    475a:	0c 96       	adiw	r24, 0x0c	; 12
    475c:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4760:	80 91 9d 06 	lds	r24, 0x069D
    4764:	88 23       	and	r24, r24
    4766:	61 f5       	brne	.+88     	; 0x47c0 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4768:	8a 81       	ldd	r24, Y+2	; 0x02
    476a:	9b 81       	ldd	r25, Y+3	; 0x03
    476c:	02 96       	adiw	r24, 0x02	; 2
    476e:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    4772:	ea 81       	ldd	r30, Y+2	; 0x02
    4774:	fb 81       	ldd	r31, Y+3	; 0x03
    4776:	96 89       	ldd	r25, Z+22	; 0x16
    4778:	80 91 93 06 	lds	r24, 0x0693
    477c:	89 17       	cp	r24, r25
    477e:	28 f4       	brcc	.+10     	; 0x478a <xTaskRemoveFromEventList+0x58>
    4780:	ea 81       	ldd	r30, Y+2	; 0x02
    4782:	fb 81       	ldd	r31, Y+3	; 0x03
    4784:	86 89       	ldd	r24, Z+22	; 0x16
    4786:	80 93 93 06 	sts	0x0693, r24
    478a:	ea 81       	ldd	r30, Y+2	; 0x02
    478c:	fb 81       	ldd	r31, Y+3	; 0x03
    478e:	86 89       	ldd	r24, Z+22	; 0x16
    4790:	28 2f       	mov	r18, r24
    4792:	30 e0       	ldi	r19, 0x00	; 0
    4794:	c9 01       	movw	r24, r18
    4796:	88 0f       	add	r24, r24
    4798:	99 1f       	adc	r25, r25
    479a:	88 0f       	add	r24, r24
    479c:	99 1f       	adc	r25, r25
    479e:	88 0f       	add	r24, r24
    47a0:	99 1f       	adc	r25, r25
    47a2:	82 0f       	add	r24, r18
    47a4:	93 1f       	adc	r25, r19
    47a6:	ac 01       	movw	r20, r24
    47a8:	42 56       	subi	r20, 0x62	; 98
    47aa:	59 4f       	sbci	r21, 0xF9	; 249
    47ac:	8a 81       	ldd	r24, Y+2	; 0x02
    47ae:	9b 81       	ldd	r25, Y+3	; 0x03
    47b0:	9c 01       	movw	r18, r24
    47b2:	2e 5f       	subi	r18, 0xFE	; 254
    47b4:	3f 4f       	sbci	r19, 0xFF	; 255
    47b6:	ca 01       	movw	r24, r20
    47b8:	b9 01       	movw	r22, r18
    47ba:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>
    47be:	0a c0       	rjmp	.+20     	; 0x47d4 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    47c0:	8a 81       	ldd	r24, Y+2	; 0x02
    47c2:	9b 81       	ldd	r25, Y+3	; 0x03
    47c4:	9c 01       	movw	r18, r24
    47c6:	24 5f       	subi	r18, 0xF4	; 244
    47c8:	3f 4f       	sbci	r19, 0xFF	; 255
    47ca:	88 ed       	ldi	r24, 0xD8	; 216
    47cc:	96 e0       	ldi	r25, 0x06	; 6
    47ce:	b9 01       	movw	r22, r18
    47d0:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    47d4:	ea 81       	ldd	r30, Y+2	; 0x02
    47d6:	fb 81       	ldd	r31, Y+3	; 0x03
    47d8:	96 89       	ldd	r25, Z+22	; 0x16
    47da:	e0 91 8d 06 	lds	r30, 0x068D
    47de:	f0 91 8e 06 	lds	r31, 0x068E
    47e2:	86 89       	ldd	r24, Z+22	; 0x16
    47e4:	89 17       	cp	r24, r25
    47e6:	30 f4       	brcc	.+12     	; 0x47f4 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    47e8:	81 e0       	ldi	r24, 0x01	; 1
    47ea:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    47ec:	81 e0       	ldi	r24, 0x01	; 1
    47ee:	80 93 96 06 	sts	0x0696, r24
    47f2:	01 c0       	rjmp	.+2      	; 0x47f6 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    47f4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    47f6:	89 81       	ldd	r24, Y+1	; 0x01
}
    47f8:	0f 90       	pop	r0
    47fa:	0f 90       	pop	r0
    47fc:	0f 90       	pop	r0
    47fe:	0f 90       	pop	r0
    4800:	0f 90       	pop	r0
    4802:	cf 91       	pop	r28
    4804:	df 91       	pop	r29
    4806:	08 95       	ret

00004808 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    4808:	df 93       	push	r29
    480a:	cf 93       	push	r28
    480c:	00 d0       	rcall	.+0      	; 0x480e <vTaskRemoveFromUnorderedEventList+0x6>
    480e:	00 d0       	rcall	.+0      	; 0x4810 <vTaskRemoveFromUnorderedEventList+0x8>
    4810:	00 d0       	rcall	.+0      	; 0x4812 <vTaskRemoveFromUnorderedEventList+0xa>
    4812:	cd b7       	in	r28, 0x3d	; 61
    4814:	de b7       	in	r29, 0x3e	; 62
    4816:	9c 83       	std	Y+4, r25	; 0x04
    4818:	8b 83       	std	Y+3, r24	; 0x03
    481a:	7e 83       	std	Y+6, r23	; 0x06
    481c:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    481e:	8d 81       	ldd	r24, Y+5	; 0x05
    4820:	9e 81       	ldd	r25, Y+6	; 0x06
    4822:	90 68       	ori	r25, 0x80	; 128
    4824:	eb 81       	ldd	r30, Y+3	; 0x03
    4826:	fc 81       	ldd	r31, Y+4	; 0x04
    4828:	91 83       	std	Z+1, r25	; 0x01
    482a:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    482c:	eb 81       	ldd	r30, Y+3	; 0x03
    482e:	fc 81       	ldd	r31, Y+4	; 0x04
    4830:	86 81       	ldd	r24, Z+6	; 0x06
    4832:	97 81       	ldd	r25, Z+7	; 0x07
    4834:	9a 83       	std	Y+2, r25	; 0x02
    4836:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    4838:	8b 81       	ldd	r24, Y+3	; 0x03
    483a:	9c 81       	ldd	r25, Y+4	; 0x04
    483c:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    4840:	89 81       	ldd	r24, Y+1	; 0x01
    4842:	9a 81       	ldd	r25, Y+2	; 0x02
    4844:	02 96       	adiw	r24, 0x02	; 2
    4846:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    484a:	e9 81       	ldd	r30, Y+1	; 0x01
    484c:	fa 81       	ldd	r31, Y+2	; 0x02
    484e:	96 89       	ldd	r25, Z+22	; 0x16
    4850:	80 91 93 06 	lds	r24, 0x0693
    4854:	89 17       	cp	r24, r25
    4856:	28 f4       	brcc	.+10     	; 0x4862 <vTaskRemoveFromUnorderedEventList+0x5a>
    4858:	e9 81       	ldd	r30, Y+1	; 0x01
    485a:	fa 81       	ldd	r31, Y+2	; 0x02
    485c:	86 89       	ldd	r24, Z+22	; 0x16
    485e:	80 93 93 06 	sts	0x0693, r24
    4862:	e9 81       	ldd	r30, Y+1	; 0x01
    4864:	fa 81       	ldd	r31, Y+2	; 0x02
    4866:	86 89       	ldd	r24, Z+22	; 0x16
    4868:	28 2f       	mov	r18, r24
    486a:	30 e0       	ldi	r19, 0x00	; 0
    486c:	c9 01       	movw	r24, r18
    486e:	88 0f       	add	r24, r24
    4870:	99 1f       	adc	r25, r25
    4872:	88 0f       	add	r24, r24
    4874:	99 1f       	adc	r25, r25
    4876:	88 0f       	add	r24, r24
    4878:	99 1f       	adc	r25, r25
    487a:	82 0f       	add	r24, r18
    487c:	93 1f       	adc	r25, r19
    487e:	ac 01       	movw	r20, r24
    4880:	42 56       	subi	r20, 0x62	; 98
    4882:	59 4f       	sbci	r21, 0xF9	; 249
    4884:	89 81       	ldd	r24, Y+1	; 0x01
    4886:	9a 81       	ldd	r25, Y+2	; 0x02
    4888:	9c 01       	movw	r18, r24
    488a:	2e 5f       	subi	r18, 0xFE	; 254
    488c:	3f 4f       	sbci	r19, 0xFF	; 255
    488e:	ca 01       	movw	r24, r20
    4890:	b9 01       	movw	r22, r18
    4892:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4896:	e9 81       	ldd	r30, Y+1	; 0x01
    4898:	fa 81       	ldd	r31, Y+2	; 0x02
    489a:	96 89       	ldd	r25, Z+22	; 0x16
    489c:	e0 91 8d 06 	lds	r30, 0x068D
    48a0:	f0 91 8e 06 	lds	r31, 0x068E
    48a4:	86 89       	ldd	r24, Z+22	; 0x16
    48a6:	89 17       	cp	r24, r25
    48a8:	18 f4       	brcc	.+6      	; 0x48b0 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    48aa:	81 e0       	ldi	r24, 0x01	; 1
    48ac:	80 93 96 06 	sts	0x0696, r24
	}
}
    48b0:	26 96       	adiw	r28, 0x06	; 6
    48b2:	0f b6       	in	r0, 0x3f	; 63
    48b4:	f8 94       	cli
    48b6:	de bf       	out	0x3e, r29	; 62
    48b8:	0f be       	out	0x3f, r0	; 63
    48ba:	cd bf       	out	0x3d, r28	; 61
    48bc:	cf 91       	pop	r28
    48be:	df 91       	pop	r29
    48c0:	08 95       	ret

000048c2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    48c2:	df 93       	push	r29
    48c4:	cf 93       	push	r28
    48c6:	00 d0       	rcall	.+0      	; 0x48c8 <vTaskSetTimeOutState+0x6>
    48c8:	cd b7       	in	r28, 0x3d	; 61
    48ca:	de b7       	in	r29, 0x3e	; 62
    48cc:	9a 83       	std	Y+2, r25	; 0x02
    48ce:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    48d0:	0f b6       	in	r0, 0x3f	; 63
    48d2:	f8 94       	cli
    48d4:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    48d6:	80 91 97 06 	lds	r24, 0x0697
    48da:	e9 81       	ldd	r30, Y+1	; 0x01
    48dc:	fa 81       	ldd	r31, Y+2	; 0x02
    48de:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    48e0:	80 91 91 06 	lds	r24, 0x0691
    48e4:	90 91 92 06 	lds	r25, 0x0692
    48e8:	e9 81       	ldd	r30, Y+1	; 0x01
    48ea:	fa 81       	ldd	r31, Y+2	; 0x02
    48ec:	92 83       	std	Z+2, r25	; 0x02
    48ee:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    48f0:	0f 90       	pop	r0
    48f2:	0f be       	out	0x3f, r0	; 63
}
    48f4:	0f 90       	pop	r0
    48f6:	0f 90       	pop	r0
    48f8:	cf 91       	pop	r28
    48fa:	df 91       	pop	r29
    48fc:	08 95       	ret

000048fe <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    48fe:	df 93       	push	r29
    4900:	cf 93       	push	r28
    4902:	00 d0       	rcall	.+0      	; 0x4904 <vTaskInternalSetTimeOutState+0x6>
    4904:	cd b7       	in	r28, 0x3d	; 61
    4906:	de b7       	in	r29, 0x3e	; 62
    4908:	9a 83       	std	Y+2, r25	; 0x02
    490a:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    490c:	80 91 97 06 	lds	r24, 0x0697
    4910:	e9 81       	ldd	r30, Y+1	; 0x01
    4912:	fa 81       	ldd	r31, Y+2	; 0x02
    4914:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4916:	80 91 91 06 	lds	r24, 0x0691
    491a:	90 91 92 06 	lds	r25, 0x0692
    491e:	e9 81       	ldd	r30, Y+1	; 0x01
    4920:	fa 81       	ldd	r31, Y+2	; 0x02
    4922:	92 83       	std	Z+2, r25	; 0x02
    4924:	81 83       	std	Z+1, r24	; 0x01
}
    4926:	0f 90       	pop	r0
    4928:	0f 90       	pop	r0
    492a:	cf 91       	pop	r28
    492c:	df 91       	pop	r29
    492e:	08 95       	ret

00004930 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    4930:	df 93       	push	r29
    4932:	cf 93       	push	r28
    4934:	cd b7       	in	r28, 0x3d	; 61
    4936:	de b7       	in	r29, 0x3e	; 62
    4938:	29 97       	sbiw	r28, 0x09	; 9
    493a:	0f b6       	in	r0, 0x3f	; 63
    493c:	f8 94       	cli
    493e:	de bf       	out	0x3e, r29	; 62
    4940:	0f be       	out	0x3f, r0	; 63
    4942:	cd bf       	out	0x3d, r28	; 61
    4944:	9f 83       	std	Y+7, r25	; 0x07
    4946:	8e 83       	std	Y+6, r24	; 0x06
    4948:	79 87       	std	Y+9, r23	; 0x09
    494a:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    494c:	0f b6       	in	r0, 0x3f	; 63
    494e:	f8 94       	cli
    4950:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    4952:	80 91 91 06 	lds	r24, 0x0691
    4956:	90 91 92 06 	lds	r25, 0x0692
    495a:	9c 83       	std	Y+4, r25	; 0x04
    495c:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    495e:	ee 81       	ldd	r30, Y+6	; 0x06
    4960:	ff 81       	ldd	r31, Y+7	; 0x07
    4962:	21 81       	ldd	r18, Z+1	; 0x01
    4964:	32 81       	ldd	r19, Z+2	; 0x02
    4966:	8b 81       	ldd	r24, Y+3	; 0x03
    4968:	9c 81       	ldd	r25, Y+4	; 0x04
    496a:	82 1b       	sub	r24, r18
    496c:	93 0b       	sbc	r25, r19
    496e:	9a 83       	std	Y+2, r25	; 0x02
    4970:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    4972:	e8 85       	ldd	r30, Y+8	; 0x08
    4974:	f9 85       	ldd	r31, Y+9	; 0x09
    4976:	80 81       	ld	r24, Z
    4978:	91 81       	ldd	r25, Z+1	; 0x01
    497a:	2f ef       	ldi	r18, 0xFF	; 255
    497c:	8f 3f       	cpi	r24, 0xFF	; 255
    497e:	92 07       	cpc	r25, r18
    4980:	11 f4       	brne	.+4      	; 0x4986 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    4982:	1d 82       	std	Y+5, r1	; 0x05
    4984:	36 c0       	rjmp	.+108    	; 0x49f2 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4986:	ee 81       	ldd	r30, Y+6	; 0x06
    4988:	ff 81       	ldd	r31, Y+7	; 0x07
    498a:	90 81       	ld	r25, Z
    498c:	80 91 97 06 	lds	r24, 0x0697
    4990:	98 17       	cp	r25, r24
    4992:	61 f0       	breq	.+24     	; 0x49ac <xTaskCheckForTimeOut+0x7c>
    4994:	ee 81       	ldd	r30, Y+6	; 0x06
    4996:	ff 81       	ldd	r31, Y+7	; 0x07
    4998:	21 81       	ldd	r18, Z+1	; 0x01
    499a:	32 81       	ldd	r19, Z+2	; 0x02
    499c:	8b 81       	ldd	r24, Y+3	; 0x03
    499e:	9c 81       	ldd	r25, Y+4	; 0x04
    49a0:	82 17       	cp	r24, r18
    49a2:	93 07       	cpc	r25, r19
    49a4:	18 f0       	brcs	.+6      	; 0x49ac <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    49a6:	81 e0       	ldi	r24, 0x01	; 1
    49a8:	8d 83       	std	Y+5, r24	; 0x05
    49aa:	23 c0       	rjmp	.+70     	; 0x49f2 <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    49ac:	e8 85       	ldd	r30, Y+8	; 0x08
    49ae:	f9 85       	ldd	r31, Y+9	; 0x09
    49b0:	20 81       	ld	r18, Z
    49b2:	31 81       	ldd	r19, Z+1	; 0x01
    49b4:	89 81       	ldd	r24, Y+1	; 0x01
    49b6:	9a 81       	ldd	r25, Y+2	; 0x02
    49b8:	82 17       	cp	r24, r18
    49ba:	93 07       	cpc	r25, r19
    49bc:	a0 f4       	brcc	.+40     	; 0x49e6 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    49be:	e8 85       	ldd	r30, Y+8	; 0x08
    49c0:	f9 85       	ldd	r31, Y+9	; 0x09
    49c2:	20 81       	ld	r18, Z
    49c4:	31 81       	ldd	r19, Z+1	; 0x01
    49c6:	89 81       	ldd	r24, Y+1	; 0x01
    49c8:	9a 81       	ldd	r25, Y+2	; 0x02
    49ca:	a9 01       	movw	r20, r18
    49cc:	48 1b       	sub	r20, r24
    49ce:	59 0b       	sbc	r21, r25
    49d0:	ca 01       	movw	r24, r20
    49d2:	e8 85       	ldd	r30, Y+8	; 0x08
    49d4:	f9 85       	ldd	r31, Y+9	; 0x09
    49d6:	91 83       	std	Z+1, r25	; 0x01
    49d8:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    49da:	8e 81       	ldd	r24, Y+6	; 0x06
    49dc:	9f 81       	ldd	r25, Y+7	; 0x07
    49de:	0e 94 7f 24 	call	0x48fe	; 0x48fe <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    49e2:	1d 82       	std	Y+5, r1	; 0x05
    49e4:	06 c0       	rjmp	.+12     	; 0x49f2 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    49e6:	e8 85       	ldd	r30, Y+8	; 0x08
    49e8:	f9 85       	ldd	r31, Y+9	; 0x09
    49ea:	11 82       	std	Z+1, r1	; 0x01
    49ec:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    49ee:	81 e0       	ldi	r24, 0x01	; 1
    49f0:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    49f2:	0f 90       	pop	r0
    49f4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    49f6:	8d 81       	ldd	r24, Y+5	; 0x05
}
    49f8:	29 96       	adiw	r28, 0x09	; 9
    49fa:	0f b6       	in	r0, 0x3f	; 63
    49fc:	f8 94       	cli
    49fe:	de bf       	out	0x3e, r29	; 62
    4a00:	0f be       	out	0x3f, r0	; 63
    4a02:	cd bf       	out	0x3d, r28	; 61
    4a04:	cf 91       	pop	r28
    4a06:	df 91       	pop	r29
    4a08:	08 95       	ret

00004a0a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4a0a:	df 93       	push	r29
    4a0c:	cf 93       	push	r28
    4a0e:	cd b7       	in	r28, 0x3d	; 61
    4a10:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    4a12:	81 e0       	ldi	r24, 0x01	; 1
    4a14:	80 93 96 06 	sts	0x0696, r24
}
    4a18:	cf 91       	pop	r28
    4a1a:	df 91       	pop	r29
    4a1c:	08 95       	ret

00004a1e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4a1e:	df 93       	push	r29
    4a20:	cf 93       	push	r28
    4a22:	00 d0       	rcall	.+0      	; 0x4a24 <prvIdleTask+0x6>
    4a24:	cd b7       	in	r28, 0x3d	; 61
    4a26:	de b7       	in	r29, 0x3e	; 62
    4a28:	9a 83       	std	Y+2, r25	; 0x02
    4a2a:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    4a2c:	0e 94 5a 25 	call	0x4ab4	; 0x4ab4 <prvCheckTasksWaitingTermination>
    4a30:	fd cf       	rjmp	.-6      	; 0x4a2c <prvIdleTask+0xe>

00004a32 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4a32:	df 93       	push	r29
    4a34:	cf 93       	push	r28
    4a36:	0f 92       	push	r0
    4a38:	cd b7       	in	r28, 0x3d	; 61
    4a3a:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4a3c:	19 82       	std	Y+1, r1	; 0x01
    4a3e:	13 c0       	rjmp	.+38     	; 0x4a66 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4a40:	89 81       	ldd	r24, Y+1	; 0x01
    4a42:	28 2f       	mov	r18, r24
    4a44:	30 e0       	ldi	r19, 0x00	; 0
    4a46:	c9 01       	movw	r24, r18
    4a48:	88 0f       	add	r24, r24
    4a4a:	99 1f       	adc	r25, r25
    4a4c:	88 0f       	add	r24, r24
    4a4e:	99 1f       	adc	r25, r25
    4a50:	88 0f       	add	r24, r24
    4a52:	99 1f       	adc	r25, r25
    4a54:	82 0f       	add	r24, r18
    4a56:	93 1f       	adc	r25, r19
    4a58:	82 56       	subi	r24, 0x62	; 98
    4a5a:	99 4f       	sbci	r25, 0xF9	; 249
    4a5c:	0e 94 31 0a 	call	0x1462	; 0x1462 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4a60:	89 81       	ldd	r24, Y+1	; 0x01
    4a62:	8f 5f       	subi	r24, 0xFF	; 255
    4a64:	89 83       	std	Y+1, r24	; 0x01
    4a66:	89 81       	ldd	r24, Y+1	; 0x01
    4a68:	84 30       	cpi	r24, 0x04	; 4
    4a6a:	50 f3       	brcs	.-44     	; 0x4a40 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    4a6c:	82 ec       	ldi	r24, 0xC2	; 194
    4a6e:	96 e0       	ldi	r25, 0x06	; 6
    4a70:	0e 94 31 0a 	call	0x1462	; 0x1462 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    4a74:	8b ec       	ldi	r24, 0xCB	; 203
    4a76:	96 e0       	ldi	r25, 0x06	; 6
    4a78:	0e 94 31 0a 	call	0x1462	; 0x1462 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    4a7c:	88 ed       	ldi	r24, 0xD8	; 216
    4a7e:	96 e0       	ldi	r25, 0x06	; 6
    4a80:	0e 94 31 0a 	call	0x1462	; 0x1462 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    4a84:	81 ee       	ldi	r24, 0xE1	; 225
    4a86:	96 e0       	ldi	r25, 0x06	; 6
    4a88:	0e 94 31 0a 	call	0x1462	; 0x1462 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    4a8c:	8a ee       	ldi	r24, 0xEA	; 234
    4a8e:	96 e0       	ldi	r25, 0x06	; 6
    4a90:	0e 94 31 0a 	call	0x1462	; 0x1462 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4a94:	82 ec       	ldi	r24, 0xC2	; 194
    4a96:	96 e0       	ldi	r25, 0x06	; 6
    4a98:	90 93 d5 06 	sts	0x06D5, r25
    4a9c:	80 93 d4 06 	sts	0x06D4, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4aa0:	8b ec       	ldi	r24, 0xCB	; 203
    4aa2:	96 e0       	ldi	r25, 0x06	; 6
    4aa4:	90 93 d7 06 	sts	0x06D7, r25
    4aa8:	80 93 d6 06 	sts	0x06D6, r24
}
    4aac:	0f 90       	pop	r0
    4aae:	cf 91       	pop	r28
    4ab0:	df 91       	pop	r29
    4ab2:	08 95       	ret

00004ab4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4ab4:	df 93       	push	r29
    4ab6:	cf 93       	push	r28
    4ab8:	00 d0       	rcall	.+0      	; 0x4aba <prvCheckTasksWaitingTermination+0x6>
    4aba:	cd b7       	in	r28, 0x3d	; 61
    4abc:	de b7       	in	r29, 0x3e	; 62
    4abe:	20 c0       	rjmp	.+64     	; 0x4b00 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    4ac0:	0f b6       	in	r0, 0x3f	; 63
    4ac2:	f8 94       	cli
    4ac4:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4ac6:	e0 91 e6 06 	lds	r30, 0x06E6
    4aca:	f0 91 e7 06 	lds	r31, 0x06E7
    4ace:	86 81       	ldd	r24, Z+6	; 0x06
    4ad0:	97 81       	ldd	r25, Z+7	; 0x07
    4ad2:	9a 83       	std	Y+2, r25	; 0x02
    4ad4:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4ad6:	89 81       	ldd	r24, Y+1	; 0x01
    4ad8:	9a 81       	ldd	r25, Y+2	; 0x02
    4ada:	02 96       	adiw	r24, 0x02	; 2
    4adc:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
				--uxCurrentNumberOfTasks;
    4ae0:	80 91 90 06 	lds	r24, 0x0690
    4ae4:	81 50       	subi	r24, 0x01	; 1
    4ae6:	80 93 90 06 	sts	0x0690, r24
				--uxDeletedTasksWaitingCleanUp;
    4aea:	80 91 8f 06 	lds	r24, 0x068F
    4aee:	81 50       	subi	r24, 0x01	; 1
    4af0:	80 93 8f 06 	sts	0x068F, r24
			}
			taskEXIT_CRITICAL();
    4af4:	0f 90       	pop	r0
    4af6:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    4af8:	89 81       	ldd	r24, Y+1	; 0x01
    4afa:	9a 81       	ldd	r25, Y+2	; 0x02
    4afc:	0e 94 89 25 	call	0x4b12	; 0x4b12 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4b00:	80 91 8f 06 	lds	r24, 0x068F
    4b04:	88 23       	and	r24, r24
    4b06:	e1 f6       	brne	.-72     	; 0x4ac0 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    4b08:	0f 90       	pop	r0
    4b0a:	0f 90       	pop	r0
    4b0c:	cf 91       	pop	r28
    4b0e:	df 91       	pop	r29
    4b10:	08 95       	ret

00004b12 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    4b12:	df 93       	push	r29
    4b14:	cf 93       	push	r28
    4b16:	00 d0       	rcall	.+0      	; 0x4b18 <prvDeleteTCB+0x6>
    4b18:	cd b7       	in	r28, 0x3d	; 61
    4b1a:	de b7       	in	r29, 0x3e	; 62
    4b1c:	9a 83       	std	Y+2, r25	; 0x02
    4b1e:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    4b20:	e9 81       	ldd	r30, Y+1	; 0x01
    4b22:	fa 81       	ldd	r31, Y+2	; 0x02
    4b24:	87 89       	ldd	r24, Z+23	; 0x17
    4b26:	90 8d       	ldd	r25, Z+24	; 0x18
    4b28:	0e 94 71 07 	call	0xee2	; 0xee2 <vPortFree>
			vPortFree( pxTCB );
    4b2c:	89 81       	ldd	r24, Y+1	; 0x01
    4b2e:	9a 81       	ldd	r25, Y+2	; 0x02
    4b30:	0e 94 71 07 	call	0xee2	; 0xee2 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    4b34:	0f 90       	pop	r0
    4b36:	0f 90       	pop	r0
    4b38:	cf 91       	pop	r28
    4b3a:	df 91       	pop	r29
    4b3c:	08 95       	ret

00004b3e <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4b3e:	df 93       	push	r29
    4b40:	cf 93       	push	r28
    4b42:	00 d0       	rcall	.+0      	; 0x4b44 <prvResetNextTaskUnblockTime+0x6>
    4b44:	cd b7       	in	r28, 0x3d	; 61
    4b46:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4b48:	e0 91 d4 06 	lds	r30, 0x06D4
    4b4c:	f0 91 d5 06 	lds	r31, 0x06D5
    4b50:	80 81       	ld	r24, Z
    4b52:	88 23       	and	r24, r24
    4b54:	39 f4       	brne	.+14     	; 0x4b64 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4b56:	8f ef       	ldi	r24, 0xFF	; 255
    4b58:	9f ef       	ldi	r25, 0xFF	; 255
    4b5a:	90 93 9a 06 	sts	0x069A, r25
    4b5e:	80 93 99 06 	sts	0x0699, r24
    4b62:	13 c0       	rjmp	.+38     	; 0x4b8a <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4b64:	e0 91 d4 06 	lds	r30, 0x06D4
    4b68:	f0 91 d5 06 	lds	r31, 0x06D5
    4b6c:	05 80       	ldd	r0, Z+5	; 0x05
    4b6e:	f6 81       	ldd	r31, Z+6	; 0x06
    4b70:	e0 2d       	mov	r30, r0
    4b72:	86 81       	ldd	r24, Z+6	; 0x06
    4b74:	97 81       	ldd	r25, Z+7	; 0x07
    4b76:	9a 83       	std	Y+2, r25	; 0x02
    4b78:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4b7a:	e9 81       	ldd	r30, Y+1	; 0x01
    4b7c:	fa 81       	ldd	r31, Y+2	; 0x02
    4b7e:	82 81       	ldd	r24, Z+2	; 0x02
    4b80:	93 81       	ldd	r25, Z+3	; 0x03
    4b82:	90 93 9a 06 	sts	0x069A, r25
    4b86:	80 93 99 06 	sts	0x0699, r24
	}
}
    4b8a:	0f 90       	pop	r0
    4b8c:	0f 90       	pop	r0
    4b8e:	cf 91       	pop	r28
    4b90:	df 91       	pop	r29
    4b92:	08 95       	ret

00004b94 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    4b94:	df 93       	push	r29
    4b96:	cf 93       	push	r28
    4b98:	00 d0       	rcall	.+0      	; 0x4b9a <xTaskGetCurrentTaskHandle+0x6>
    4b9a:	cd b7       	in	r28, 0x3d	; 61
    4b9c:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4b9e:	80 91 8d 06 	lds	r24, 0x068D
    4ba2:	90 91 8e 06 	lds	r25, 0x068E
    4ba6:	9a 83       	std	Y+2, r25	; 0x02
    4ba8:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4baa:	89 81       	ldd	r24, Y+1	; 0x01
    4bac:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4bae:	0f 90       	pop	r0
    4bb0:	0f 90       	pop	r0
    4bb2:	cf 91       	pop	r28
    4bb4:	df 91       	pop	r29
    4bb6:	08 95       	ret

00004bb8 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4bb8:	df 93       	push	r29
    4bba:	cf 93       	push	r28
    4bbc:	00 d0       	rcall	.+0      	; 0x4bbe <uxTaskResetEventItemValue+0x6>
    4bbe:	cd b7       	in	r28, 0x3d	; 61
    4bc0:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4bc2:	e0 91 8d 06 	lds	r30, 0x068D
    4bc6:	f0 91 8e 06 	lds	r31, 0x068E
    4bca:	84 85       	ldd	r24, Z+12	; 0x0c
    4bcc:	95 85       	ldd	r25, Z+13	; 0x0d
    4bce:	9a 83       	std	Y+2, r25	; 0x02
    4bd0:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4bd2:	a0 91 8d 06 	lds	r26, 0x068D
    4bd6:	b0 91 8e 06 	lds	r27, 0x068E
    4bda:	e0 91 8d 06 	lds	r30, 0x068D
    4bde:	f0 91 8e 06 	lds	r31, 0x068E
    4be2:	86 89       	ldd	r24, Z+22	; 0x16
    4be4:	28 2f       	mov	r18, r24
    4be6:	30 e0       	ldi	r19, 0x00	; 0
    4be8:	84 e0       	ldi	r24, 0x04	; 4
    4bea:	90 e0       	ldi	r25, 0x00	; 0
    4bec:	82 1b       	sub	r24, r18
    4bee:	93 0b       	sbc	r25, r19
    4bf0:	1d 96       	adiw	r26, 0x0d	; 13
    4bf2:	9c 93       	st	X, r25
    4bf4:	8e 93       	st	-X, r24
    4bf6:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    4bf8:	89 81       	ldd	r24, Y+1	; 0x01
    4bfa:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4bfc:	0f 90       	pop	r0
    4bfe:	0f 90       	pop	r0
    4c00:	cf 91       	pop	r28
    4c02:	df 91       	pop	r29
    4c04:	08 95       	ret

00004c06 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    4c06:	df 93       	push	r29
    4c08:	cf 93       	push	r28
    4c0a:	cd b7       	in	r28, 0x3d	; 61
    4c0c:	de b7       	in	r29, 0x3e	; 62
    4c0e:	27 97       	sbiw	r28, 0x07	; 7
    4c10:	0f b6       	in	r0, 0x3f	; 63
    4c12:	f8 94       	cli
    4c14:	de bf       	out	0x3e, r29	; 62
    4c16:	0f be       	out	0x3f, r0	; 63
    4c18:	cd bf       	out	0x3d, r28	; 61
    4c1a:	8d 83       	std	Y+5, r24	; 0x05
    4c1c:	7f 83       	std	Y+7, r23	; 0x07
    4c1e:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    4c20:	0f b6       	in	r0, 0x3f	; 63
    4c22:	f8 94       	cli
    4c24:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    4c26:	e0 91 8d 06 	lds	r30, 0x068D
    4c2a:	f0 91 8e 06 	lds	r31, 0x068E
    4c2e:	85 a1       	ldd	r24, Z+37	; 0x25
    4c30:	96 a1       	ldd	r25, Z+38	; 0x26
    4c32:	a7 a1       	ldd	r26, Z+39	; 0x27
    4c34:	b0 a5       	ldd	r27, Z+40	; 0x28
    4c36:	00 97       	sbiw	r24, 0x00	; 0
    4c38:	a1 05       	cpc	r26, r1
    4c3a:	b1 05       	cpc	r27, r1
    4c3c:	89 f4       	brne	.+34     	; 0x4c60 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4c3e:	e0 91 8d 06 	lds	r30, 0x068D
    4c42:	f0 91 8e 06 	lds	r31, 0x068E
    4c46:	81 e0       	ldi	r24, 0x01	; 1
    4c48:	81 a7       	std	Z+41, r24	; 0x29

				if( xTicksToWait > ( TickType_t ) 0 )
    4c4a:	8e 81       	ldd	r24, Y+6	; 0x06
    4c4c:	9f 81       	ldd	r25, Y+7	; 0x07
    4c4e:	00 97       	sbiw	r24, 0x00	; 0
    4c50:	39 f0       	breq	.+14     	; 0x4c60 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4c52:	8e 81       	ldd	r24, Y+6	; 0x06
    4c54:	9f 81       	ldd	r25, Y+7	; 0x07
    4c56:	61 e0       	ldi	r22, 0x01	; 1
    4c58:	0e 94 ab 29 	call	0x5356	; 0x5356 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4c5c:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4c60:	0f 90       	pop	r0
    4c62:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4c64:	0f b6       	in	r0, 0x3f	; 63
    4c66:	f8 94       	cli
    4c68:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    4c6a:	e0 91 8d 06 	lds	r30, 0x068D
    4c6e:	f0 91 8e 06 	lds	r31, 0x068E
    4c72:	85 a1       	ldd	r24, Z+37	; 0x25
    4c74:	96 a1       	ldd	r25, Z+38	; 0x26
    4c76:	a7 a1       	ldd	r26, Z+39	; 0x27
    4c78:	b0 a5       	ldd	r27, Z+40	; 0x28
    4c7a:	89 83       	std	Y+1, r24	; 0x01
    4c7c:	9a 83       	std	Y+2, r25	; 0x02
    4c7e:	ab 83       	std	Y+3, r26	; 0x03
    4c80:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    4c82:	89 81       	ldd	r24, Y+1	; 0x01
    4c84:	9a 81       	ldd	r25, Y+2	; 0x02
    4c86:	ab 81       	ldd	r26, Y+3	; 0x03
    4c88:	bc 81       	ldd	r27, Y+4	; 0x04
    4c8a:	00 97       	sbiw	r24, 0x00	; 0
    4c8c:	a1 05       	cpc	r26, r1
    4c8e:	b1 05       	cpc	r27, r1
    4c90:	d9 f0       	breq	.+54     	; 0x4cc8 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    4c92:	8d 81       	ldd	r24, Y+5	; 0x05
    4c94:	88 23       	and	r24, r24
    4c96:	49 f0       	breq	.+18     	; 0x4caa <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    4c98:	e0 91 8d 06 	lds	r30, 0x068D
    4c9c:	f0 91 8e 06 	lds	r31, 0x068E
    4ca0:	15 a2       	std	Z+37, r1	; 0x25
    4ca2:	16 a2       	std	Z+38, r1	; 0x26
    4ca4:	17 a2       	std	Z+39, r1	; 0x27
    4ca6:	10 a6       	std	Z+40, r1	; 0x28
    4ca8:	0f c0       	rjmp	.+30     	; 0x4cc8 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    4caa:	e0 91 8d 06 	lds	r30, 0x068D
    4cae:	f0 91 8e 06 	lds	r31, 0x068E
    4cb2:	89 81       	ldd	r24, Y+1	; 0x01
    4cb4:	9a 81       	ldd	r25, Y+2	; 0x02
    4cb6:	ab 81       	ldd	r26, Y+3	; 0x03
    4cb8:	bc 81       	ldd	r27, Y+4	; 0x04
    4cba:	01 97       	sbiw	r24, 0x01	; 1
    4cbc:	a1 09       	sbc	r26, r1
    4cbe:	b1 09       	sbc	r27, r1
    4cc0:	85 a3       	std	Z+37, r24	; 0x25
    4cc2:	96 a3       	std	Z+38, r25	; 0x26
    4cc4:	a7 a3       	std	Z+39, r26	; 0x27
    4cc6:	b0 a7       	std	Z+40, r27	; 0x28
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4cc8:	e0 91 8d 06 	lds	r30, 0x068D
    4ccc:	f0 91 8e 06 	lds	r31, 0x068E
    4cd0:	11 a6       	std	Z+41, r1	; 0x29
		}
		taskEXIT_CRITICAL();
    4cd2:	0f 90       	pop	r0
    4cd4:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    4cd6:	89 81       	ldd	r24, Y+1	; 0x01
    4cd8:	9a 81       	ldd	r25, Y+2	; 0x02
    4cda:	ab 81       	ldd	r26, Y+3	; 0x03
    4cdc:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    4cde:	bc 01       	movw	r22, r24
    4ce0:	cd 01       	movw	r24, r26
    4ce2:	27 96       	adiw	r28, 0x07	; 7
    4ce4:	0f b6       	in	r0, 0x3f	; 63
    4ce6:	f8 94       	cli
    4ce8:	de bf       	out	0x3e, r29	; 62
    4cea:	0f be       	out	0x3f, r0	; 63
    4cec:	cd bf       	out	0x3d, r28	; 61
    4cee:	cf 91       	pop	r28
    4cf0:	df 91       	pop	r29
    4cf2:	08 95       	ret

00004cf4 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    4cf4:	ef 92       	push	r14
    4cf6:	ff 92       	push	r15
    4cf8:	0f 93       	push	r16
    4cfa:	1f 93       	push	r17
    4cfc:	df 93       	push	r29
    4cfe:	cf 93       	push	r28
    4d00:	cd b7       	in	r28, 0x3d	; 61
    4d02:	de b7       	in	r29, 0x3e	; 62
    4d04:	2d 97       	sbiw	r28, 0x0d	; 13
    4d06:	0f b6       	in	r0, 0x3f	; 63
    4d08:	f8 94       	cli
    4d0a:	de bf       	out	0x3e, r29	; 62
    4d0c:	0f be       	out	0x3f, r0	; 63
    4d0e:	cd bf       	out	0x3d, r28	; 61
    4d10:	6a 83       	std	Y+2, r22	; 0x02
    4d12:	7b 83       	std	Y+3, r23	; 0x03
    4d14:	8c 83       	std	Y+4, r24	; 0x04
    4d16:	9d 83       	std	Y+5, r25	; 0x05
    4d18:	2e 83       	std	Y+6, r18	; 0x06
    4d1a:	3f 83       	std	Y+7, r19	; 0x07
    4d1c:	48 87       	std	Y+8, r20	; 0x08
    4d1e:	59 87       	std	Y+9, r21	; 0x09
    4d20:	1b 87       	std	Y+11, r17	; 0x0b
    4d22:	0a 87       	std	Y+10, r16	; 0x0a
    4d24:	fd 86       	std	Y+13, r15	; 0x0d
    4d26:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    4d28:	0f b6       	in	r0, 0x3f	; 63
    4d2a:	f8 94       	cli
    4d2c:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4d2e:	e0 91 8d 06 	lds	r30, 0x068D
    4d32:	f0 91 8e 06 	lds	r31, 0x068E
    4d36:	81 a5       	ldd	r24, Z+41	; 0x29
    4d38:	82 30       	cpi	r24, 0x02	; 2
    4d3a:	49 f1       	breq	.+82     	; 0x4d8e <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    4d3c:	e0 91 8d 06 	lds	r30, 0x068D
    4d40:	f0 91 8e 06 	lds	r31, 0x068E
    4d44:	25 a1       	ldd	r18, Z+37	; 0x25
    4d46:	36 a1       	ldd	r19, Z+38	; 0x26
    4d48:	47 a1       	ldd	r20, Z+39	; 0x27
    4d4a:	50 a5       	ldd	r21, Z+40	; 0x28
    4d4c:	8a 81       	ldd	r24, Y+2	; 0x02
    4d4e:	9b 81       	ldd	r25, Y+3	; 0x03
    4d50:	ac 81       	ldd	r26, Y+4	; 0x04
    4d52:	bd 81       	ldd	r27, Y+5	; 0x05
    4d54:	80 95       	com	r24
    4d56:	90 95       	com	r25
    4d58:	a0 95       	com	r26
    4d5a:	b0 95       	com	r27
    4d5c:	82 23       	and	r24, r18
    4d5e:	93 23       	and	r25, r19
    4d60:	a4 23       	and	r26, r20
    4d62:	b5 23       	and	r27, r21
    4d64:	85 a3       	std	Z+37, r24	; 0x25
    4d66:	96 a3       	std	Z+38, r25	; 0x26
    4d68:	a7 a3       	std	Z+39, r26	; 0x27
    4d6a:	b0 a7       	std	Z+40, r27	; 0x28

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4d6c:	e0 91 8d 06 	lds	r30, 0x068D
    4d70:	f0 91 8e 06 	lds	r31, 0x068E
    4d74:	81 e0       	ldi	r24, 0x01	; 1
    4d76:	81 a7       	std	Z+41, r24	; 0x29

				if( xTicksToWait > ( TickType_t ) 0 )
    4d78:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d7a:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d7c:	00 97       	sbiw	r24, 0x00	; 0
    4d7e:	39 f0       	breq	.+14     	; 0x4d8e <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4d80:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d82:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d84:	61 e0       	ldi	r22, 0x01	; 1
    4d86:	0e 94 ab 29 	call	0x5356	; 0x5356 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    4d8a:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4d8e:	0f 90       	pop	r0
    4d90:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    4d92:	0f b6       	in	r0, 0x3f	; 63
    4d94:	f8 94       	cli
    4d96:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    4d98:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d9a:	9b 85       	ldd	r25, Y+11	; 0x0b
    4d9c:	00 97       	sbiw	r24, 0x00	; 0
    4d9e:	71 f0       	breq	.+28     	; 0x4dbc <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4da0:	e0 91 8d 06 	lds	r30, 0x068D
    4da4:	f0 91 8e 06 	lds	r31, 0x068E
    4da8:	85 a1       	ldd	r24, Z+37	; 0x25
    4daa:	96 a1       	ldd	r25, Z+38	; 0x26
    4dac:	a7 a1       	ldd	r26, Z+39	; 0x27
    4dae:	b0 a5       	ldd	r27, Z+40	; 0x28
    4db0:	ea 85       	ldd	r30, Y+10	; 0x0a
    4db2:	fb 85       	ldd	r31, Y+11	; 0x0b
    4db4:	80 83       	st	Z, r24
    4db6:	91 83       	std	Z+1, r25	; 0x01
    4db8:	a2 83       	std	Z+2, r26	; 0x02
    4dba:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4dbc:	e0 91 8d 06 	lds	r30, 0x068D
    4dc0:	f0 91 8e 06 	lds	r31, 0x068E
    4dc4:	81 a5       	ldd	r24, Z+41	; 0x29
    4dc6:	82 30       	cpi	r24, 0x02	; 2
    4dc8:	11 f0       	breq	.+4      	; 0x4dce <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4dca:	19 82       	std	Y+1, r1	; 0x01
    4dcc:	1a c0       	rjmp	.+52     	; 0x4e02 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4dce:	e0 91 8d 06 	lds	r30, 0x068D
    4dd2:	f0 91 8e 06 	lds	r31, 0x068E
    4dd6:	25 a1       	ldd	r18, Z+37	; 0x25
    4dd8:	36 a1       	ldd	r19, Z+38	; 0x26
    4dda:	47 a1       	ldd	r20, Z+39	; 0x27
    4ddc:	50 a5       	ldd	r21, Z+40	; 0x28
    4dde:	8e 81       	ldd	r24, Y+6	; 0x06
    4de0:	9f 81       	ldd	r25, Y+7	; 0x07
    4de2:	a8 85       	ldd	r26, Y+8	; 0x08
    4de4:	b9 85       	ldd	r27, Y+9	; 0x09
    4de6:	80 95       	com	r24
    4de8:	90 95       	com	r25
    4dea:	a0 95       	com	r26
    4dec:	b0 95       	com	r27
    4dee:	82 23       	and	r24, r18
    4df0:	93 23       	and	r25, r19
    4df2:	a4 23       	and	r26, r20
    4df4:	b5 23       	and	r27, r21
    4df6:	85 a3       	std	Z+37, r24	; 0x25
    4df8:	96 a3       	std	Z+38, r25	; 0x26
    4dfa:	a7 a3       	std	Z+39, r26	; 0x27
    4dfc:	b0 a7       	std	Z+40, r27	; 0x28
				xReturn = pdTRUE;
    4dfe:	81 e0       	ldi	r24, 0x01	; 1
    4e00:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4e02:	e0 91 8d 06 	lds	r30, 0x068D
    4e06:	f0 91 8e 06 	lds	r31, 0x068E
    4e0a:	11 a6       	std	Z+41, r1	; 0x29
		}
		taskEXIT_CRITICAL();
    4e0c:	0f 90       	pop	r0
    4e0e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4e10:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4e12:	2d 96       	adiw	r28, 0x0d	; 13
    4e14:	0f b6       	in	r0, 0x3f	; 63
    4e16:	f8 94       	cli
    4e18:	de bf       	out	0x3e, r29	; 62
    4e1a:	0f be       	out	0x3f, r0	; 63
    4e1c:	cd bf       	out	0x3d, r28	; 61
    4e1e:	cf 91       	pop	r28
    4e20:	df 91       	pop	r29
    4e22:	1f 91       	pop	r17
    4e24:	0f 91       	pop	r16
    4e26:	ff 90       	pop	r15
    4e28:	ef 90       	pop	r14
    4e2a:	08 95       	ret

00004e2c <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    4e2c:	0f 93       	push	r16
    4e2e:	1f 93       	push	r17
    4e30:	df 93       	push	r29
    4e32:	cf 93       	push	r28
    4e34:	cd b7       	in	r28, 0x3d	; 61
    4e36:	de b7       	in	r29, 0x3e	; 62
    4e38:	2f 97       	sbiw	r28, 0x0f	; 15
    4e3a:	0f b6       	in	r0, 0x3f	; 63
    4e3c:	f8 94       	cli
    4e3e:	de bf       	out	0x3e, r29	; 62
    4e40:	0f be       	out	0x3f, r0	; 63
    4e42:	cd bf       	out	0x3d, r28	; 61
    4e44:	9e 83       	std	Y+6, r25	; 0x06
    4e46:	8d 83       	std	Y+5, r24	; 0x05
    4e48:	4f 83       	std	Y+7, r20	; 0x07
    4e4a:	58 87       	std	Y+8, r21	; 0x08
    4e4c:	69 87       	std	Y+9, r22	; 0x09
    4e4e:	7a 87       	std	Y+10, r23	; 0x0a
    4e50:	2b 87       	std	Y+11, r18	; 0x0b
    4e52:	1d 87       	std	Y+13, r17	; 0x0d
    4e54:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    4e56:	81 e0       	ldi	r24, 0x01	; 1
    4e58:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    4e5a:	8d 81       	ldd	r24, Y+5	; 0x05
    4e5c:	9e 81       	ldd	r25, Y+6	; 0x06
    4e5e:	9c 83       	std	Y+4, r25	; 0x04
    4e60:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    4e62:	0f b6       	in	r0, 0x3f	; 63
    4e64:	f8 94       	cli
    4e66:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    4e68:	8c 85       	ldd	r24, Y+12	; 0x0c
    4e6a:	9d 85       	ldd	r25, Y+13	; 0x0d
    4e6c:	00 97       	sbiw	r24, 0x00	; 0
    4e6e:	61 f0       	breq	.+24     	; 0x4e88 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4e70:	eb 81       	ldd	r30, Y+3	; 0x03
    4e72:	fc 81       	ldd	r31, Y+4	; 0x04
    4e74:	85 a1       	ldd	r24, Z+37	; 0x25
    4e76:	96 a1       	ldd	r25, Z+38	; 0x26
    4e78:	a7 a1       	ldd	r26, Z+39	; 0x27
    4e7a:	b0 a5       	ldd	r27, Z+40	; 0x28
    4e7c:	ec 85       	ldd	r30, Y+12	; 0x0c
    4e7e:	fd 85       	ldd	r31, Y+13	; 0x0d
    4e80:	80 83       	st	Z, r24
    4e82:	91 83       	std	Z+1, r25	; 0x01
    4e84:	a2 83       	std	Z+2, r26	; 0x02
    4e86:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4e88:	eb 81       	ldd	r30, Y+3	; 0x03
    4e8a:	fc 81       	ldd	r31, Y+4	; 0x04
    4e8c:	81 a5       	ldd	r24, Z+41	; 0x29
    4e8e:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4e90:	eb 81       	ldd	r30, Y+3	; 0x03
    4e92:	fc 81       	ldd	r31, Y+4	; 0x04
    4e94:	82 e0       	ldi	r24, 0x02	; 2
    4e96:	81 a7       	std	Z+41, r24	; 0x29

			switch( eAction )
    4e98:	8b 85       	ldd	r24, Y+11	; 0x0b
    4e9a:	28 2f       	mov	r18, r24
    4e9c:	30 e0       	ldi	r19, 0x00	; 0
    4e9e:	3f 87       	std	Y+15, r19	; 0x0f
    4ea0:	2e 87       	std	Y+14, r18	; 0x0e
    4ea2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ea4:	9f 85       	ldd	r25, Y+15	; 0x0f
    4ea6:	82 30       	cpi	r24, 0x02	; 2
    4ea8:	91 05       	cpc	r25, r1
    4eaa:	59 f1       	breq	.+86     	; 0x4f02 <xTaskGenericNotify+0xd6>
    4eac:	2e 85       	ldd	r18, Y+14	; 0x0e
    4eae:	3f 85       	ldd	r19, Y+15	; 0x0f
    4eb0:	23 30       	cpi	r18, 0x03	; 3
    4eb2:	31 05       	cpc	r19, r1
    4eb4:	34 f4       	brge	.+12     	; 0x4ec2 <xTaskGenericNotify+0x96>
    4eb6:	8e 85       	ldd	r24, Y+14	; 0x0e
    4eb8:	9f 85       	ldd	r25, Y+15	; 0x0f
    4eba:	81 30       	cpi	r24, 0x01	; 1
    4ebc:	91 05       	cpc	r25, r1
    4ebe:	61 f0       	breq	.+24     	; 0x4ed8 <xTaskGenericNotify+0xac>
    4ec0:	4a c0       	rjmp	.+148    	; 0x4f56 <xTaskGenericNotify+0x12a>
    4ec2:	2e 85       	ldd	r18, Y+14	; 0x0e
    4ec4:	3f 85       	ldd	r19, Y+15	; 0x0f
    4ec6:	23 30       	cpi	r18, 0x03	; 3
    4ec8:	31 05       	cpc	r19, r1
    4eca:	59 f1       	breq	.+86     	; 0x4f22 <xTaskGenericNotify+0xf6>
    4ecc:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ece:	9f 85       	ldd	r25, Y+15	; 0x0f
    4ed0:	84 30       	cpi	r24, 0x04	; 4
    4ed2:	91 05       	cpc	r25, r1
    4ed4:	89 f1       	breq	.+98     	; 0x4f38 <xTaskGenericNotify+0x10c>
    4ed6:	3f c0       	rjmp	.+126    	; 0x4f56 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4ed8:	eb 81       	ldd	r30, Y+3	; 0x03
    4eda:	fc 81       	ldd	r31, Y+4	; 0x04
    4edc:	25 a1       	ldd	r18, Z+37	; 0x25
    4ede:	36 a1       	ldd	r19, Z+38	; 0x26
    4ee0:	47 a1       	ldd	r20, Z+39	; 0x27
    4ee2:	50 a5       	ldd	r21, Z+40	; 0x28
    4ee4:	8f 81       	ldd	r24, Y+7	; 0x07
    4ee6:	98 85       	ldd	r25, Y+8	; 0x08
    4ee8:	a9 85       	ldd	r26, Y+9	; 0x09
    4eea:	ba 85       	ldd	r27, Y+10	; 0x0a
    4eec:	82 2b       	or	r24, r18
    4eee:	93 2b       	or	r25, r19
    4ef0:	a4 2b       	or	r26, r20
    4ef2:	b5 2b       	or	r27, r21
    4ef4:	eb 81       	ldd	r30, Y+3	; 0x03
    4ef6:	fc 81       	ldd	r31, Y+4	; 0x04
    4ef8:	85 a3       	std	Z+37, r24	; 0x25
    4efa:	96 a3       	std	Z+38, r25	; 0x26
    4efc:	a7 a3       	std	Z+39, r26	; 0x27
    4efe:	b0 a7       	std	Z+40, r27	; 0x28
    4f00:	2a c0       	rjmp	.+84     	; 0x4f56 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4f02:	eb 81       	ldd	r30, Y+3	; 0x03
    4f04:	fc 81       	ldd	r31, Y+4	; 0x04
    4f06:	85 a1       	ldd	r24, Z+37	; 0x25
    4f08:	96 a1       	ldd	r25, Z+38	; 0x26
    4f0a:	a7 a1       	ldd	r26, Z+39	; 0x27
    4f0c:	b0 a5       	ldd	r27, Z+40	; 0x28
    4f0e:	01 96       	adiw	r24, 0x01	; 1
    4f10:	a1 1d       	adc	r26, r1
    4f12:	b1 1d       	adc	r27, r1
    4f14:	eb 81       	ldd	r30, Y+3	; 0x03
    4f16:	fc 81       	ldd	r31, Y+4	; 0x04
    4f18:	85 a3       	std	Z+37, r24	; 0x25
    4f1a:	96 a3       	std	Z+38, r25	; 0x26
    4f1c:	a7 a3       	std	Z+39, r26	; 0x27
    4f1e:	b0 a7       	std	Z+40, r27	; 0x28
    4f20:	1a c0       	rjmp	.+52     	; 0x4f56 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4f22:	eb 81       	ldd	r30, Y+3	; 0x03
    4f24:	fc 81       	ldd	r31, Y+4	; 0x04
    4f26:	8f 81       	ldd	r24, Y+7	; 0x07
    4f28:	98 85       	ldd	r25, Y+8	; 0x08
    4f2a:	a9 85       	ldd	r26, Y+9	; 0x09
    4f2c:	ba 85       	ldd	r27, Y+10	; 0x0a
    4f2e:	85 a3       	std	Z+37, r24	; 0x25
    4f30:	96 a3       	std	Z+38, r25	; 0x26
    4f32:	a7 a3       	std	Z+39, r26	; 0x27
    4f34:	b0 a7       	std	Z+40, r27	; 0x28
    4f36:	0f c0       	rjmp	.+30     	; 0x4f56 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4f38:	89 81       	ldd	r24, Y+1	; 0x01
    4f3a:	82 30       	cpi	r24, 0x02	; 2
    4f3c:	59 f0       	breq	.+22     	; 0x4f54 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4f3e:	eb 81       	ldd	r30, Y+3	; 0x03
    4f40:	fc 81       	ldd	r31, Y+4	; 0x04
    4f42:	8f 81       	ldd	r24, Y+7	; 0x07
    4f44:	98 85       	ldd	r25, Y+8	; 0x08
    4f46:	a9 85       	ldd	r26, Y+9	; 0x09
    4f48:	ba 85       	ldd	r27, Y+10	; 0x0a
    4f4a:	85 a3       	std	Z+37, r24	; 0x25
    4f4c:	96 a3       	std	Z+38, r25	; 0x26
    4f4e:	a7 a3       	std	Z+39, r26	; 0x27
    4f50:	b0 a7       	std	Z+40, r27	; 0x28
    4f52:	01 c0       	rjmp	.+2      	; 0x4f56 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4f54:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4f56:	89 81       	ldd	r24, Y+1	; 0x01
    4f58:	81 30       	cpi	r24, 0x01	; 1
    4f5a:	b9 f5       	brne	.+110    	; 0x4fca <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4f5c:	8b 81       	ldd	r24, Y+3	; 0x03
    4f5e:	9c 81       	ldd	r25, Y+4	; 0x04
    4f60:	02 96       	adiw	r24, 0x02	; 2
    4f62:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    4f66:	eb 81       	ldd	r30, Y+3	; 0x03
    4f68:	fc 81       	ldd	r31, Y+4	; 0x04
    4f6a:	96 89       	ldd	r25, Z+22	; 0x16
    4f6c:	80 91 93 06 	lds	r24, 0x0693
    4f70:	89 17       	cp	r24, r25
    4f72:	28 f4       	brcc	.+10     	; 0x4f7e <xTaskGenericNotify+0x152>
    4f74:	eb 81       	ldd	r30, Y+3	; 0x03
    4f76:	fc 81       	ldd	r31, Y+4	; 0x04
    4f78:	86 89       	ldd	r24, Z+22	; 0x16
    4f7a:	80 93 93 06 	sts	0x0693, r24
    4f7e:	eb 81       	ldd	r30, Y+3	; 0x03
    4f80:	fc 81       	ldd	r31, Y+4	; 0x04
    4f82:	86 89       	ldd	r24, Z+22	; 0x16
    4f84:	28 2f       	mov	r18, r24
    4f86:	30 e0       	ldi	r19, 0x00	; 0
    4f88:	c9 01       	movw	r24, r18
    4f8a:	88 0f       	add	r24, r24
    4f8c:	99 1f       	adc	r25, r25
    4f8e:	88 0f       	add	r24, r24
    4f90:	99 1f       	adc	r25, r25
    4f92:	88 0f       	add	r24, r24
    4f94:	99 1f       	adc	r25, r25
    4f96:	82 0f       	add	r24, r18
    4f98:	93 1f       	adc	r25, r19
    4f9a:	ac 01       	movw	r20, r24
    4f9c:	42 56       	subi	r20, 0x62	; 98
    4f9e:	59 4f       	sbci	r21, 0xF9	; 249
    4fa0:	8b 81       	ldd	r24, Y+3	; 0x03
    4fa2:	9c 81       	ldd	r25, Y+4	; 0x04
    4fa4:	9c 01       	movw	r18, r24
    4fa6:	2e 5f       	subi	r18, 0xFE	; 254
    4fa8:	3f 4f       	sbci	r19, 0xFF	; 255
    4faa:	ca 01       	movw	r24, r20
    4fac:	b9 01       	movw	r22, r18
    4fae:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4fb2:	eb 81       	ldd	r30, Y+3	; 0x03
    4fb4:	fc 81       	ldd	r31, Y+4	; 0x04
    4fb6:	96 89       	ldd	r25, Z+22	; 0x16
    4fb8:	e0 91 8d 06 	lds	r30, 0x068D
    4fbc:	f0 91 8e 06 	lds	r31, 0x068E
    4fc0:	86 89       	ldd	r24, Z+22	; 0x16
    4fc2:	89 17       	cp	r24, r25
    4fc4:	10 f4       	brcc	.+4      	; 0x4fca <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4fc6:	0e 94 43 0d 	call	0x1a86	; 0x1a86 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4fca:	0f 90       	pop	r0
    4fcc:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4fce:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4fd0:	2f 96       	adiw	r28, 0x0f	; 15
    4fd2:	0f b6       	in	r0, 0x3f	; 63
    4fd4:	f8 94       	cli
    4fd6:	de bf       	out	0x3e, r29	; 62
    4fd8:	0f be       	out	0x3f, r0	; 63
    4fda:	cd bf       	out	0x3d, r28	; 61
    4fdc:	cf 91       	pop	r28
    4fde:	df 91       	pop	r29
    4fe0:	1f 91       	pop	r17
    4fe2:	0f 91       	pop	r16
    4fe4:	08 95       	ret

00004fe6 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4fe6:	ef 92       	push	r14
    4fe8:	ff 92       	push	r15
    4fea:	0f 93       	push	r16
    4fec:	1f 93       	push	r17
    4fee:	df 93       	push	r29
    4ff0:	cf 93       	push	r28
    4ff2:	cd b7       	in	r28, 0x3d	; 61
    4ff4:	de b7       	in	r29, 0x3e	; 62
    4ff6:	62 97       	sbiw	r28, 0x12	; 18
    4ff8:	0f b6       	in	r0, 0x3f	; 63
    4ffa:	f8 94       	cli
    4ffc:	de bf       	out	0x3e, r29	; 62
    4ffe:	0f be       	out	0x3f, r0	; 63
    5000:	cd bf       	out	0x3d, r28	; 61
    5002:	9f 83       	std	Y+7, r25	; 0x07
    5004:	8e 83       	std	Y+6, r24	; 0x06
    5006:	48 87       	std	Y+8, r20	; 0x08
    5008:	59 87       	std	Y+9, r21	; 0x09
    500a:	6a 87       	std	Y+10, r22	; 0x0a
    500c:	7b 87       	std	Y+11, r23	; 0x0b
    500e:	2c 87       	std	Y+12, r18	; 0x0c
    5010:	1e 87       	std	Y+14, r17	; 0x0e
    5012:	0d 87       	std	Y+13, r16	; 0x0d
    5014:	f8 8a       	std	Y+16, r15	; 0x10
    5016:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    5018:	81 e0       	ldi	r24, 0x01	; 1
    501a:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    501c:	8e 81       	ldd	r24, Y+6	; 0x06
    501e:	9f 81       	ldd	r25, Y+7	; 0x07
    5020:	9d 83       	std	Y+5, r25	; 0x05
    5022:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5024:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    5026:	8d 85       	ldd	r24, Y+13	; 0x0d
    5028:	9e 85       	ldd	r25, Y+14	; 0x0e
    502a:	00 97       	sbiw	r24, 0x00	; 0
    502c:	61 f0       	breq	.+24     	; 0x5046 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    502e:	ec 81       	ldd	r30, Y+4	; 0x04
    5030:	fd 81       	ldd	r31, Y+5	; 0x05
    5032:	85 a1       	ldd	r24, Z+37	; 0x25
    5034:	96 a1       	ldd	r25, Z+38	; 0x26
    5036:	a7 a1       	ldd	r26, Z+39	; 0x27
    5038:	b0 a5       	ldd	r27, Z+40	; 0x28
    503a:	ed 85       	ldd	r30, Y+13	; 0x0d
    503c:	fe 85       	ldd	r31, Y+14	; 0x0e
    503e:	80 83       	st	Z, r24
    5040:	91 83       	std	Z+1, r25	; 0x01
    5042:	a2 83       	std	Z+2, r26	; 0x02
    5044:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    5046:	ec 81       	ldd	r30, Y+4	; 0x04
    5048:	fd 81       	ldd	r31, Y+5	; 0x05
    504a:	81 a5       	ldd	r24, Z+41	; 0x29
    504c:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    504e:	ec 81       	ldd	r30, Y+4	; 0x04
    5050:	fd 81       	ldd	r31, Y+5	; 0x05
    5052:	82 e0       	ldi	r24, 0x02	; 2
    5054:	81 a7       	std	Z+41, r24	; 0x29

			switch( eAction )
    5056:	8c 85       	ldd	r24, Y+12	; 0x0c
    5058:	28 2f       	mov	r18, r24
    505a:	30 e0       	ldi	r19, 0x00	; 0
    505c:	3a 8b       	std	Y+18, r19	; 0x12
    505e:	29 8b       	std	Y+17, r18	; 0x11
    5060:	89 89       	ldd	r24, Y+17	; 0x11
    5062:	9a 89       	ldd	r25, Y+18	; 0x12
    5064:	82 30       	cpi	r24, 0x02	; 2
    5066:	91 05       	cpc	r25, r1
    5068:	59 f1       	breq	.+86     	; 0x50c0 <xTaskGenericNotifyFromISR+0xda>
    506a:	29 89       	ldd	r18, Y+17	; 0x11
    506c:	3a 89       	ldd	r19, Y+18	; 0x12
    506e:	23 30       	cpi	r18, 0x03	; 3
    5070:	31 05       	cpc	r19, r1
    5072:	34 f4       	brge	.+12     	; 0x5080 <xTaskGenericNotifyFromISR+0x9a>
    5074:	89 89       	ldd	r24, Y+17	; 0x11
    5076:	9a 89       	ldd	r25, Y+18	; 0x12
    5078:	81 30       	cpi	r24, 0x01	; 1
    507a:	91 05       	cpc	r25, r1
    507c:	61 f0       	breq	.+24     	; 0x5096 <xTaskGenericNotifyFromISR+0xb0>
    507e:	4a c0       	rjmp	.+148    	; 0x5114 <xTaskGenericNotifyFromISR+0x12e>
    5080:	29 89       	ldd	r18, Y+17	; 0x11
    5082:	3a 89       	ldd	r19, Y+18	; 0x12
    5084:	23 30       	cpi	r18, 0x03	; 3
    5086:	31 05       	cpc	r19, r1
    5088:	59 f1       	breq	.+86     	; 0x50e0 <xTaskGenericNotifyFromISR+0xfa>
    508a:	89 89       	ldd	r24, Y+17	; 0x11
    508c:	9a 89       	ldd	r25, Y+18	; 0x12
    508e:	84 30       	cpi	r24, 0x04	; 4
    5090:	91 05       	cpc	r25, r1
    5092:	89 f1       	breq	.+98     	; 0x50f6 <xTaskGenericNotifyFromISR+0x110>
    5094:	3f c0       	rjmp	.+126    	; 0x5114 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    5096:	ec 81       	ldd	r30, Y+4	; 0x04
    5098:	fd 81       	ldd	r31, Y+5	; 0x05
    509a:	25 a1       	ldd	r18, Z+37	; 0x25
    509c:	36 a1       	ldd	r19, Z+38	; 0x26
    509e:	47 a1       	ldd	r20, Z+39	; 0x27
    50a0:	50 a5       	ldd	r21, Z+40	; 0x28
    50a2:	88 85       	ldd	r24, Y+8	; 0x08
    50a4:	99 85       	ldd	r25, Y+9	; 0x09
    50a6:	aa 85       	ldd	r26, Y+10	; 0x0a
    50a8:	bb 85       	ldd	r27, Y+11	; 0x0b
    50aa:	82 2b       	or	r24, r18
    50ac:	93 2b       	or	r25, r19
    50ae:	a4 2b       	or	r26, r20
    50b0:	b5 2b       	or	r27, r21
    50b2:	ec 81       	ldd	r30, Y+4	; 0x04
    50b4:	fd 81       	ldd	r31, Y+5	; 0x05
    50b6:	85 a3       	std	Z+37, r24	; 0x25
    50b8:	96 a3       	std	Z+38, r25	; 0x26
    50ba:	a7 a3       	std	Z+39, r26	; 0x27
    50bc:	b0 a7       	std	Z+40, r27	; 0x28
    50be:	2a c0       	rjmp	.+84     	; 0x5114 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    50c0:	ec 81       	ldd	r30, Y+4	; 0x04
    50c2:	fd 81       	ldd	r31, Y+5	; 0x05
    50c4:	85 a1       	ldd	r24, Z+37	; 0x25
    50c6:	96 a1       	ldd	r25, Z+38	; 0x26
    50c8:	a7 a1       	ldd	r26, Z+39	; 0x27
    50ca:	b0 a5       	ldd	r27, Z+40	; 0x28
    50cc:	01 96       	adiw	r24, 0x01	; 1
    50ce:	a1 1d       	adc	r26, r1
    50d0:	b1 1d       	adc	r27, r1
    50d2:	ec 81       	ldd	r30, Y+4	; 0x04
    50d4:	fd 81       	ldd	r31, Y+5	; 0x05
    50d6:	85 a3       	std	Z+37, r24	; 0x25
    50d8:	96 a3       	std	Z+38, r25	; 0x26
    50da:	a7 a3       	std	Z+39, r26	; 0x27
    50dc:	b0 a7       	std	Z+40, r27	; 0x28
    50de:	1a c0       	rjmp	.+52     	; 0x5114 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    50e0:	ec 81       	ldd	r30, Y+4	; 0x04
    50e2:	fd 81       	ldd	r31, Y+5	; 0x05
    50e4:	88 85       	ldd	r24, Y+8	; 0x08
    50e6:	99 85       	ldd	r25, Y+9	; 0x09
    50e8:	aa 85       	ldd	r26, Y+10	; 0x0a
    50ea:	bb 85       	ldd	r27, Y+11	; 0x0b
    50ec:	85 a3       	std	Z+37, r24	; 0x25
    50ee:	96 a3       	std	Z+38, r25	; 0x26
    50f0:	a7 a3       	std	Z+39, r26	; 0x27
    50f2:	b0 a7       	std	Z+40, r27	; 0x28
    50f4:	0f c0       	rjmp	.+30     	; 0x5114 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    50f6:	8b 81       	ldd	r24, Y+3	; 0x03
    50f8:	82 30       	cpi	r24, 0x02	; 2
    50fa:	59 f0       	breq	.+22     	; 0x5112 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    50fc:	ec 81       	ldd	r30, Y+4	; 0x04
    50fe:	fd 81       	ldd	r31, Y+5	; 0x05
    5100:	88 85       	ldd	r24, Y+8	; 0x08
    5102:	99 85       	ldd	r25, Y+9	; 0x09
    5104:	aa 85       	ldd	r26, Y+10	; 0x0a
    5106:	bb 85       	ldd	r27, Y+11	; 0x0b
    5108:	85 a3       	std	Z+37, r24	; 0x25
    510a:	96 a3       	std	Z+38, r25	; 0x26
    510c:	a7 a3       	std	Z+39, r26	; 0x27
    510e:	b0 a7       	std	Z+40, r27	; 0x28
    5110:	01 c0       	rjmp	.+2      	; 0x5114 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    5112:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5114:	8b 81       	ldd	r24, Y+3	; 0x03
    5116:	81 30       	cpi	r24, 0x01	; 1
    5118:	09 f0       	breq	.+2      	; 0x511c <xTaskGenericNotifyFromISR+0x136>
    511a:	4f c0       	rjmp	.+158    	; 0x51ba <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    511c:	80 91 9d 06 	lds	r24, 0x069D
    5120:	88 23       	and	r24, r24
    5122:	61 f5       	brne	.+88     	; 0x517c <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5124:	8c 81       	ldd	r24, Y+4	; 0x04
    5126:	9d 81       	ldd	r25, Y+5	; 0x05
    5128:	02 96       	adiw	r24, 0x02	; 2
    512a:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    512e:	ec 81       	ldd	r30, Y+4	; 0x04
    5130:	fd 81       	ldd	r31, Y+5	; 0x05
    5132:	96 89       	ldd	r25, Z+22	; 0x16
    5134:	80 91 93 06 	lds	r24, 0x0693
    5138:	89 17       	cp	r24, r25
    513a:	28 f4       	brcc	.+10     	; 0x5146 <xTaskGenericNotifyFromISR+0x160>
    513c:	ec 81       	ldd	r30, Y+4	; 0x04
    513e:	fd 81       	ldd	r31, Y+5	; 0x05
    5140:	86 89       	ldd	r24, Z+22	; 0x16
    5142:	80 93 93 06 	sts	0x0693, r24
    5146:	ec 81       	ldd	r30, Y+4	; 0x04
    5148:	fd 81       	ldd	r31, Y+5	; 0x05
    514a:	86 89       	ldd	r24, Z+22	; 0x16
    514c:	28 2f       	mov	r18, r24
    514e:	30 e0       	ldi	r19, 0x00	; 0
    5150:	c9 01       	movw	r24, r18
    5152:	88 0f       	add	r24, r24
    5154:	99 1f       	adc	r25, r25
    5156:	88 0f       	add	r24, r24
    5158:	99 1f       	adc	r25, r25
    515a:	88 0f       	add	r24, r24
    515c:	99 1f       	adc	r25, r25
    515e:	82 0f       	add	r24, r18
    5160:	93 1f       	adc	r25, r19
    5162:	ac 01       	movw	r20, r24
    5164:	42 56       	subi	r20, 0x62	; 98
    5166:	59 4f       	sbci	r21, 0xF9	; 249
    5168:	8c 81       	ldd	r24, Y+4	; 0x04
    516a:	9d 81       	ldd	r25, Y+5	; 0x05
    516c:	9c 01       	movw	r18, r24
    516e:	2e 5f       	subi	r18, 0xFE	; 254
    5170:	3f 4f       	sbci	r19, 0xFF	; 255
    5172:	ca 01       	movw	r24, r20
    5174:	b9 01       	movw	r22, r18
    5176:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>
    517a:	0a c0       	rjmp	.+20     	; 0x5190 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    517c:	8c 81       	ldd	r24, Y+4	; 0x04
    517e:	9d 81       	ldd	r25, Y+5	; 0x05
    5180:	9c 01       	movw	r18, r24
    5182:	24 5f       	subi	r18, 0xF4	; 244
    5184:	3f 4f       	sbci	r19, 0xFF	; 255
    5186:	88 ed       	ldi	r24, 0xD8	; 216
    5188:	96 e0       	ldi	r25, 0x06	; 6
    518a:	b9 01       	movw	r22, r18
    518c:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5190:	ec 81       	ldd	r30, Y+4	; 0x04
    5192:	fd 81       	ldd	r31, Y+5	; 0x05
    5194:	96 89       	ldd	r25, Z+22	; 0x16
    5196:	e0 91 8d 06 	lds	r30, 0x068D
    519a:	f0 91 8e 06 	lds	r31, 0x068E
    519e:	86 89       	ldd	r24, Z+22	; 0x16
    51a0:	89 17       	cp	r24, r25
    51a2:	58 f4       	brcc	.+22     	; 0x51ba <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    51a4:	8f 85       	ldd	r24, Y+15	; 0x0f
    51a6:	98 89       	ldd	r25, Y+16	; 0x10
    51a8:	00 97       	sbiw	r24, 0x00	; 0
    51aa:	21 f0       	breq	.+8      	; 0x51b4 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    51ac:	ef 85       	ldd	r30, Y+15	; 0x0f
    51ae:	f8 89       	ldd	r31, Y+16	; 0x10
    51b0:	81 e0       	ldi	r24, 0x01	; 1
    51b2:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    51b4:	81 e0       	ldi	r24, 0x01	; 1
    51b6:	80 93 96 06 	sts	0x0696, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    51ba:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    51bc:	62 96       	adiw	r28, 0x12	; 18
    51be:	0f b6       	in	r0, 0x3f	; 63
    51c0:	f8 94       	cli
    51c2:	de bf       	out	0x3e, r29	; 62
    51c4:	0f be       	out	0x3f, r0	; 63
    51c6:	cd bf       	out	0x3d, r28	; 61
    51c8:	cf 91       	pop	r28
    51ca:	df 91       	pop	r29
    51cc:	1f 91       	pop	r17
    51ce:	0f 91       	pop	r16
    51d0:	ff 90       	pop	r15
    51d2:	ef 90       	pop	r14
    51d4:	08 95       	ret

000051d6 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    51d6:	df 93       	push	r29
    51d8:	cf 93       	push	r28
    51da:	cd b7       	in	r28, 0x3d	; 61
    51dc:	de b7       	in	r29, 0x3e	; 62
    51de:	28 97       	sbiw	r28, 0x08	; 8
    51e0:	0f b6       	in	r0, 0x3f	; 63
    51e2:	f8 94       	cli
    51e4:	de bf       	out	0x3e, r29	; 62
    51e6:	0f be       	out	0x3f, r0	; 63
    51e8:	cd bf       	out	0x3d, r28	; 61
    51ea:	9e 83       	std	Y+6, r25	; 0x06
    51ec:	8d 83       	std	Y+5, r24	; 0x05
    51ee:	78 87       	std	Y+8, r23	; 0x08
    51f0:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    51f2:	8d 81       	ldd	r24, Y+5	; 0x05
    51f4:	9e 81       	ldd	r25, Y+6	; 0x06
    51f6:	9c 83       	std	Y+4, r25	; 0x04
    51f8:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    51fa:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    51fc:	eb 81       	ldd	r30, Y+3	; 0x03
    51fe:	fc 81       	ldd	r31, Y+4	; 0x04
    5200:	81 a5       	ldd	r24, Z+41	; 0x29
    5202:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    5204:	eb 81       	ldd	r30, Y+3	; 0x03
    5206:	fc 81       	ldd	r31, Y+4	; 0x04
    5208:	82 e0       	ldi	r24, 0x02	; 2
    520a:	81 a7       	std	Z+41, r24	; 0x29

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    520c:	eb 81       	ldd	r30, Y+3	; 0x03
    520e:	fc 81       	ldd	r31, Y+4	; 0x04
    5210:	85 a1       	ldd	r24, Z+37	; 0x25
    5212:	96 a1       	ldd	r25, Z+38	; 0x26
    5214:	a7 a1       	ldd	r26, Z+39	; 0x27
    5216:	b0 a5       	ldd	r27, Z+40	; 0x28
    5218:	01 96       	adiw	r24, 0x01	; 1
    521a:	a1 1d       	adc	r26, r1
    521c:	b1 1d       	adc	r27, r1
    521e:	eb 81       	ldd	r30, Y+3	; 0x03
    5220:	fc 81       	ldd	r31, Y+4	; 0x04
    5222:	85 a3       	std	Z+37, r24	; 0x25
    5224:	96 a3       	std	Z+38, r25	; 0x26
    5226:	a7 a3       	std	Z+39, r26	; 0x27
    5228:	b0 a7       	std	Z+40, r27	; 0x28

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    522a:	8a 81       	ldd	r24, Y+2	; 0x02
    522c:	81 30       	cpi	r24, 0x01	; 1
    522e:	09 f0       	breq	.+2      	; 0x5232 <vTaskNotifyGiveFromISR+0x5c>
    5230:	4f c0       	rjmp	.+158    	; 0x52d0 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5232:	80 91 9d 06 	lds	r24, 0x069D
    5236:	88 23       	and	r24, r24
    5238:	61 f5       	brne	.+88     	; 0x5292 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    523a:	8b 81       	ldd	r24, Y+3	; 0x03
    523c:	9c 81       	ldd	r25, Y+4	; 0x04
    523e:	02 96       	adiw	r24, 0x02	; 2
    5240:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5244:	eb 81       	ldd	r30, Y+3	; 0x03
    5246:	fc 81       	ldd	r31, Y+4	; 0x04
    5248:	96 89       	ldd	r25, Z+22	; 0x16
    524a:	80 91 93 06 	lds	r24, 0x0693
    524e:	89 17       	cp	r24, r25
    5250:	28 f4       	brcc	.+10     	; 0x525c <vTaskNotifyGiveFromISR+0x86>
    5252:	eb 81       	ldd	r30, Y+3	; 0x03
    5254:	fc 81       	ldd	r31, Y+4	; 0x04
    5256:	86 89       	ldd	r24, Z+22	; 0x16
    5258:	80 93 93 06 	sts	0x0693, r24
    525c:	eb 81       	ldd	r30, Y+3	; 0x03
    525e:	fc 81       	ldd	r31, Y+4	; 0x04
    5260:	86 89       	ldd	r24, Z+22	; 0x16
    5262:	28 2f       	mov	r18, r24
    5264:	30 e0       	ldi	r19, 0x00	; 0
    5266:	c9 01       	movw	r24, r18
    5268:	88 0f       	add	r24, r24
    526a:	99 1f       	adc	r25, r25
    526c:	88 0f       	add	r24, r24
    526e:	99 1f       	adc	r25, r25
    5270:	88 0f       	add	r24, r24
    5272:	99 1f       	adc	r25, r25
    5274:	82 0f       	add	r24, r18
    5276:	93 1f       	adc	r25, r19
    5278:	ac 01       	movw	r20, r24
    527a:	42 56       	subi	r20, 0x62	; 98
    527c:	59 4f       	sbci	r21, 0xF9	; 249
    527e:	8b 81       	ldd	r24, Y+3	; 0x03
    5280:	9c 81       	ldd	r25, Y+4	; 0x04
    5282:	9c 01       	movw	r18, r24
    5284:	2e 5f       	subi	r18, 0xFE	; 254
    5286:	3f 4f       	sbci	r19, 0xFF	; 255
    5288:	ca 01       	movw	r24, r20
    528a:	b9 01       	movw	r22, r18
    528c:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>
    5290:	0a c0       	rjmp	.+20     	; 0x52a6 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5292:	8b 81       	ldd	r24, Y+3	; 0x03
    5294:	9c 81       	ldd	r25, Y+4	; 0x04
    5296:	9c 01       	movw	r18, r24
    5298:	24 5f       	subi	r18, 0xF4	; 244
    529a:	3f 4f       	sbci	r19, 0xFF	; 255
    529c:	88 ed       	ldi	r24, 0xD8	; 216
    529e:	96 e0       	ldi	r25, 0x06	; 6
    52a0:	b9 01       	movw	r22, r18
    52a2:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    52a6:	eb 81       	ldd	r30, Y+3	; 0x03
    52a8:	fc 81       	ldd	r31, Y+4	; 0x04
    52aa:	96 89       	ldd	r25, Z+22	; 0x16
    52ac:	e0 91 8d 06 	lds	r30, 0x068D
    52b0:	f0 91 8e 06 	lds	r31, 0x068E
    52b4:	86 89       	ldd	r24, Z+22	; 0x16
    52b6:	89 17       	cp	r24, r25
    52b8:	58 f4       	brcc	.+22     	; 0x52d0 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    52ba:	8f 81       	ldd	r24, Y+7	; 0x07
    52bc:	98 85       	ldd	r25, Y+8	; 0x08
    52be:	00 97       	sbiw	r24, 0x00	; 0
    52c0:	21 f0       	breq	.+8      	; 0x52ca <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    52c2:	ef 81       	ldd	r30, Y+7	; 0x07
    52c4:	f8 85       	ldd	r31, Y+8	; 0x08
    52c6:	81 e0       	ldi	r24, 0x01	; 1
    52c8:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    52ca:	81 e0       	ldi	r24, 0x01	; 1
    52cc:	80 93 96 06 	sts	0x0696, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    52d0:	28 96       	adiw	r28, 0x08	; 8
    52d2:	0f b6       	in	r0, 0x3f	; 63
    52d4:	f8 94       	cli
    52d6:	de bf       	out	0x3e, r29	; 62
    52d8:	0f be       	out	0x3f, r0	; 63
    52da:	cd bf       	out	0x3d, r28	; 61
    52dc:	cf 91       	pop	r28
    52de:	df 91       	pop	r29
    52e0:	08 95       	ret

000052e2 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    52e2:	df 93       	push	r29
    52e4:	cf 93       	push	r28
    52e6:	cd b7       	in	r28, 0x3d	; 61
    52e8:	de b7       	in	r29, 0x3e	; 62
    52ea:	27 97       	sbiw	r28, 0x07	; 7
    52ec:	0f b6       	in	r0, 0x3f	; 63
    52ee:	f8 94       	cli
    52f0:	de bf       	out	0x3e, r29	; 62
    52f2:	0f be       	out	0x3f, r0	; 63
    52f4:	cd bf       	out	0x3d, r28	; 61
    52f6:	9d 83       	std	Y+5, r25	; 0x05
    52f8:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    52fa:	8c 81       	ldd	r24, Y+4	; 0x04
    52fc:	9d 81       	ldd	r25, Y+5	; 0x05
    52fe:	00 97       	sbiw	r24, 0x00	; 0
    5300:	39 f4       	brne	.+14     	; 0x5310 <xTaskNotifyStateClear+0x2e>
    5302:	80 91 8d 06 	lds	r24, 0x068D
    5306:	90 91 8e 06 	lds	r25, 0x068E
    530a:	9f 83       	std	Y+7, r25	; 0x07
    530c:	8e 83       	std	Y+6, r24	; 0x06
    530e:	04 c0       	rjmp	.+8      	; 0x5318 <xTaskNotifyStateClear+0x36>
    5310:	8c 81       	ldd	r24, Y+4	; 0x04
    5312:	9d 81       	ldd	r25, Y+5	; 0x05
    5314:	9f 83       	std	Y+7, r25	; 0x07
    5316:	8e 83       	std	Y+6, r24	; 0x06
    5318:	8e 81       	ldd	r24, Y+6	; 0x06
    531a:	9f 81       	ldd	r25, Y+7	; 0x07
    531c:	9b 83       	std	Y+3, r25	; 0x03
    531e:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    5320:	0f b6       	in	r0, 0x3f	; 63
    5322:	f8 94       	cli
    5324:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    5326:	ea 81       	ldd	r30, Y+2	; 0x02
    5328:	fb 81       	ldd	r31, Y+3	; 0x03
    532a:	81 a5       	ldd	r24, Z+41	; 0x29
    532c:	82 30       	cpi	r24, 0x02	; 2
    532e:	31 f4       	brne	.+12     	; 0x533c <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    5330:	ea 81       	ldd	r30, Y+2	; 0x02
    5332:	fb 81       	ldd	r31, Y+3	; 0x03
    5334:	11 a6       	std	Z+41, r1	; 0x29
				xReturn = pdPASS;
    5336:	81 e0       	ldi	r24, 0x01	; 1
    5338:	89 83       	std	Y+1, r24	; 0x01
    533a:	01 c0       	rjmp	.+2      	; 0x533e <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    533c:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    533e:	0f 90       	pop	r0
    5340:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    5342:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5344:	27 96       	adiw	r28, 0x07	; 7
    5346:	0f b6       	in	r0, 0x3f	; 63
    5348:	f8 94       	cli
    534a:	de bf       	out	0x3e, r29	; 62
    534c:	0f be       	out	0x3f, r0	; 63
    534e:	cd bf       	out	0x3d, r28	; 61
    5350:	cf 91       	pop	r28
    5352:	df 91       	pop	r29
    5354:	08 95       	ret

00005356 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    5356:	df 93       	push	r29
    5358:	cf 93       	push	r28
    535a:	cd b7       	in	r28, 0x3d	; 61
    535c:	de b7       	in	r29, 0x3e	; 62
    535e:	27 97       	sbiw	r28, 0x07	; 7
    5360:	0f b6       	in	r0, 0x3f	; 63
    5362:	f8 94       	cli
    5364:	de bf       	out	0x3e, r29	; 62
    5366:	0f be       	out	0x3f, r0	; 63
    5368:	cd bf       	out	0x3d, r28	; 61
    536a:	9e 83       	std	Y+6, r25	; 0x06
    536c:	8d 83       	std	Y+5, r24	; 0x05
    536e:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    5370:	80 91 91 06 	lds	r24, 0x0691
    5374:	90 91 92 06 	lds	r25, 0x0692
    5378:	9a 83       	std	Y+2, r25	; 0x02
    537a:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    537c:	80 91 8d 06 	lds	r24, 0x068D
    5380:	90 91 8e 06 	lds	r25, 0x068E
    5384:	02 96       	adiw	r24, 0x02	; 2
    5386:	0e 94 1b 0b 	call	0x1636	; 0x1636 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    538a:	8d 81       	ldd	r24, Y+5	; 0x05
    538c:	9e 81       	ldd	r25, Y+6	; 0x06
    538e:	2f ef       	ldi	r18, 0xFF	; 255
    5390:	8f 3f       	cpi	r24, 0xFF	; 255
    5392:	92 07       	cpc	r25, r18
    5394:	81 f4       	brne	.+32     	; 0x53b6 <prvAddCurrentTaskToDelayedList+0x60>
    5396:	8f 81       	ldd	r24, Y+7	; 0x07
    5398:	88 23       	and	r24, r24
    539a:	69 f0       	breq	.+26     	; 0x53b6 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    539c:	80 91 8d 06 	lds	r24, 0x068D
    53a0:	90 91 8e 06 	lds	r25, 0x068E
    53a4:	9c 01       	movw	r18, r24
    53a6:	2e 5f       	subi	r18, 0xFE	; 254
    53a8:	3f 4f       	sbci	r19, 0xFF	; 255
    53aa:	8a ee       	ldi	r24, 0xEA	; 234
    53ac:	96 e0       	ldi	r25, 0x06	; 6
    53ae:	b9 01       	movw	r22, r18
    53b0:	0e 94 6b 0a 	call	0x14d6	; 0x14d6 <vListInsertEnd>
    53b4:	43 c0       	rjmp	.+134    	; 0x543c <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    53b6:	29 81       	ldd	r18, Y+1	; 0x01
    53b8:	3a 81       	ldd	r19, Y+2	; 0x02
    53ba:	8d 81       	ldd	r24, Y+5	; 0x05
    53bc:	9e 81       	ldd	r25, Y+6	; 0x06
    53be:	82 0f       	add	r24, r18
    53c0:	93 1f       	adc	r25, r19
    53c2:	9c 83       	std	Y+4, r25	; 0x04
    53c4:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    53c6:	e0 91 8d 06 	lds	r30, 0x068D
    53ca:	f0 91 8e 06 	lds	r31, 0x068E
    53ce:	8b 81       	ldd	r24, Y+3	; 0x03
    53d0:	9c 81       	ldd	r25, Y+4	; 0x04
    53d2:	93 83       	std	Z+3, r25	; 0x03
    53d4:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    53d6:	2b 81       	ldd	r18, Y+3	; 0x03
    53d8:	3c 81       	ldd	r19, Y+4	; 0x04
    53da:	89 81       	ldd	r24, Y+1	; 0x01
    53dc:	9a 81       	ldd	r25, Y+2	; 0x02
    53de:	28 17       	cp	r18, r24
    53e0:	39 07       	cpc	r19, r25
    53e2:	70 f4       	brcc	.+28     	; 0x5400 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    53e4:	80 91 d6 06 	lds	r24, 0x06D6
    53e8:	90 91 d7 06 	lds	r25, 0x06D7
    53ec:	20 91 8d 06 	lds	r18, 0x068D
    53f0:	30 91 8e 06 	lds	r19, 0x068E
    53f4:	2e 5f       	subi	r18, 0xFE	; 254
    53f6:	3f 4f       	sbci	r19, 0xFF	; 255
    53f8:	b9 01       	movw	r22, r18
    53fa:	0e 94 af 0a 	call	0x155e	; 0x155e <vListInsert>
    53fe:	1e c0       	rjmp	.+60     	; 0x543c <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5400:	40 91 d4 06 	lds	r20, 0x06D4
    5404:	50 91 d5 06 	lds	r21, 0x06D5
    5408:	80 91 8d 06 	lds	r24, 0x068D
    540c:	90 91 8e 06 	lds	r25, 0x068E
    5410:	9c 01       	movw	r18, r24
    5412:	2e 5f       	subi	r18, 0xFE	; 254
    5414:	3f 4f       	sbci	r19, 0xFF	; 255
    5416:	ca 01       	movw	r24, r20
    5418:	b9 01       	movw	r22, r18
    541a:	0e 94 af 0a 	call	0x155e	; 0x155e <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    541e:	20 91 99 06 	lds	r18, 0x0699
    5422:	30 91 9a 06 	lds	r19, 0x069A
    5426:	8b 81       	ldd	r24, Y+3	; 0x03
    5428:	9c 81       	ldd	r25, Y+4	; 0x04
    542a:	82 17       	cp	r24, r18
    542c:	93 07       	cpc	r25, r19
    542e:	30 f4       	brcc	.+12     	; 0x543c <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    5430:	8b 81       	ldd	r24, Y+3	; 0x03
    5432:	9c 81       	ldd	r25, Y+4	; 0x04
    5434:	90 93 9a 06 	sts	0x069A, r25
    5438:	80 93 99 06 	sts	0x0699, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    543c:	27 96       	adiw	r28, 0x07	; 7
    543e:	0f b6       	in	r0, 0x3f	; 63
    5440:	f8 94       	cli
    5442:	de bf       	out	0x3e, r29	; 62
    5444:	0f be       	out	0x3f, r0	; 63
    5446:	cd bf       	out	0x3d, r28	; 61
    5448:	cf 91       	pop	r28
    544a:	df 91       	pop	r29
    544c:	08 95       	ret

0000544e <memcpy>:
    544e:	fb 01       	movw	r30, r22
    5450:	dc 01       	movw	r26, r24
    5452:	02 c0       	rjmp	.+4      	; 0x5458 <memcpy+0xa>
    5454:	01 90       	ld	r0, Z+
    5456:	0d 92       	st	X+, r0
    5458:	41 50       	subi	r20, 0x01	; 1
    545a:	50 40       	sbci	r21, 0x00	; 0
    545c:	d8 f7       	brcc	.-10     	; 0x5454 <memcpy+0x6>
    545e:	08 95       	ret

00005460 <memset>:
    5460:	dc 01       	movw	r26, r24
    5462:	01 c0       	rjmp	.+2      	; 0x5466 <memset+0x6>
    5464:	6d 93       	st	X+, r22
    5466:	41 50       	subi	r20, 0x01	; 1
    5468:	50 40       	sbci	r21, 0x00	; 0
    546a:	e0 f7       	brcc	.-8      	; 0x5464 <memset+0x4>
    546c:	08 95       	ret

0000546e <_exit>:
    546e:	f8 94       	cli

00005470 <__stop_program>:
    5470:	ff cf       	rjmp	.-2      	; 0x5470 <__stop_program>
